
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>wbia.algo.graph.mixin_matching &#8212; wbia 2.2.4 documentation</title>
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />

  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />


  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">


          <div class="body" role="main">

  <h1>Source code for wbia.algo.graph.mixin_matching</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">join</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">wbia.algo.graph</span> <span class="k">import</span> <span class="n">nx_utils</span> <span class="k">as</span> <span class="n">nxu</span>
<span class="kn">from</span> <span class="nn">wbia.algo.graph.nx_utils</span> <span class="k">import</span> <span class="n">e_</span>
<span class="kn">from</span> <span class="nn">wbia.algo.graph.state</span> <span class="k">import</span> <span class="n">POSTV</span><span class="p">,</span> <span class="n">NEGTV</span><span class="p">,</span> <span class="n">INCMP</span><span class="p">,</span> <span class="n">UNREV</span>  <span class="c1"># NOQA</span>

<span class="nb">print</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">inject2</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="AnnotInfrMatching"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.AnnotInfrMatching">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">ReloadingMetaclass</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AnnotInfrMatching</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Methods for running matching algorithms</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AnnotInfrMatching.exec_matching"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.AnnotInfrMatching.exec_matching">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">exec_matching</span><span class="p">(</span>
        <span class="n">infr</span><span class="p">,</span>
        <span class="n">qaids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">daids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prog_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cfgdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name_method</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">,</span>
        <span class="n">use_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">invalidate_supercache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads chip matches into the inference structure</span>
<span class="sd">        Uses graph name labeling and ignores wbia labeling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">_make_rankings</span><span class="p">(</span>
            <span class="n">qaids</span><span class="p">,</span>
            <span class="n">daids</span><span class="p">,</span>
            <span class="n">prog_hook</span><span class="p">,</span>
            <span class="n">cfgdict</span><span class="p">,</span>
            <span class="n">name_method</span><span class="p">,</span>
            <span class="n">use_cache</span><span class="o">=</span><span class="n">use_cache</span><span class="p">,</span>
            <span class="n">invalidate_supercache</span><span class="o">=</span><span class="n">invalidate_supercache</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_vsmany_info</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">cm_list</span><span class="p">):</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">vsmany_qreq_</span> <span class="o">=</span> <span class="n">qreq_</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">vsmany_cm_list</span> <span class="o">=</span> <span class="n">cm_list</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span> <span class="o">=</span> <span class="n">cm_list</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">qreq_</span> <span class="o">=</span> <span class="n">qreq_</span>

    <span class="k">def</span> <span class="nf">_make_rankings</span><span class="p">(</span>
        <span class="n">infr</span><span class="p">,</span>
        <span class="n">qaids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">daids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prog_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cfgdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name_method</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">,</span>
        <span class="n">use_cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">invalidate_supercache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># from wbia.algo.graph import graph_iden</span>

        <span class="c1"># TODO: expose other ranking algos like SMK</span>
        <span class="n">rank_algo</span> <span class="o">=</span> <span class="s1">&#39;LNBNN&#39;</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Exec </span><span class="si">{}</span><span class="s1"> ranking algorithm&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rank_algo</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="k">if</span> <span class="n">qaids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qaids</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">aids</span>
        <span class="n">qaids</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ensure_iterable</span><span class="p">(</span><span class="n">qaids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">daids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">daids</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">aids</span>
        <span class="k">if</span> <span class="n">cfgdict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cfgdict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1"># &#39;can_match_samename&#39;: False,</span>
                <span class="s1">&#39;can_match_samename&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;can_match_sameimg&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="c1"># &#39;augment_queryside_hack&#39;: True,</span>
                <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                <span class="s1">&#39;Knorm&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                <span class="s1">&#39;prescore_method&#39;</span><span class="p">:</span> <span class="s1">&#39;csum&#39;</span><span class="p">,</span>
                <span class="s1">&#39;score_method&#39;</span><span class="p">:</span> <span class="s1">&#39;csum&#39;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="n">cfgdict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">ranker_params</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Using LNBNN config = </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cfgdict</span><span class="p">,))</span>
        <span class="c1"># hack for using current nids</span>
        <span class="k">if</span> <span class="n">name_method</span> <span class="o">==</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span>
            <span class="n">aids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">aslist</span><span class="p">(</span><span class="n">qaids</span><span class="p">)</span> <span class="o">+</span> <span class="n">ut</span><span class="o">.</span><span class="n">aslist</span><span class="p">(</span><span class="n">daids</span><span class="p">)))</span>
            <span class="n">custom_nid_lookup</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">get_node_attrs</span><span class="p">(</span><span class="s1">&#39;name_label&#39;</span><span class="p">,</span> <span class="n">aids</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name_method</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
            <span class="n">custom_nid_lookup</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">aid</span><span class="p">:</span> <span class="n">nid</span> <span class="k">for</span> <span class="n">nid</span><span class="p">,</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">_ccs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">aid</span> <span class="ow">in</span> <span class="n">cc</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">name_method</span> <span class="o">==</span> <span class="s1">&#39;wbia&#39;</span><span class="p">:</span>
            <span class="n">custom_nid_lookup</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Unknown name_method=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_method</span><span class="p">))</span>

        <span class="n">qreq_</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">new_query_request</span><span class="p">(</span>
            <span class="n">qaids</span><span class="p">,</span>
            <span class="n">daids</span><span class="p">,</span>
            <span class="n">cfgdict</span><span class="o">=</span><span class="n">cfgdict</span><span class="p">,</span>
            <span class="n">custom_nid_lookup</span><span class="o">=</span><span class="n">custom_nid_lookup</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">infr</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># cacher = qreq_.get_big_cacher()</span>
        <span class="c1"># if not cacher.exists():</span>
        <span class="c1">#     pass</span>
        <span class="c1">#     # import sys</span>
        <span class="c1">#     # sys.exit(1)</span>

        <span class="n">cm_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="n">prog_hook</span><span class="o">=</span><span class="n">prog_hook</span><span class="p">,</span>
            <span class="n">use_cache</span><span class="o">=</span><span class="n">use_cache</span><span class="p">,</span>
            <span class="n">invalidate_supercache</span><span class="o">=</span><span class="n">invalidate_supercache</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">_set_vsmany_info</span><span class="p">(</span><span class="n">qreq_</span><span class="p">,</span> <span class="n">cm_list</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">_cm_breaking</span><span class="p">(</span><span class="n">cm_list</span><span class="p">,</span> <span class="n">review_cfg</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ranks_top&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}))</span>
        <span class="k">return</span> <span class="n">edges</span>
        <span class="c1"># return cm_list</span>

    <span class="k">def</span> <span class="nf">_make_matches_from</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prog_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">wbia.algo.verif</span> <span class="k">import</span> <span class="n">pairfeat</span>

        <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">verifier_params</span>
        <span class="n">extr</span> <span class="o">=</span> <span class="n">pairfeat</span><span class="o">.</span><span class="n">PairwiseFeatureExtractor</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
        <span class="n">match_list</span> <span class="o">=</span> <span class="n">extr</span><span class="o">.</span><span class="n">_exec_pairwise_match</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">prog_hook</span><span class="o">=</span><span class="n">prog_hook</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">match_list</span>

<div class="viewcode-block" id="AnnotInfrMatching.exec_vsone_subset"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.AnnotInfrMatching.exec_vsone_subset">[docs]</a>    <span class="k">def</span> <span class="nf">exec_vsone_subset</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">prog_hook</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            prog_hook (None): (default = None)</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.core exec_vsone_subset</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.core import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; infr = testdata_infr(&#39;testdb1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_full()</span>
<span class="sd">            &gt;&gt;&gt; edges = [(1, 2), (2, 3)]</span>
<span class="sd">            &gt;&gt;&gt; result = infr.exec_vsone_subset(edges)</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">match_list</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_make_matches_from</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">prog_hook</span><span class="p">)</span>

        <span class="c1"># TODO: is this code necessary anymore?</span>
        <span class="n">vsone_matches</span> <span class="o">=</span> <span class="p">{</span><span class="n">e_</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> <span class="n">match</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">match</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">match_list</span><span class="p">)}</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">vsone_matches</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vsone_matches</span><span class="p">)</span>
        <span class="n">edge_to_score</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">match</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">vsone_matches</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edge_to_score</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="n">edge_to_score</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">match_list</span></div>

<div class="viewcode-block" id="AnnotInfrMatching.lookup_cm"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.AnnotInfrMatching.lookup_cm">[docs]</a>    <span class="k">def</span> <span class="nf">lookup_cm</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get chipmatch object associated with an edge if one exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span>
        <span class="c1"># TODO: keep chip matches in dictionary by default?</span>
        <span class="n">aid2_idx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">make_index_lookup</span><span class="p">([</span><span class="n">cm</span><span class="o">.</span><span class="n">qaid</span> <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span><span class="p">])</span>
        <span class="n">switch_order</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">aid1</span> <span class="ow">in</span> <span class="n">aid2_idx</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">aid2_idx</span><span class="p">[</span><span class="n">aid1</span><span class="p">]</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">aid2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cm</span><span class="o">.</span><span class="n">daid2_idx</span><span class="p">:</span>
                <span class="n">switch_order</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># raise KeyError(&#39;switch order&#39;)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">switch_order</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">switch_order</span><span class="p">:</span>
            <span class="c1"># switch order</span>
            <span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span> <span class="o">=</span> <span class="n">aid2</span><span class="p">,</span> <span class="n">aid1</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">aid2_idx</span><span class="p">[</span><span class="n">aid1</span><span class="p">]</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">aid2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cm</span><span class="o">.</span><span class="n">daid2_idx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;No ChipMatch for edge (</span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cm</span><span class="p">,</span> <span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span></div>

<div class="viewcode-block" id="AnnotInfrMatching.apply_match_edges"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.AnnotInfrMatching.apply_match_edges">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">apply_match_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">review_cfg</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds results from one-vs-many rankings as edges in the graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;apply_match_edges - matching has not been run!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;apply_match_edges&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_cm_breaking</span><span class="p">(</span><span class="n">review_cfg</span><span class="p">)</span>
        <span class="c1"># Create match-based graph structure</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;apply_match_edges adding </span><span class="si">%d</span><span class="s1"> edges&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">apply_match_scores</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_cm_breaking</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">cm_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">review_cfg</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from wbia.algo.graph.core import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; review_cfg = {}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cm_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cm_list</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span>
        <span class="n">ranks_top</span> <span class="o">=</span> <span class="n">review_cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ranks_top&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ranks_bot</span> <span class="o">=</span> <span class="n">review_cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ranks_bot&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Construct K-broken graph</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">ranks_bot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ranks_bot</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">cm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cm_list</span><span class="p">):</span>
            <span class="n">score_list</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">annot_score_list</span>
            <span class="n">rank_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">score_list</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sortx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">rank_list</span><span class="p">)</span>

            <span class="n">top_sortx</span> <span class="o">=</span> <span class="n">sortx</span><span class="p">[:</span><span class="n">ranks_top</span><span class="p">]</span>
            <span class="n">bot_sortx</span> <span class="o">=</span> <span class="n">sortx</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sortx</span><span class="p">)</span> <span class="o">-</span> <span class="n">ranks_bot</span> <span class="p">:]</span>
            <span class="n">short_sortx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">top_sortx</span> <span class="o">+</span> <span class="n">bot_sortx</span><span class="p">)</span>

            <span class="n">daid_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">daid_list</span><span class="p">,</span> <span class="n">short_sortx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">daid</span> <span class="ow">in</span> <span class="n">daid_list</span><span class="p">:</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">qaid</span><span class="p">,</span> <span class="n">daid</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">:</span>
                    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">edges</span>

    <span class="k">def</span> <span class="nf">_cm_training_pairs</span><span class="p">(</span>
        <span class="n">infr</span><span class="p">,</span>
        <span class="n">qreq_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cm_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">top_gt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">mid_gt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">bot_gt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">top_gf</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">mid_gf</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">bot_gf</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">rand_gt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">rand_gf</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs training data for a pairwise classifier</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.core _cm_training_pairs</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.core import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; infr = testdata_infr(&#39;PZ_MTEST&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr.exec_matching(cfgdict={</span>
<span class="sd">            &gt;&gt;&gt;     &#39;can_match_samename&#39;: True,</span>
<span class="sd">            &gt;&gt;&gt;     &#39;K&#39;: 4,</span>
<span class="sd">            &gt;&gt;&gt;     &#39;Knorm&#39;: 1,</span>
<span class="sd">            &gt;&gt;&gt;     &#39;prescore_method&#39;: &#39;csum&#39;,</span>
<span class="sd">            &gt;&gt;&gt;     &#39;score_method&#39;: &#39;csum&#39;</span>
<span class="sd">            &gt;&gt;&gt; })</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.core import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; exec(ut.execstr_funckw(infr._cm_training_pairs))</span>
<span class="sd">            &gt;&gt;&gt; rng = np.random.RandomState(42)</span>
<span class="sd">            &gt;&gt;&gt; aid_pairs = np.array(infr._cm_training_pairs(rng=rng))</span>
<span class="sd">            &gt;&gt;&gt; print(len(aid_pairs))</span>
<span class="sd">            &gt;&gt;&gt; assert np.sum(aid_pairs.T[0] == aid_pairs.T[1]) == 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">qreq_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cm_list</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span>
            <span class="n">qreq_</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">qreq_</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="n">aid_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dnids</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_qreq_annot_nids</span><span class="p">(</span><span class="n">qreq_</span><span class="o">.</span><span class="n">daids</span><span class="p">)</span>
        <span class="c1"># dnids = qreq_.get_qreq_annot_nids(qreq_.daids)</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ensure_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">ut</span><span class="o">.</span><span class="n">ProgIter</span><span class="p">(</span><span class="n">cm_list</span><span class="p">,</span> <span class="n">lbl</span><span class="o">=</span><span class="s1">&#39;building pairs&#39;</span><span class="p">):</span>
            <span class="n">all_gt_aids</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_top_gt_aids</span><span class="p">(</span><span class="n">ibs</span><span class="p">)</span>
            <span class="n">all_gf_aids</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_top_gf_aids</span><span class="p">(</span><span class="n">ibs</span><span class="p">)</span>
            <span class="n">gt_aids</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take_percentile_parts</span><span class="p">(</span><span class="n">all_gt_aids</span><span class="p">,</span> <span class="n">top_gt</span><span class="p">,</span> <span class="n">mid_gt</span><span class="p">,</span> <span class="n">bot_gt</span><span class="p">)</span>
            <span class="n">gf_aids</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take_percentile_parts</span><span class="p">(</span><span class="n">all_gf_aids</span><span class="p">,</span> <span class="n">top_gf</span><span class="p">,</span> <span class="n">mid_gf</span><span class="p">,</span> <span class="n">bot_gf</span><span class="p">)</span>
            <span class="c1"># get unscored examples</span>
            <span class="n">unscored_gt_aids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">aid</span> <span class="k">for</span> <span class="n">aid</span> <span class="ow">in</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">daids</span><span class="p">[</span><span class="n">cm</span><span class="o">.</span><span class="n">qnid</span> <span class="o">==</span> <span class="n">dnids</span><span class="p">]</span> <span class="k">if</span> <span class="n">aid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cm</span><span class="o">.</span><span class="n">daid2_idx</span>
            <span class="p">]</span>
            <span class="n">rand_gt_aids</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">unscored_gt_aids</span><span class="p">,</span> <span class="n">rand_gt</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
            <span class="c1"># gf_aids = cm.get_groundfalse_daids()</span>
            <span class="n">_gf_aids</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">daids</span><span class="p">[</span><span class="n">cm</span><span class="o">.</span><span class="n">qnid</span> <span class="o">!=</span> <span class="n">dnids</span><span class="p">]</span>
            <span class="n">_gf_aids</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">daids</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">qnid</span> <span class="o">!=</span> <span class="n">dnids</span><span class="p">)</span>
            <span class="c1"># gf_aids = ibs.get_annot_groundfalse(cm.qaid, daid_list=qreq_.daids)</span>
            <span class="n">rand_gf_aids</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">_gf_aids</span><span class="p">,</span> <span class="n">rand_gf</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">chosen_daids</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">gt_aids</span> <span class="o">+</span> <span class="n">gf_aids</span> <span class="o">+</span> <span class="n">rand_gf_aids</span> <span class="o">+</span> <span class="n">rand_gt_aids</span><span class="p">)</span>
            <span class="n">aid_pairs</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">cm</span><span class="o">.</span><span class="n">qaid</span><span class="p">,</span> <span class="n">aid</span><span class="p">)</span> <span class="k">for</span> <span class="n">aid</span> <span class="ow">in</span> <span class="n">chosen_daids</span> <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">qaid</span> <span class="o">!=</span> <span class="n">aid</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">aid_pairs</span>

    <span class="k">def</span> <span class="nf">_get_cm_agg_aid_ranking</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">cc</span><span class="p">):</span>
        <span class="n">aid_to_cm</span> <span class="o">=</span> <span class="p">{</span><span class="n">cm</span><span class="o">.</span><span class="n">qaid</span><span class="p">:</span> <span class="n">cm</span> <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span><span class="p">}</span>
        <span class="n">all_scores</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qaid</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">aid_to_cm</span><span class="p">[</span><span class="n">qaid</span><span class="p">]</span>
            <span class="c1"># should we be doing nids?</span>
            <span class="k">for</span> <span class="n">daid</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">get_top_aids</span><span class="p">(),</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_top_scores</span><span class="p">()):</span>
                <span class="n">all_scores</span><span class="p">[</span><span class="n">daid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

        <span class="n">max_scores</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="n">scores</span><span class="p">),</span> <span class="n">aid</span><span class="p">)</span> <span class="k">for</span> <span class="n">aid</span><span class="p">,</span> <span class="n">scores</span> <span class="ow">in</span> <span class="n">all_scores</span><span class="o">.</span><span class="n">items</span><span class="p">())[</span>
            <span class="p">::</span><span class="o">-</span><span class="mi">1</span>
        <span class="p">]</span>
        <span class="n">ranked_aids</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take_column</span><span class="p">(</span><span class="n">max_scores</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ranked_aids</span>

    <span class="k">def</span> <span class="nf">_get_cm_edge_data</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">cm_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">symmetric</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">cm_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cm_list</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span>
        <span class="c1"># Find scores for the edges that exist in the graph</span>
        <span class="n">edge_to_data</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="n">aid_to_cm</span> <span class="o">=</span> <span class="p">{</span><span class="n">cm</span><span class="o">.</span><span class="n">qaid</span><span class="p">:</span> <span class="n">cm</span> <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">cm_list</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e_</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">cm1</span> <span class="o">=</span> <span class="n">aid_to_cm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">cm2</span> <span class="o">=</span> <span class="n">aid_to_cm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">ut</span><span class="o">.</span><span class="n">filter_Nones</span><span class="p">([</span><span class="n">cm1</span><span class="p">,</span> <span class="n">cm2</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">aid</span> <span class="ow">in</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">daid2_idx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">aid</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">annot_score_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">rank</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_annot_ranks</span><span class="p">([</span><span class="n">aid</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
                    <span class="n">ranks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Choose whichever one gave the best score</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">safe_argmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">ranks</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">edge_to_data</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)][</span><span class="s1">&#39;score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">edge_to_data</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank</span>
        <span class="k">return</span> <span class="n">edge_to_data</span>

<div class="viewcode-block" id="AnnotInfrMatching.apply_match_scores"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.AnnotInfrMatching.apply_match_scores">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">apply_match_scores</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Applies precomputed matching scores to edges that already exist in the</span>
<span class="sd">        graph. Typically you should run infr.apply_match_edges() before running</span>
<span class="sd">        this.</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.core apply_match_scores --show</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.core import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; infr = testdata_infr(&#39;PZ_MTEST&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr.exec_matching()</span>
<span class="sd">            &gt;&gt;&gt; infr.apply_match_edges()</span>
<span class="sd">            &gt;&gt;&gt; infr.apply_match_scores()</span>
<span class="sd">            &gt;&gt;&gt; infr.get_edge_attrs(&#39;score&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;apply_match_scores - no scores to apply!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;apply_match_scores&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="n">edge_to_data</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_get_cm_edge_data</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="c1"># Remove existing attrs</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">nx_delete_edge_attr</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">)</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">nx_delete_edge_attr</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;rank&#39;</span><span class="p">)</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">nx_delete_edge_attr</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;normscore&#39;</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edge_to_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">edge_scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">take_column</span><span class="p">(</span><span class="n">edge_to_data</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="s1">&#39;score&#39;</span><span class="p">))</span>
        <span class="n">edge_scores</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">replace_nones</span><span class="p">(</span><span class="n">edge_scores</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">edge_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_scores</span><span class="p">)</span>
        <span class="n">edge_ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">take_column</span><span class="p">(</span><span class="n">edge_to_data</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="s1">&#39;rank&#39;</span><span class="p">))</span>
        <span class="c1"># take the inf-norm</span>
        <span class="n">normscores</span> <span class="o">=</span> <span class="n">edge_scores</span> <span class="o">/</span> <span class="n">vt</span><span class="o">.</span><span class="n">safe_max</span><span class="p">(</span><span class="n">edge_scores</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Add new attrs</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edge_scores</span><span class="p">))</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edge_ranks</span><span class="p">))</span>

        <span class="c1"># Hack away zero probabilites</span>
        <span class="c1"># probs = np.vstack([p_nomatch, p_match, p_notcomp]).T + 1e-9</span>
        <span class="c1"># probs = vt.normalize(probs, axis=1, ord=1, out=probs)</span>
        <span class="c1"># entropy = -(np.log2(probs) * probs).sum(axis=1)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="s1">&#39;normscore&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">normscores</span><span class="p">)))</span></div></div>


<div class="viewcode-block" id="InfrLearning"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.InfrLearning">[docs]</a><span class="k">class</span> <span class="nc">InfrLearning</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="InfrLearning.learn_deploy_verifiers"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.InfrLearning.learn_deploy_verifiers">[docs]</a>    <span class="k">def</span> <span class="nf">learn_deploy_verifiers</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">publish</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses current knowledge to train verifiers for new unseen pairs.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; ibs = wbia.opendb(&#39;PZ_MTEST&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(ibs, aids=&#39;all&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_mst()</span>
<span class="sd">            &gt;&gt;&gt; publish = False</span>
<span class="sd">            &gt;&gt;&gt; infr.learn_deploy_verifiers()</span>

<span class="sd">        Ignore:</span>
<span class="sd">            publish = True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;learn_deploy_verifiers&#39;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">wbia.algo.verif</span> <span class="k">import</span> <span class="n">vsone</span>

        <span class="n">pblm</span> <span class="o">=</span> <span class="n">vsone</span><span class="o">.</span><span class="n">OneVsOneProblem</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pblm</span><span class="o">.</span><span class="n">primary_task_key</span> <span class="o">=</span> <span class="s1">&#39;match_state&#39;</span>
        <span class="n">pblm</span><span class="o">.</span><span class="n">default_clf_key</span> <span class="o">=</span> <span class="s1">&#39;RF&#39;</span>
        <span class="n">pblm</span><span class="o">.</span><span class="n">default_data_key</span> <span class="o">=</span> <span class="s1">&#39;learn(sum,glob)&#39;</span>
        <span class="n">pblm</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
        <span class="n">dpath</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>

        <span class="n">task_key</span> <span class="o">=</span> <span class="s1">&#39;match_state&#39;</span>
        <span class="n">pblm</span><span class="o">.</span><span class="n">deploy</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="n">task_key</span><span class="o">=</span><span class="n">task_key</span><span class="p">,</span> <span class="n">publish</span><span class="o">=</span><span class="n">publish</span><span class="p">)</span>

        <span class="n">task_key</span> <span class="o">=</span> <span class="s1">&#39;photobomb_state&#39;</span>
        <span class="k">if</span> <span class="n">task_key</span> <span class="ow">in</span> <span class="n">pblm</span><span class="o">.</span><span class="n">eval_task_keys</span><span class="p">:</span>
            <span class="n">pblm</span><span class="o">.</span><span class="n">deploy</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="n">task_key</span><span class="o">=</span><span class="n">task_key</span><span class="p">)</span></div>

<div class="viewcode-block" id="InfrLearning.learn_evaluation_verifiers"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.InfrLearning.learn_evaluation_verifiers">[docs]</a>    <span class="k">def</span> <span class="nf">learn_evaluation_verifiers</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a cross-validated ensemble of classifiers to evaluate</span>
<span class="sd">        verifier error cases and groundtruth errors.</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.mixin_matching learn_evaluation_verifiers</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(</span>
<span class="sd">            &gt;&gt;&gt;     &#39;PZ_MTEST&#39;, aids=&#39;all&#39;, autoinit=&#39;annotmatch&#39;,</span>
<span class="sd">            &gt;&gt;&gt;     verbose=4)</span>
<span class="sd">            &gt;&gt;&gt; verifiers = infr.learn_evaluation_verifiers()</span>
<span class="sd">            &gt;&gt;&gt; edges = list(infr.edges())</span>
<span class="sd">            &gt;&gt;&gt; verif = verifiers[&#39;match_state&#39;]</span>
<span class="sd">            &gt;&gt;&gt; probs = verif.predict_proba_df(edges)</span>
<span class="sd">            &gt;&gt;&gt; print(probs)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;learn_evaluataion_verifiers&#39;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">wbia.algo.verif</span> <span class="k">import</span> <span class="n">vsone</span>

        <span class="n">pblm</span> <span class="o">=</span> <span class="n">vsone</span><span class="o">.</span><span class="n">OneVsOneProblem</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">pblm</span><span class="o">.</span><span class="n">primary_task_key</span> <span class="o">=</span> <span class="s1">&#39;match_state&#39;</span>
        <span class="n">pblm</span><span class="o">.</span><span class="n">eval_clf_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;RF&#39;</span><span class="p">]</span>
        <span class="n">pblm</span><span class="o">.</span><span class="n">eval_data_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;learn(sum,glob)&#39;</span><span class="p">]</span>
        <span class="n">pblm</span><span class="o">.</span><span class="n">setup_evaluation</span><span class="p">()</span>
        <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">pblm</span><span class="o">.</span><span class="n">report_evaluation</span><span class="p">()</span>
        <span class="n">verifiers</span> <span class="o">=</span> <span class="n">pblm</span><span class="o">.</span><span class="n">_make_evaluation_verifiers</span><span class="p">(</span><span class="n">pblm</span><span class="o">.</span><span class="n">eval_task_keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">verifiers</span></div>

<div class="viewcode-block" id="InfrLearning.load_published"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.InfrLearning.load_published">[docs]</a>    <span class="k">def</span> <span class="nf">load_published</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downloads, caches, and loads pre-trained verifiers.</span>
<span class="sd">        This is the default action.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">wbia.algo.verif</span> <span class="k">import</span> <span class="n">deploy</span>

        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="n">species</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_primary_database_species</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">aids</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Loading task_thresh for species: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">species</span><span class="p">,))</span>
        <span class="k">assert</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">task_thresh_dict</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">task_thresh</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">task_thresh_dict</span><span class="p">[</span><span class="n">species</span><span class="p">]</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;infr.task_thresh: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">task_thresh</span><span class="p">,))</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Loading verifiers for species: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">species</span><span class="p">,))</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">verifiers</span> <span class="o">=</span> <span class="n">deploy</span><span class="o">.</span><span class="n">Deployer</span><span class="p">()</span><span class="o">.</span><span class="n">load_published</span><span class="p">(</span><span class="n">ibs</span><span class="p">,</span> <span class="n">species</span><span class="p">)</span></div>

<div class="viewcode-block" id="InfrLearning.load_latest_classifiers"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.InfrLearning.load_latest_classifiers">[docs]</a>    <span class="k">def</span> <span class="nf">load_latest_classifiers</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">dpath</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">wbia.algo.verif</span> <span class="k">import</span> <span class="n">deploy</span>

        <span class="n">task_clf_fpaths</span> <span class="o">=</span> <span class="n">deploy</span><span class="o">.</span><span class="n">Deployer</span><span class="p">(</span><span class="n">dpath</span><span class="p">)</span><span class="o">.</span><span class="n">find_latest_local</span><span class="p">()</span>
        <span class="n">classifiers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">task_key</span><span class="p">,</span> <span class="n">fpath</span> <span class="ow">in</span> <span class="n">task_clf_fpaths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">clf_info</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">clf_info</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;task_key&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">task_key</span>
            <span class="p">),</span> <span class="s1">&#39;bad saved clf at fpath=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
            <span class="n">classifiers</span><span class="p">[</span><span class="n">task_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf_info</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">verifiers</span> <span class="o">=</span> <span class="n">classifiers</span></div>
        <span class="c1"># return classifiers</span>

<div class="viewcode-block" id="InfrLearning.photobomb_samples"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.InfrLearning.photobomb_samples">[docs]</a>    <span class="k">def</span> <span class="nf">photobomb_samples</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="n">tags_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">gen_edge_values</span><span class="p">(</span><span class="s1">&#39;tags&#39;</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[]))</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">filterflags_general_tags</span><span class="p">(</span><span class="n">tags_list</span><span class="p">,</span> <span class="n">has_any</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;photobomb&#39;</span><span class="p">])</span>
        <span class="n">pb_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pb_edges</span></div></div>


<span class="k">class</span> <span class="nc">_RedundancyAugmentation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="c1"># def rand_neg_check_edges(infr, c1_nodes, c2_nodes):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Find enough edges to between two pccs to make them k-negative complete</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     k = infr.params[&#39;redun.neg&#39;]</span>
    <span class="c1">#     existing_edges = nxu.edges_cross(infr.graph, c1_nodes, c2_nodes)</span>
    <span class="c1">#     reviewed_edges = {</span>
    <span class="c1">#         edge: state</span>
    <span class="c1">#         for edge, state in infr.get_edge_attrs(</span>
    <span class="c1">#             &#39;decision&#39;, existing_edges,</span>
    <span class="c1">#             default=UNREV).items()</span>
    <span class="c1">#         if state != UNREV</span>
    <span class="c1">#     }</span>
    <span class="c1">#     n_neg = sum([state == NEGTV for state in reviewed_edges.values()])</span>
    <span class="c1">#     if n_neg &lt; k:</span>
    <span class="c1">#         # Find k random negative edges</span>
    <span class="c1">#         check_edges = existing_edges - set(reviewed_edges)</span>
    <span class="c1">#         if len(check_edges) &lt; k:</span>
    <span class="c1">#             edges = it.starmap(nxu.e_, it.product(c1_nodes, c2_nodes))</span>
    <span class="c1">#             for edge in edges:</span>
    <span class="c1">#                 if edge not in reviewed_edges:</span>
    <span class="c1">#                     check_edges.add(edge)</span>
    <span class="c1">#                     if len(check_edges) == k:</span>
    <span class="c1">#                         break</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         check_edges = {}</span>
    <span class="c1">#     return check_edges</span>

    <span class="k">def</span> <span class="nf">find_neg_augment_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find enough edges to between two pccs to make them k-negative complete</span>
<span class="sd">        The two CCs should be disjoint and not have any positive edges between</span>
<span class="sd">        them.</span>

<span class="sd">        Args:</span>
<span class="sd">            cc1 (set): nodes in one PCC</span>
<span class="sd">            cc2 (set): nodes in another positive-disjoint PCC</span>
<span class="sd">            k (int): redundnacy level (if None uses infr.params[&#39;redun.neg&#39;])</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; k = 2</span>
<span class="sd">            &gt;&gt;&gt; cc1, cc2 = {1}, {2, 3}</span>
<span class="sd">            &gt;&gt;&gt; # --- return an augmentation if feasible</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(ccs=[cc1, cc2], ignore_pair=True)</span>
<span class="sd">            &gt;&gt;&gt; edges = set(infr.find_neg_augment_edges(cc1, cc2, k=k))</span>
<span class="sd">            &gt;&gt;&gt; assert edges == {(1, 2), (1, 3)}</span>
<span class="sd">            &gt;&gt;&gt; # --- if infeasible return a partial augmentation</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((1, 2), INCMP)</span>
<span class="sd">            &gt;&gt;&gt; edges = set(infr.find_neg_augment_edges(cc1, cc2, k=k))</span>
<span class="sd">            &gt;&gt;&gt; assert edges == {(1, 3)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.neg&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">cc1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">cc2</span><span class="p">,</span> <span class="s1">&#39;CCs should be disjoint (but they are the same)&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cc2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;CCs should be disjoint&#39;</span>
        <span class="n">existing_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_cross</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">))</span>

        <span class="n">reviewed_edges</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">edge</span><span class="p">:</span> <span class="n">state</span>
            <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">existing_edges</span><span class="p">,</span> <span class="n">infr</span><span class="o">.</span><span class="n">edge_decision_from</span><span class="p">(</span><span class="n">existing_edges</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">UNREV</span>
        <span class="p">}</span>

        <span class="c1"># Find how many negative edges we already have</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">state</span> <span class="o">==</span> <span class="n">NEGTV</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">reviewed_edges</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="c1"># Find k random negative edges</span>
            <span class="n">check_edges</span> <span class="o">=</span> <span class="n">existing_edges</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">reviewed_edges</span><span class="p">)</span>
            <span class="c1"># Check the existing but unreviewed edges first</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">check_edges</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">yield</span> <span class="n">edge</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                    <span class="k">return</span>
            <span class="c1"># Check non-existing edges next</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="mi">2827295125</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cc1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cc2</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">cc1</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cc1</span><span class="p">),</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
            <span class="n">cc2</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cc2</span><span class="p">),</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
            <span class="n">cc1</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cc1</span><span class="p">),</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">e_</span><span class="p">,</span> <span class="n">nxu</span><span class="o">.</span><span class="n">diag_product</span><span class="p">(</span><span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_edges</span><span class="p">:</span>
                    <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">yield</span> <span class="n">edge</span>
                    <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">find_pos_augment_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">pcc</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # [[1, 0], [0, 2], [1, 2], [3, 1]]</span>
<span class="sd">        pos_sub = nx.Graph([[0, 1], [1, 2], [0, 2], [1, 3]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos_k</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.pos&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">pos_sub</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">pcc</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># weight by pairs most likely to be comparable</span>

        <span class="c1"># First try to augment only with unreviewed existing edges</span>
        <span class="n">unrev_avail</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_inside</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">unreviewed_graph</span><span class="p">,</span> <span class="n">pcc</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">nxu</span><span class="o">.</span><span class="n">k_edge_augmentation</span><span class="p">(</span>
                    <span class="n">pos_sub</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">pos_k</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="n">unrev_avail</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">:</span>
            <span class="n">check_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">check_edges</span><span class="p">:</span>
            <span class="c1"># Allow new edges to be introduced</span>
            <span class="n">full_sub</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">pcc</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_avail</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">estarmap</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">e_</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">complement</span><span class="p">(</span><span class="n">full_sub</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
            <span class="n">full_avail</span> <span class="o">=</span> <span class="n">unrev_avail</span> <span class="o">+</span> <span class="n">new_avail</span>
            <span class="n">n_max</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_sub</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_sub</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">n_complement</span> <span class="o">=</span> <span class="n">n_max</span> <span class="o">-</span> <span class="n">pos_sub</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_avail</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_complement</span><span class="p">:</span>
                <span class="c1"># can use the faster algorithm</span>
                <span class="n">check_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">nxu</span><span class="o">.</span><span class="n">k_edge_augmentation</span><span class="p">(</span><span class="n">pos_sub</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">pos_k</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># have to use the slow approximate algo</span>
                <span class="n">check_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">nxu</span><span class="o">.</span><span class="n">k_edge_augmentation</span><span class="p">(</span>
                        <span class="n">pos_sub</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">pos_k</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="n">full_avail</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="n">check_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">e_</span><span class="p">,</span> <span class="n">check_edges</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">check_edges</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">find_pos_redun_candidate_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for augmenting edges that would make PCCs k-positive redundant</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_matching import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(ccs=[(1, 2, 3, 4, 5), (7, 8, 9, 10)])</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((2, 5), &#39;match&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((1, 5), &#39;notcomp&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr.params[&#39;redun.pos&#39;] = 2</span>
<span class="sd">            &gt;&gt;&gt; candidate_edges = list(infr.find_pos_redun_candidate_edges())</span>
<span class="sd">            &gt;&gt;&gt; result = (&#39;candidate_edges = &#39; + ut.repr2(candidate_edges))</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">            candidate_edges = []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add random edges between exisiting non-redundant PCCs</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.pos&#39;</span><span class="p">]</span>
        <span class="c1"># infr.find_non_pos_redundant_pccs(k=k, relax=True)</span>
        <span class="n">pcc_gen</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">positive_components</span><span class="p">())</span>
        <span class="n">prog</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ProgIter</span><span class="p">(</span><span class="n">pcc_gen</span><span class="p">,</span> <span class="n">enabled</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">adjust</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pcc</span> <span class="ow">in</span> <span class="n">prog</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_pos_redundant</span><span class="p">(</span><span class="n">pcc</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">relax</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">assume_connected</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">find_pos_augment_edges</span><span class="p">(</span><span class="n">pcc</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">()</span>
                    <span class="k">yield</span> <span class="n">nxu</span><span class="o">.</span><span class="n">e_</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">find_neg_redun_candidate_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get pairs of PCCs that are not complete.</span>
<span class="sd">        Finds edges that might complete them.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_matching import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(ccs=[(1,), (2,), (3,)], ignore_pair=True)</span>
<span class="sd">            &gt;&gt;&gt; edges = list(infr.find_neg_redun_candidate_edges())</span>
<span class="sd">            &gt;&gt;&gt; assert len(edges) == 3, &#39;all should be needed here&#39;</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback_from(edges, evidence_decision=NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; assert len(list(infr.find_neg_redun_candidate_edges())) == 0</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(pcc_sizes=[3] * 20, ignore_pair=True)</span>
<span class="sd">            &gt;&gt;&gt; ccs = list(infr.positive_components())</span>
<span class="sd">            &gt;&gt;&gt; gen = infr.find_neg_redun_candidate_edges(k=2)</span>
<span class="sd">            &gt;&gt;&gt; for edge in gen:</span>
<span class="sd">            &gt;&gt;&gt;     # What happens when we make ccs positive</span>
<span class="sd">            &gt;&gt;&gt;     print(infr.node_labels(edge))</span>
<span class="sd">            &gt;&gt;&gt;     infr.add_feedback(edge, evidence_decision=POSTV)</span>
<span class="sd">            &gt;&gt;&gt; import ubelt as ub</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(pcc_sizes=[1] * 30, ignore_pair=True)</span>
<span class="sd">            &gt;&gt;&gt; ccs = list(infr.positive_components())</span>
<span class="sd">            &gt;&gt;&gt; gen = infr.find_neg_redun_candidate_edges(k=3)</span>
<span class="sd">            &gt;&gt;&gt; for chunk in ub.chunks(gen, 2):</span>
<span class="sd">            &gt;&gt;&gt;     for edge in chunk:</span>
<span class="sd">            &gt;&gt;&gt;         # What happens when we make ccs positive</span>
<span class="sd">            &gt;&gt;&gt;         print(infr.node_labels(edge))</span>
<span class="sd">            &gt;&gt;&gt;         infr.add_feedback(edge, evidence_decision=POSTV)</span>

<span class="sd">            list(gen)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.neg&#39;</span><span class="p">]</span>
        <span class="c1"># Loop through all pairs</span>
        <span class="k">for</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">find_non_neg_redun_pccs</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cc2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If there is modification of the underlying graph while we</span>
                <span class="c1"># iterate, then two ccs may not be disjoint. Skip these cases.</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">find_neg_augment_edges</span><span class="p">(</span><span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">e_</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">assert_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">edge</span>


<div class="viewcode-block" id="CandidateSearch"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.CandidateSearch">[docs]</a><span class="k">class</span> <span class="nc">CandidateSearch</span><span class="p">(</span><span class="n">_RedundancyAugmentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Search for candidate edges &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CandidateSearch.find_lnbnn_candidate_edges"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.CandidateSearch.find_lnbnn_candidate_edges">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">find_lnbnn_candidate_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_mtest_infr()</span>
<span class="sd">            &gt;&gt;&gt; cand_edges = infr.find_lnbnn_candidate_edges()</span>
<span class="sd">            &gt;&gt;&gt; assert len(cand_edges) &gt; 200</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Refresh the name labels</span>

        <span class="c1"># TODO: abstract into a Ranker class</span>

        <span class="c1"># do LNBNN query for new edges</span>
        <span class="c1"># Use one-vs-many to establish candidate edges to classify</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">exec_matching</span><span class="p">(</span>
            <span class="n">name_method</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span>
            <span class="n">cfgdict</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;resize_dim&#39;</span><span class="p">:</span> <span class="s1">&#39;width&#39;</span><span class="p">,</span>
                <span class="s1">&#39;dim_size&#39;</span><span class="p">:</span> <span class="mi">700</span><span class="p">,</span>
                <span class="s1">&#39;requery&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;can_match_samename&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;can_match_sameimg&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="c1"># &#39;sv_on&#39;: False,</span>
            <span class="p">},</span>
        <span class="p">)</span>
        <span class="c1"># infr.apply_match_edges(review_cfg={&#39;ranks_top&#39;: 5})</span>
        <span class="n">ranks_top</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ranking.ntop&#39;</span><span class="p">]</span>
        <span class="n">lnbnn_results</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">_cm_breaking</span><span class="p">(</span><span class="n">review_cfg</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ranks_top&#39;</span><span class="p">:</span> <span class="n">ranks_top</span><span class="p">}))</span>

        <span class="n">candidate_edges</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">edge</span>
            <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lnbnn_results</span><span class="p">,</span> <span class="n">infr</span><span class="o">.</span><span class="n">edge_decision_from</span><span class="p">(</span><span class="n">lnbnn_results</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">UNREV</span>
        <span class="p">}</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
            <span class="s1">&#39;ranking alg found </span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1"> unreviewed edges&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">candidate_edges</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnbnn_results</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">candidate_edges</span></div>

<div class="viewcode-block" id="CandidateSearch.ensure_task_probs"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.CandidateSearch.ensure_task_probs">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_task_probs</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures that probabilities are assigned to the edges.</span>
<span class="sd">        This gaurentees that infr.task_probs contains data for edges.</span>
<span class="sd">        (Currently only the primary task is actually ensured)</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.mixin_matching ensure_task_probs</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_matching import *</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(&#39;PZ_MTEST&#39;, aids=&#39;all&#39;,</span>
<span class="sd">            &gt;&gt;&gt;                             autoinit=&#39;staging&#39;)</span>
<span class="sd">            &gt;&gt;&gt; edges = list(infr.edges())[0:3]</span>
<span class="sd">            &gt;&gt;&gt; infr.load_published()</span>
<span class="sd">            &gt;&gt;&gt; assert len(infr.task_probs[&#39;match_state&#39;]) == 0</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_task_probs(edges)</span>
<span class="sd">            &gt;&gt;&gt; assert len(infr.task_probs[&#39;match_state&#39;]) == 3</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_task_probs(edges)</span>
<span class="sd">            &gt;&gt;&gt; assert len(infr.task_probs[&#39;match_state&#39;]) == 3</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_matching import *</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(num_pccs=6, p_incon=.5, size_std=2)</span>
<span class="sd">            &gt;&gt;&gt; edges = list(infr.edges())</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_task_probs(edges)</span>
<span class="sd">            &gt;&gt;&gt; assert all([np.isclose(sum(p.values()), 1)</span>
<span class="sd">            &gt;&gt;&gt;             for p in infr.task_probs[&#39;match_state&#39;].values()])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">verifiers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Verifiers are needed to predict probabilities&#39;</span><span class="p">)</span>

        <span class="c1"># Construct pairwise features on edges in infr</span>
        <span class="n">primary_task</span> <span class="o">=</span> <span class="s1">&#39;match_state&#39;</span>

        <span class="n">match_task</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">task_probs</span><span class="p">[</span><span class="n">primary_task</span><span class="p">]</span>
        <span class="n">need_flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">match_task</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">need_flags</span><span class="p">):</span>
            <span class="n">need_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">need_flags</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s1">&#39;There are </span><span class="si">{}</span><span class="s1"> edges without probabilities&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">need_edges</span><span class="p">)),</span> <span class="mi">1</span>
            <span class="p">)</span>

            <span class="c1"># Only recompute for the needed edges</span>
            <span class="n">task_probs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_make_task_probs</span><span class="p">(</span><span class="n">need_edges</span><span class="p">)</span>
            <span class="c1"># Store task probs in internal data structure</span>
            <span class="c1"># FIXME: this is slow</span>
            <span class="k">for</span> <span class="n">task</span><span class="p">,</span> <span class="n">probs</span> <span class="ow">in</span> <span class="n">task_probs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">probs_dict</span> <span class="o">=</span> <span class="n">probs</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">task</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">task_probs</span><span class="p">:</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">task_probs</span><span class="p">[</span><span class="n">task</span><span class="p">]</span> <span class="o">=</span> <span class="n">probs_dict</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">task_probs</span><span class="p">[</span><span class="n">task</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">probs_dict</span><span class="p">)</span>

                <span class="c1"># Set edge task attribute as well</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">probs_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateSearch.ensure_priority_scores"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.CandidateSearch.ensure_priority_scores">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">ensure_priority_scores</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">priority_edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures that priority attributes are assigned to the edges.</span>
<span class="sd">        This does not change the state of the queue.</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; ibs = wbia.opendb(&#39;PZ_MTEST&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(ibs, aids=&#39;all&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_mst()</span>
<span class="sd">            &gt;&gt;&gt; priority_edges = list(infr.edges())[0:1]</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_priority_scores(priority_edges)</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; ibs = wbia.opendb(&#39;PZ_MTEST&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(ibs, aids=&#39;all&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_mst()</span>
<span class="sd">            &gt;&gt;&gt; # infr.load_published()</span>
<span class="sd">            &gt;&gt;&gt; priority_edges = list(infr.edges())</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_priority_scores(priority_edges)</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(num_pccs=6, p_incon=.5, size_std=2)</span>
<span class="sd">            &gt;&gt;&gt; edges = list(infr.edges())</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_priority_scores(edges)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Checking for verifiers: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">verifiers</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">verifiers</span> <span class="ow">and</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s1">&#39;Prioritizing </span><span class="si">{}</span><span class="s1"> edges with one-vs-one probs&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)),</span>
                <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Using thresholds: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">task_thresh</span><span class="p">,))</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s1">&#39;Using infr.params[autoreview.enabled]          : </span><span class="si">%r</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;autoreview.enabled&#39;</span><span class="p">],)</span>
            <span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s1">&#39;Using infr.params[autoreview.prioritize_nonpos]: </span><span class="si">%r</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;autoreview.prioritize_nonpos&#39;</span><span class="p">],)</span>
            <span class="p">)</span>

            <span class="n">infr</span><span class="o">.</span><span class="n">ensure_task_probs</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">load_published</span><span class="p">()</span>

            <span class="n">primary_task</span> <span class="o">=</span> <span class="s1">&#39;match_state&#39;</span>
            <span class="n">match_probs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">task_probs</span><span class="p">[</span><span class="n">primary_task</span><span class="p">]</span>
            <span class="n">primary_thresh</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">task_thresh</span><span class="p">[</span><span class="n">primary_task</span><span class="p">]</span>

            <span class="c1"># Read match_probs into a DataFrame</span>
            <span class="n">primary_probs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">match_probs</span><span class="p">,</span> <span class="n">priority_edges</span><span class="p">),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">nxu</span><span class="o">.</span><span class="n">ensure_multi_index</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;aid1&#39;</span><span class="p">,</span> <span class="s1">&#39;aid2&#39;</span><span class="p">)),</span>
            <span class="p">)</span>

            <span class="c1"># Convert match-state probabilities into priorities</span>
            <span class="n">prob_match</span> <span class="o">=</span> <span class="n">primary_probs</span><span class="p">[</span><span class="n">POSTV</span><span class="p">]</span>

            <span class="c1"># Initialize priorities to probability of matching</span>
            <span class="n">default_priority</span> <span class="o">=</span> <span class="n">prob_match</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># If the edges are currently between the same individual, then</span>
            <span class="c1"># prioritize by non-positive probability (because those edges might</span>
            <span class="c1"># expose an inconsistency)</span>
            <span class="n">already_pos</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">priority_edges</span>
            <span class="p">]</span>
            <span class="n">default_priority</span><span class="p">[</span><span class="n">already_pos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">default_priority</span><span class="p">[</span><span class="n">already_pos</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;autoreview.enabled&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;autoreview.prioritize_nonpos&#39;</span><span class="p">]:</span>
                    <span class="c1"># Give positives that pass automatic thresholds high priority</span>
                    <span class="n">_probs</span> <span class="o">=</span> <span class="n">primary_probs</span><span class="p">[</span><span class="n">POSTV</span><span class="p">]</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="n">_probs</span> <span class="o">&gt;</span> <span class="n">primary_thresh</span><span class="p">[</span><span class="n">POSTV</span><span class="p">]</span>
                    <span class="n">default_priority</span><span class="p">[</span><span class="n">flags</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">default_priority</span><span class="p">[</span><span class="n">flags</span><span class="p">],</span> <span class="n">_probs</span><span class="p">[</span><span class="n">flags</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>

                    <span class="c1"># Give negatives that pass automatic thresholds high priority</span>
                    <span class="n">_probs</span> <span class="o">=</span> <span class="n">primary_probs</span><span class="p">[</span><span class="n">NEGTV</span><span class="p">]</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="n">_probs</span> <span class="o">&gt;</span> <span class="n">primary_thresh</span><span class="p">[</span><span class="n">NEGTV</span><span class="p">]</span>
                    <span class="n">default_priority</span><span class="p">[</span><span class="n">flags</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">default_priority</span><span class="p">[</span><span class="n">flags</span><span class="p">],</span> <span class="n">_probs</span><span class="p">[</span><span class="n">flags</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>

                    <span class="c1"># Give not-comps that pass automatic thresholds high priority</span>
                    <span class="n">_probs</span> <span class="o">=</span> <span class="n">primary_probs</span><span class="p">[</span><span class="n">INCMP</span><span class="p">]</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="n">_probs</span> <span class="o">&gt;</span> <span class="n">primary_thresh</span><span class="p">[</span><span class="n">INCMP</span><span class="p">]</span>
                    <span class="n">default_priority</span><span class="p">[</span><span class="n">flags</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">default_priority</span><span class="p">[</span><span class="n">flags</span><span class="p">],</span> <span class="n">_probs</span><span class="p">[</span><span class="n">flags</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>

            <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="s1">&#39;prob_match&#39;</span><span class="p">,</span> <span class="n">prob_match</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="s1">&#39;default_priority&#39;</span><span class="p">,</span> <span class="n">default_priority</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

            <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;default_priority&#39;</span>
            <span class="n">priority</span> <span class="o">=</span> <span class="n">default_priority</span>
        <span class="k">elif</span> <span class="n">infr</span><span class="o">.</span><span class="n">cm_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s1">&#39;Prioritizing </span><span class="si">{}</span><span class="s1"> edges with one-vs-vsmany scores&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">),</span> <span class="mi">1</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Not given any deploy classifier, this is the best we can do</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_make_lnbnn_scores</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;normscore&#39;</span>
            <span class="n">priority</span> <span class="o">=</span> <span class="n">scores</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s1">&#39;WARNING: No verifiers to prioritize </span><span class="si">{}</span><span class="s1"> edge(s)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;random&#39;</span>
            <span class="n">priority</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">))</span> <span class="o">+</span> <span class="mf">1e-6</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">,</span> <span class="n">priority</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">metric</span><span class="p">,</span> <span class="n">priority</span></div>

<div class="viewcode-block" id="CandidateSearch.ensure_prioritized"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.CandidateSearch.ensure_prioritized">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_prioritized</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">priority_edges</span><span class="p">):</span>
        <span class="n">priority_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)</span>
        <span class="n">metric</span><span class="p">,</span> <span class="n">priority</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ensure_priority_scores</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">prioritize</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">priority_edges</span><span class="p">,</span> <span class="n">scores</span><span class="o">=</span><span class="n">priority</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateSearch.add_candidate_edges"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.CandidateSearch.add_candidate_edges">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">add_candidate_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">candidate_edges</span><span class="p">):</span>
        <span class="n">candidate_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">candidate_edges</span><span class="p">)</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ensure_edges_from</span><span class="p">(</span><span class="n">candidate_edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">test_mode</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">apply_edge_truth</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.enabled&#39;</span><span class="p">]:</span>
            <span class="n">priority_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">filter_edges_flagged_as_redun</span><span class="p">(</span><span class="n">candidate_edges</span><span class="p">))</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s1">&#39;Got </span><span class="si">{}</span><span class="s1"> candidate edges, </span><span class="si">{}</span><span class="s1"> are new, &#39;</span>
                <span class="s1">&#39;and </span><span class="si">{}</span><span class="s1"> are non-redundant&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">candidate_edges</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_edges</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s1">&#39;Got </span><span class="si">{}</span><span class="s1"> candidate edges and </span><span class="si">{}</span><span class="s1"> are new&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">candidate_edges</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">priority_edges</span> <span class="o">=</span> <span class="n">candidate_edges</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">ensure_prioritized</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="s1">&#39;on_new_candidate_edges&#39;</span><span class="p">):</span>
                <span class="c1"># hack callback for demo</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">on_new_candidate_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">priority_edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateSearch.refresh_candidate_edges"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_matching.CandidateSearch.refresh_candidate_edges">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">refresh_candidate_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for candidate edges.</span>
<span class="sd">        Assign each edge a priority and add to queue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;refresh_candidate_edges&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">assert_consistency_invariant</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">candidate_edges</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">find_lnbnn_candidate_edges</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="s1">&#39;dummy_verif&#39;</span><span class="p">):</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Searching for dummy candidates&#39;</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s1">&#39;dummy vsone params =&#39;</span>
                <span class="o">+</span> <span class="n">ut</span><span class="o">.</span><span class="n">repr4</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">dummy_verif</span><span class="o">.</span><span class="n">dummy_params</span><span class="p">,</span> <span class="n">nl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">si</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">ranks_top</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ranking.ntop&#39;</span><span class="p">]</span>
            <span class="n">candidate_edges</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">dummy_verif</span><span class="o">.</span><span class="n">find_candidate_edges</span><span class="p">(</span><span class="n">K</span><span class="o">=</span><span class="n">ranks_top</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No method available to search for candidate edges&#39;</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">add_candidate_edges</span><span class="p">(</span><span class="n">candidate_edges</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">assert_consistency_invariant</span><span class="p">()</span></div>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_make_task_probs</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict edge probs for each pairwise classifier task</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">verifiers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no classifiers exist&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">verifiers</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;need to deploy or implement eval prediction&#39;</span><span class="p">)</span>
        <span class="n">task_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">verifiers</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">task_probs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># infr.print(&#39;[make_taks_probs] predict {} for {} edges&#39;.format(</span>
        <span class="c1">#     ut.conj_phrase(task_keys, &#39;and&#39;), len(edges)))</span>
        <span class="k">for</span> <span class="n">task_key</span> <span class="ow">in</span> <span class="n">task_keys</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;predict </span><span class="si">{}</span><span class="s1"> for </span><span class="si">{}</span><span class="s1"> edges&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">task_key</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)))</span>
            <span class="n">verif</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">verifiers</span><span class="p">[</span><span class="n">task_key</span><span class="p">]</span>
            <span class="n">probs_df</span> <span class="o">=</span> <span class="n">verif</span><span class="o">.</span><span class="n">predict_proba_df</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
            <span class="n">task_probs</span><span class="p">[</span><span class="n">task_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">probs_df</span>
        <span class="k">return</span> <span class="n">task_probs</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_make_lnbnn_scores</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="n">edge_to_data</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_get_cm_edge_data</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edge_to_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">edge_scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">take_column</span><span class="p">(</span><span class="n">edge_to_data</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="s1">&#39;score&#39;</span><span class="p">))</span>
        <span class="n">edge_scores</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">replace_nones</span><span class="p">(</span><span class="n">edge_scores</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">edge_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_scores</span><span class="p">)</span>
        <span class="c1"># take the inf-norm</span>
        <span class="n">normscores</span> <span class="o">=</span> <span class="n">edge_scores</span> <span class="o">/</span> <span class="n">vt</span><span class="o">.</span><span class="n">safe_max</span><span class="p">(</span><span class="n">edge_scores</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">normscores</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m wbia.algo.graph.mixin_matching</span>
<span class="sd">        python -m wbia.algo.graph.mixin_matching --allexamples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>

    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>  <span class="c1"># for win32</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>  <span class="c1"># NOQA</span>

    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

          </div>

        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">wbia</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../wbia.html">wbia - Wildbook IA</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../wbia.html">wbia</a><ul>
  <li><a href="../../algo.html">wbia.algo</a><ul>
  <li><a href="../graph.html">wbia.algo.graph</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Wild Me.

      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>

    </div>




  </body>
</html>
