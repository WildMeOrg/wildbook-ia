
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>wbia.algo.graph.mixin_wbia &#8212; wbia 2.2.4 documentation</title>
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />

  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />


  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">


          <div class="body" role="main">

  <h1>Source code for wbia.algo.graph.mixin_wbia</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>  <span class="c1"># NOQA</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">wbia.algo.graph</span> <span class="k">import</span> <span class="n">nx_utils</span> <span class="k">as</span> <span class="n">nxu</span>
<span class="kn">from</span> <span class="nn">wbia.algo.graph.state</span> <span class="k">import</span> <span class="n">POSTV</span><span class="p">,</span> <span class="n">NEGTV</span><span class="p">,</span> <span class="n">INCMP</span><span class="p">,</span> <span class="n">UNREV</span><span class="p">,</span> <span class="n">UNKWN</span>  <span class="c1"># NOQA</span>

<span class="nb">print</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">inject2</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="IBEISIO"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">ReloadingMetaclass</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">IBEISIO</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Direct interface into wbia tables and delta statistics</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IBEISIO.add_annots"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.add_annots">[docs]</a>    <span class="k">def</span> <span class="nf">add_annots</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">aid_list</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="IBEISIO.wbia_delta_info"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.wbia_delta_info">[docs]</a>    <span class="k">def</span> <span class="nf">wbia_delta_info</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge_delta_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name_delta_df</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name_delta_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_delta_df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">get_wbia_name_delta</span><span class="p">()</span>

        <span class="n">name_stats_df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">name_group_stats</span><span class="p">()</span>
        <span class="n">name_delta_stats_df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">wbia_name_group_delta_info</span><span class="p">()</span>

        <span class="n">edge_delta_info</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">wbia_edge_delta_info</span><span class="p">(</span><span class="n">edge_delta_df</span><span class="p">)</span>

        <span class="n">info</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">odict</span><span class="p">([(</span><span class="s1">&#39;num_annots_with_names_changed&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_delta_df</span><span class="p">)),])</span>
        <span class="n">info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edge_delta_info</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">name_stats_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;num_&#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">name_delta_stats_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;num_&#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">info</span></div>

<div class="viewcode-block" id="IBEISIO.wbia_edge_delta_info"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.wbia_edge_delta_info">[docs]</a>    <span class="k">def</span> <span class="nf">wbia_edge_delta_info</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge_delta_df</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge_delta_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_delta_df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">match_state_delta</span><span class="p">(</span><span class="n">old</span><span class="o">=</span><span class="s1">&#39;annotmatch&#39;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

        <span class="c1"># Look at what changed</span>
        <span class="n">tag_flags</span> <span class="o">=</span> <span class="n">edge_delta_df</span><span class="p">[</span><span class="s1">&#39;old_tags&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">edge_delta_df</span><span class="p">[</span><span class="s1">&#39;new_tags&#39;</span><span class="p">]</span>
        <span class="n">state_flags</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">edge_delta_df</span><span class="p">[</span><span class="s1">&#39;old_evidence_decision&#39;</span><span class="p">]</span>
            <span class="o">!=</span> <span class="n">edge_delta_df</span><span class="p">[</span><span class="s1">&#39;new_evidence_decision&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">is_added_to_am</span> <span class="o">=</span> <span class="n">edge_delta_df</span><span class="p">[</span><span class="s1">&#39;am_rowid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
        <span class="n">is_new</span> <span class="o">=</span> <span class="n">edge_delta_df</span><span class="p">[</span><span class="s1">&#39;is_new&#39;</span><span class="p">]</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">odict</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="c1"># Technically num_edges_added only cares if the edge exists in the</span>
                <span class="c1"># annotmatch table.</span>
                <span class="p">(</span><span class="s1">&#39;num_edges_added_to_am&#39;</span><span class="p">,</span> <span class="n">is_added_to_am</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
                <span class="p">(</span><span class="s1">&#39;num_edges_added&#39;</span><span class="p">,</span> <span class="n">is_new</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
                <span class="p">(</span><span class="s1">&#39;num_edges_modified&#39;</span><span class="p">,</span> <span class="p">(</span><span class="o">~</span><span class="n">is_new</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
                <span class="p">(</span>
                    <span class="s1">&#39;num_changed_decision_and_tags&#39;</span><span class="p">,</span>
                    <span class="p">((</span><span class="n">tag_flags</span> <span class="o">&amp;</span> <span class="n">state_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">is_new</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
                <span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;num_changed_tags&#39;</span><span class="p">,</span> <span class="p">((</span><span class="n">tag_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">state_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">is_new</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())),</span>
                <span class="p">(</span><span class="s1">&#39;num_changed_decision&#39;</span><span class="p">,</span> <span class="p">((</span><span class="o">~</span><span class="n">tag_flags</span> <span class="o">&amp;</span> <span class="n">state_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">is_new</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())),</span>
                <span class="c1"># &#39;num_non_pos_redundant&#39;: num_non_pos_redundant,</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">info</span></div>

<div class="viewcode-block" id="IBEISIO.name_label_group_delta_info"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.name_label_group_delta_info">[docs]</a>    <span class="k">def</span> <span class="nf">name_label_group_delta_info</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the name labeling delta is non-zero then you need to rectify names</span>

<span class="sd">        infr.relabel_using_reviews(rectify=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aids</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">aids</span>
        <span class="n">name_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">gen_node_values</span><span class="p">(</span><span class="s1">&#39;name_label&#39;</span><span class="p">,</span> <span class="n">aids</span><span class="p">))</span>
        <span class="n">old_ccs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">group_items</span><span class="p">(</span><span class="n">aids</span><span class="p">,</span> <span class="n">name_labels</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">new_ccs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">positive_components</span><span class="p">())</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">name_group_delta_stats</span><span class="p">(</span><span class="n">old_ccs</span><span class="p">,</span> <span class="n">new_ccs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="IBEISIO.wbia_name_group_delta_info"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.wbia_name_group_delta_info">[docs]</a>    <span class="k">def</span> <span class="nf">wbia_name_group_delta_info</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        infr.relabel_using_reviews(rectify=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aids</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">aids</span>
        <span class="n">new_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">gen_node_values</span><span class="p">(</span><span class="s1">&#39;name_label&#39;</span><span class="p">,</span> <span class="n">aids</span><span class="p">))</span>
        <span class="n">new_ccs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">group_items</span><span class="p">(</span><span class="n">aids</span><span class="p">,</span> <span class="n">new_names</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">old_names</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_name_texts</span><span class="p">(</span><span class="n">aids</span><span class="p">,</span> <span class="n">distinguish_unknowns</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">old_ccs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">group_items</span><span class="p">(</span><span class="n">aids</span><span class="p">,</span> <span class="n">old_names</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">name_group_delta_stats</span><span class="p">(</span><span class="n">old_ccs</span><span class="p">,</span> <span class="n">new_ccs</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="IBEISIO.name_group_stats"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.name_group_stats">[docs]</a>    <span class="k">def</span> <span class="nf">name_group_stats</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">odict</span><span class="p">()</span>
        <span class="n">statsmap</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ut</span><span class="o">.</span><span class="n">stats_dict</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;pos_redun&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">find_pos_redundant_pccs</span><span class="p">())</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;non_pos_redun&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">find_non_pos_redundant_pccs</span><span class="p">())</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;inconsistent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">inconsistent_components</span><span class="p">())</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;consistent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">consistent_components</span><span class="p">())</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Name Group stats:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">float_format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="IBEISIO.name_group_delta_stats"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.name_group_delta_stats">[docs]</a>    <span class="k">def</span> <span class="nf">name_group_delta_stats</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">old_ccs</span><span class="p">,</span> <span class="n">new_ccs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">group_delta</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">grouping_delta</span><span class="p">(</span><span class="n">old_ccs</span><span class="p">,</span> <span class="n">new_ccs</span><span class="p">)</span>

        <span class="n">stats</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">odict</span><span class="p">()</span>
        <span class="n">unchanged</span> <span class="o">=</span> <span class="n">group_delta</span><span class="p">[</span><span class="s1">&#39;unchanged&#39;</span><span class="p">]</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="n">group_delta</span><span class="p">[</span><span class="s1">&#39;splits&#39;</span><span class="p">]</span>
        <span class="n">merges</span> <span class="o">=</span> <span class="n">group_delta</span><span class="p">[</span><span class="s1">&#39;merges&#39;</span><span class="p">]</span>
        <span class="n">hybrid</span> <span class="o">=</span> <span class="n">group_delta</span><span class="p">[</span><span class="s1">&#39;hybrid&#39;</span><span class="p">]</span>
        <span class="n">statsmap</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ut</span><span class="o">.</span><span class="n">stats_dict</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;unchanged&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">unchanged</span><span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;old_split&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">splits</span><span class="p">[</span><span class="s1">&#39;old&#39;</span><span class="p">])</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;new_split&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">splits</span><span class="p">[</span><span class="s1">&#39;new&#39;</span><span class="p">]))</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;old_merge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">merges</span><span class="p">[</span><span class="s1">&#39;old&#39;</span><span class="p">]))</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;new_merge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">merges</span><span class="p">[</span><span class="s1">&#39;new&#39;</span><span class="p">])</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;old_hybrid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">hybrid</span><span class="p">[</span><span class="s1">&#39;old&#39;</span><span class="p">])</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;new_hybrid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsmap</span><span class="p">(</span><span class="n">hybrid</span><span class="p">[</span><span class="s1">&#39;new&#39;</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Name Group changes:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">float_format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="IBEISIO.find_unjustified_splits"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.find_unjustified_splits">[docs]</a>    <span class="k">def</span> <span class="nf">find_unjustified_splits</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_helpers import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; ibs = wbia.opendb(defaultdb=&#39;GZ_Master1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ibs = wbia.opendb(defaultdb=&#39;PZ_Master1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(ibs, &#39;all&#39;, autoinit=True)</span>
<span class="sd">            &gt;&gt;&gt; infr.reset_feedback(&#39;staging&#39;, apply=True)</span>
<span class="sd">            &gt;&gt;&gt; infr.relabel_using_reviews(rectify=False)</span>
<span class="sd">            &gt;&gt;&gt; unjustified = infr.find_unjustified_splits()</span>
<span class="sd">            &gt;&gt;&gt; review_edges = []</span>
<span class="sd">            &gt;&gt;&gt; for cc1, cc2 in unjustified:</span>
<span class="sd">            &gt;&gt;&gt;     u = next(iter(cc1))</span>
<span class="sd">            &gt;&gt;&gt;     v = next(iter(cc2))</span>
<span class="sd">            &gt;&gt;&gt;     review_edges.append(nxu.e_(u, v))</span>
<span class="sd">            &gt;&gt;&gt; infr.verbose = 100</span>
<span class="sd">            &gt;&gt;&gt; infr.prioritize(</span>
<span class="sd">            &gt;&gt;&gt;     edges=review_edges, scores=[1] * len(review_edges),</span>
<span class="sd">            &gt;&gt;&gt;     reset=True,</span>
<span class="sd">            &gt;&gt;&gt; )</span>
<span class="sd">            &gt;&gt;&gt; infr.qt_review_loop()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="n">annots</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">annots</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">aids</span><span class="p">)</span>
        <span class="n">ibs_ccs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">aids</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">annots</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">annots</span><span class="o">.</span><span class="n">nids</span><span class="p">)[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">infr_ccs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">positive_components</span><span class="p">())</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">grouping_delta</span><span class="p">(</span><span class="n">ibs_ccs</span><span class="p">,</span> <span class="n">infr_ccs</span><span class="p">)</span>

        <span class="n">hyrbid_splits</span> <span class="o">=</span> <span class="p">[</span><span class="n">ccs</span> <span class="k">for</span> <span class="n">ccs</span> <span class="ow">in</span> <span class="n">delta</span><span class="p">[</span><span class="s1">&#39;hybrid&#39;</span><span class="p">][</span><span class="s1">&#39;splits&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">pure_splits</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[</span><span class="s1">&#39;splits&#39;</span><span class="p">][</span><span class="s1">&#39;new&#39;</span><span class="p">]</span>

        <span class="n">new_splits</span> <span class="o">=</span> <span class="n">hyrbid_splits</span> <span class="o">+</span> <span class="n">pure_splits</span>
        <span class="n">unjustified</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ccs</span> <span class="ow">in</span> <span class="n">new_splits</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span> <span class="ow">in</span> <span class="n">ut</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">ccs</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_between</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">))</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">get_edge_dataframe</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;evidence_decision&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">NEGTV</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">n_incmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;evidence_decision&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">INCMP</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">n_incmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>
                    <span class="n">unjustified</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">))</span>
                    <span class="c1"># print(&#39;--------------------------------&#39;)</span>
                    <span class="c1"># print(&#39;No decision to justify splitting&#39;)</span>
                    <span class="c1"># print(&#39;cc1 = %r&#39; % (cc1,))</span>
                    <span class="c1"># print(&#39;cc2 = %r&#39; % (cc2,))</span>
                    <span class="c1"># if len(df):</span>
                    <span class="c1">#     df.index.names = (&#39;aid1&#39;, &#39;aid2&#39;)</span>
                    <span class="c1">#     nids = np.array([</span>
                    <span class="c1">#         infr.pos_graph.node_labels(u, v)</span>
                    <span class="c1">#         for u, v in list(df.index)])</span>
                    <span class="c1">#     df = df.assign(nid1=nids.T[0], nid2=nids.T[1])</span>
                    <span class="c1">#     print(df)</span>
        <span class="k">return</span> <span class="n">unjustified</span></div>

<div class="viewcode-block" id="IBEISIO.reset_labels_to_wbia"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.reset_labels_to_wbia">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">reset_labels_to_wbia</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sets to IBEIS de-facto labels if available &quot;&quot;&quot;</span>
        <span class="n">nids</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_nids</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">aids</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_node_attrs</span><span class="p">(</span><span class="s1">&#39;name_label&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">aids</span><span class="p">,</span> <span class="n">nids</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_prepare_write_wbia_staging_feedback</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">feedback</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        builds data that will be sent to ibs.add_review</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: (aid_1_list, aid_2_list, add_review_kw)</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.mixin_wbia _prepare_write_wbia_staging_feedback</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_wbia import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(&#39;PZ_MTEST&#39;, aids=list(range(1, 10)),</span>
<span class="sd">            &gt;&gt;&gt;                             autoinit=&#39;annotmatch&#39;, verbose=4)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((6, 7), NEGTV, user_id=&#39;user:foobar&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((5, 8), NEGTV, tags=[&#39;photobomb&#39;])</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((4, 5), POSTV, confidence=&#39;absolutely_sure&#39;)</span>
<span class="sd">            &gt;&gt;&gt; feedback = infr.internal_feedback</span>
<span class="sd">            &gt;&gt;&gt; tup = infr._prepare_write_wbia_staging_feedback(feedback)</span>
<span class="sd">            &gt;&gt;&gt; (aid_1_list, aid_2_list, add_review_kw) = tup</span>
<span class="sd">            &gt;&gt;&gt; expected = set(ut.get_func_argspec(infr.ibs.add_review).args)</span>
<span class="sd">            &gt;&gt;&gt; got = set(add_review_kw.keys())</span>
<span class="sd">            &gt;&gt;&gt; overlap = ut.set_overlap_items(expected, got)</span>
<span class="sd">            &gt;&gt;&gt; assert got.issubset(expected), ut.repr4(overlap, nl=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">uuid</span>

        <span class="c1"># Map what add_review expects to the keys used by feedback items</span>
        <span class="n">add_review_alias</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;evidence_decision_list&#39;</span><span class="p">:</span> <span class="s1">&#39;evidence_decision&#39;</span><span class="p">,</span>
            <span class="s1">&#39;meta_decision_list&#39;</span><span class="p">:</span> <span class="s1">&#39;meta_decision&#39;</span><span class="p">,</span>
            <span class="s1">&#39;review_uuid_list&#39;</span><span class="p">:</span> <span class="s1">&#39;uuid&#39;</span><span class="p">,</span>
            <span class="s1">&#39;identity_list&#39;</span><span class="p">:</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
            <span class="s1">&#39;user_confidence_list&#39;</span><span class="p">:</span> <span class="s1">&#39;confidence&#39;</span><span class="p">,</span>
            <span class="s1">&#39;tags_list&#39;</span><span class="p">:</span> <span class="s1">&#39;tags&#39;</span><span class="p">,</span>
            <span class="s1">&#39;review_client_start_time_posix&#39;</span><span class="p">:</span> <span class="s1">&#39;timestamp_c1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;review_client_end_time_posix&#39;</span><span class="p">:</span> <span class="s1">&#39;timestamp_c2&#39;</span><span class="p">,</span>
            <span class="s1">&#39;review_server_start_time_posix&#39;</span><span class="p">:</span> <span class="s1">&#39;timestamp_s1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;review_server_end_time_posix&#39;</span><span class="p">:</span> <span class="s1">&#39;timestamp&#39;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Initialize kwargs we will pass to add_review</span>
        <span class="n">aid_1_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">aid_2_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">add_review_kw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">add_review_alias</span><span class="p">:</span>
            <span class="n">add_review_kw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Translate data from feedback items into add_review format</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span><span class="p">,</span> <span class="n">feedback_item</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span><span class="p">),</span> <span class="n">feedbacks</span> <span class="ow">in</span> <span class="n">feedback</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">feedback_item</span> <span class="ow">in</span> <span class="n">feedbacks</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span><span class="p">,</span> <span class="n">feedback_item</span> <span class="ow">in</span> <span class="n">_iter</span><span class="p">:</span>
            <span class="n">aid_1_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aid1</span><span class="p">)</span>
            <span class="n">aid_2_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aid2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">review_key</span><span class="p">,</span> <span class="n">fbkey</span> <span class="ow">in</span> <span class="n">add_review_alias</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">feedback_item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fbkey</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="c1"># Do mapping for particular keys</span>
                <span class="k">if</span> <span class="n">fbkey</span> <span class="o">==</span> <span class="s1">&#39;tags&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">elif</span> <span class="n">fbkey</span> <span class="o">==</span> <span class="s1">&#39;uuid&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">fbkey</span> <span class="o">==</span> <span class="s1">&#39;confidence&#39;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">CONFIDENCE</span><span class="o">.</span><span class="n">CODE_TO_INT</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">fbkey</span> <span class="o">==</span> <span class="s1">&#39;evidence_decision&#39;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">EVIDENCE_DECISION</span><span class="o">.</span><span class="n">CODE_TO_INT</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">fbkey</span> <span class="o">==</span> <span class="s1">&#39;meta_decision&#39;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">META_DECISION</span><span class="o">.</span><span class="n">CODE_TO_INT</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
                <span class="n">add_review_kw</span><span class="p">[</span><span class="n">review_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aid_1_list</span><span class="p">,</span> <span class="n">aid_2_list</span><span class="p">,</span> <span class="n">add_review_kw</span>

    <span class="k">def</span> <span class="nf">_write_wbia_staging_feedback</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">feedback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        feedback = infr.internal_feedback</span>
<span class="sd">        ibs.staging.get_table_as_pandas(&#39;reviews&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;write_wbia_staging_feedback </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feedback</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_prepare_write_wbia_staging_feedback</span><span class="p">(</span><span class="n">feedback</span><span class="p">)</span>
        <span class="n">aid_1_list</span><span class="p">,</span> <span class="n">aid_2_list</span><span class="p">,</span> <span class="n">add_review_kw</span> <span class="o">=</span> <span class="n">tup</span>

        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="n">review_id_list</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">add_review</span><span class="p">(</span><span class="n">aid_1_list</span><span class="p">,</span> <span class="n">aid_2_list</span><span class="p">,</span> <span class="o">**</span><span class="n">add_review_kw</span><span class="p">)</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">find_duplicate_items</span><span class="p">(</span><span class="n">review_id_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="s1">&#39;Staging should only be appended to but we found a duplicate&#39;</span>
                <span class="s1">&#39; row. &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">duplicates</span><span class="p">)</span>
            <span class="p">)</span>

<div class="viewcode-block" id="IBEISIO.write_wbia_staging_feedback"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.write_wbia_staging_feedback">[docs]</a>    <span class="k">def</span> <span class="nf">write_wbia_staging_feedback</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commit all reviews in internal_feedback into the staging table.  The</span>
<span class="sd">        edges are removed from interal_feedback and added to external feedback.</span>
<span class="sd">        The staging tables stores each review in the order it happened so</span>
<span class="sd">        history is fully reconstructable if staging is never deleted.</span>

<span class="sd">        This write function is done using the implicit delta maintained by</span>
<span class="sd">        infr.internal_feedback. Therefore, it take no args. This is generally</span>
<span class="sd">        called automatically by `infr.accept`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">internal_feedback</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;write_wbia_staging_feedback 0&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Write internal feedback to disk</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">_write_wbia_staging_feedback</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">internal_feedback</span><span class="p">)</span>
        <span class="c1"># Copy internal feedback into external</span>
        <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">feedbacks</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">internal_feedback</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">external_feedback</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">feedbacks</span><span class="p">)</span>
        <span class="c1"># Delete internal feedback</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">internal_feedback</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>

<div class="viewcode-block" id="IBEISIO.write_wbia_annotmatch_feedback"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.write_wbia_annotmatch_feedback">[docs]</a>    <span class="k">def</span> <span class="nf">write_wbia_annotmatch_feedback</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge_delta_df</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits the current state in external and internal into the annotmatch</span>
<span class="sd">        table. Annotmatch only stores the final review in the history of reviews.</span>

<span class="sd">        By default this will sync the current graph state to the annotmatch</span>
<span class="sd">        table. It computes the edge_delta under the hood, so if you already</span>
<span class="sd">        made one then you can pass it in for a little extra speed.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_delta_df (pd.DataFrame): precomputed using match_state_delta.</span>
<span class="sd">                if None it will be computed under the hood.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge_delta_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_delta_df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">match_state_delta</span><span class="p">(</span><span class="n">old</span><span class="o">=</span><span class="s1">&#39;annotmatch&#39;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;write_wbia_annotmatch_feedback </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_delta_df</span><span class="p">)))</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="n">edge_delta_df_</span> <span class="o">=</span> <span class="n">edge_delta_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="c1"># Find the rows not yet in the annotmatch table</span>
        <span class="n">is_add</span> <span class="o">=</span> <span class="n">edge_delta_df_</span><span class="p">[</span><span class="s1">&#39;am_rowid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
        <span class="n">add_df</span> <span class="o">=</span> <span class="n">edge_delta_df_</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">is_add</span><span class="p">]</span>
        <span class="c1"># Assign then a new annotmatch rowid</span>
        <span class="n">add_ams</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">add_annotmatch_undirected</span><span class="p">(</span>
            <span class="n">add_df</span><span class="p">[</span><span class="s1">&#39;aid1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">add_df</span><span class="p">[</span><span class="s1">&#39;aid2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="p">)</span>
        <span class="n">edge_delta_df_</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">is_add</span><span class="p">,</span> <span class="s1">&#39;am_rowid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_ams</span>

        <span class="c1"># Set residual matching data</span>
        <span class="n">new_evidence_decisions</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
            <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">EVIDENCE_DECISION</span><span class="o">.</span><span class="n">CODE_TO_INT</span><span class="p">,</span>
            <span class="n">edge_delta_df_</span><span class="p">[</span><span class="s1">&#39;new_evidence_decision&#39;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">new_meta_decisions</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
            <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">META_DECISION</span><span class="o">.</span><span class="n">CODE_TO_INT</span><span class="p">,</span> <span class="n">edge_delta_df_</span><span class="p">[</span><span class="s1">&#39;new_meta_decision&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">new_tags</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">tags</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="k">for</span> <span class="n">tags</span> <span class="ow">in</span> <span class="n">edge_delta_df_</span><span class="p">[</span><span class="s1">&#39;new_tags&#39;</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">new_conf</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take</span><span class="p">(</span>
            <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">CONFIDENCE</span><span class="o">.</span><span class="n">CODE_TO_INT</span><span class="p">,</span> <span class="n">edge_delta_df_</span><span class="p">[</span><span class="s1">&#39;new_confidence&#39;</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">new_timestamp</span> <span class="o">=</span> <span class="n">edge_delta_df_</span><span class="p">[</span><span class="s1">&#39;new_timestamp&#39;</span><span class="p">]</span>
        <span class="n">new_reviewer</span> <span class="o">=</span> <span class="n">edge_delta_df_</span><span class="p">[</span><span class="s1">&#39;new_user_id&#39;</span><span class="p">]</span>
        <span class="n">am_rowids</span> <span class="o">=</span> <span class="n">edge_delta_df_</span><span class="p">[</span><span class="s1">&#39;am_rowid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_evidence_decision</span><span class="p">(</span><span class="n">am_rowids</span><span class="p">,</span> <span class="n">new_evidence_decisions</span><span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_meta_decision</span><span class="p">(</span><span class="n">am_rowids</span><span class="p">,</span> <span class="n">new_meta_decisions</span><span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_tag_text</span><span class="p">(</span><span class="n">am_rowids</span><span class="p">,</span> <span class="n">new_tags</span><span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_confidence</span><span class="p">(</span><span class="n">am_rowids</span><span class="p">,</span> <span class="n">new_conf</span><span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_reviewer</span><span class="p">(</span><span class="n">am_rowids</span><span class="p">,</span> <span class="n">new_reviewer</span><span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_posixtime_modified</span><span class="p">(</span><span class="n">am_rowids</span><span class="p">,</span> <span class="n">new_timestamp</span><span class="p">)</span></div>
        <span class="c1"># ibs.set_annotmatch_count(am_rowids, new_timestamp) TODO</span>

<div class="viewcode-block" id="IBEISIO.write_wbia_name_assignment"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.write_wbia_name_assignment">[docs]</a>    <span class="k">def</span> <span class="nf">write_wbia_name_assignment</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">name_delta_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the name delta to the annotations table.</span>

<span class="sd">        It computes the name delta under the hood, so if you already made one</span>
<span class="sd">        then you can pass it in for a little extra speed.</span>

<span class="sd">        Note:</span>
<span class="sd">            This will call infr.relabel_using_reviews(rectify=True) if</span>
<span class="sd">            name_delta_df is not given directly.</span>

<span class="sd">        Args:</span>
<span class="sd">            name_delta_df (pd.DataFrame): if None, the value is computed using</span>
<span class="sd">                `get_wbia_name_delta`. Note you should ensure this delta is made</span>
<span class="sd">                after nodes have been relabeled using reviews.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name_delta_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_delta_df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">get_wbia_name_delta</span><span class="p">()</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;write_wbia_name_assignment id </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_delta_df</span><span class="p">))</span>
        <span class="n">aid_list</span> <span class="o">=</span> <span class="n">name_delta_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">new_name_list</span> <span class="o">=</span> <span class="n">name_delta_df</span><span class="p">[</span><span class="s1">&#39;new_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">set_annot_names</span><span class="p">(</span><span class="n">aid_list</span><span class="p">,</span> <span class="n">new_name_list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="IBEISIO.get_wbia_name_delta"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.get_wbia_name_delta">[docs]</a>    <span class="k">def</span> <span class="nf">get_wbia_name_delta</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">ignore_unknown</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rectifies internal name_labels with the names stored in the name table.</span>

<span class="sd">        Return a pandas dataframe indicating which names have changed for what</span>
<span class="sd">        annotations.</span>

<span class="sd">        Args:</span>
<span class="sd">            ignore_unknown (bool): if True does not return deltas for unknown</span>
<span class="sd">                annotations (those with degree 0).</span>
<span class="sd">            relabel (bool): if True, ensures that all nodes are labeled based</span>
<span class="sd">                on the current PCCs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame - name_delta_df - data frame where each row specifies</span>
<span class="sd">                an aid and its `old_name` which is in the wbia database and</span>
<span class="sd">                the `new_name` which is what we infer it should be renamed to.</span>

<span class="sd">        Example:</span>
<span class="sd">            infr.write_wbia_name_assignment</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.mixin_wbia get_wbia_name_delta</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_wbia import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(&#39;PZ_MTEST&#39;, aids=list(range(1, 10)),</span>
<span class="sd">            &gt;&gt;&gt;                             autoinit=&#39;annotmatch&#39;, verbose=4)</span>
<span class="sd">            &gt;&gt;&gt; pccs1 = list(infr.positive_components())</span>
<span class="sd">            &gt;&gt;&gt; print(&#39;pccs1 = %r&#39; % (pccs1,))</span>
<span class="sd">            &gt;&gt;&gt; print(&#39;names = {}&#39;.format(list(infr.gen_node_values(&#39;name_label&#39;, infr.aids))))</span>
<span class="sd">            &gt;&gt;&gt; assert pccs1 == [{1, 2, 3, 4}, {5, 6, 7, 8}, {9}]</span>
<span class="sd">            &gt;&gt;&gt; # Split a PCC and then merge two other PCCs</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback_from([(1, 2), (1, 3), (1, 4)], evidence_decision=NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((6, 7), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((5, 8), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((4, 5), POSTV)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((7, 8), POSTV)</span>
<span class="sd">            &gt;&gt;&gt; pccs2 = list(infr.positive_components())</span>
<span class="sd">            &gt;&gt;&gt; print(&#39;pccs2 = %r&#39; % (pccs2,))</span>
<span class="sd">            &gt;&gt;&gt; pccs2 = sorted(pccs2)</span>
<span class="sd">            &gt;&gt;&gt; assert pccs2 == [{9}, {1}, {2, 3, 4, 5, 6}, {7, 8}]</span>
<span class="sd">            &gt;&gt;&gt; print(list(infr.gen_node_values(&#39;name_label&#39;, infr.aids)))</span>
<span class="sd">            &gt;&gt;&gt; name_delta_df = infr.get_wbia_name_delta()</span>
<span class="sd">            &gt;&gt;&gt; result = str(name_delta_df)</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">                old_name       new_name</span>
<span class="sd">            aid</span>
<span class="sd">            1     06_410  IBEIS_PZ_0042</span>
<span class="sd">            5     07_061         06_410</span>
<span class="sd">            6     07_061         06_410</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_wbia import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(&#39;PZ_MTEST&#39;, aids=list(range(1, 10)),</span>
<span class="sd">            &gt;&gt;&gt;                             autoinit=&#39;annotmatch&#39;, verbose=4)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback_from([(1, 2), (1, 3), (1, 4)], evidence_decision=NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((4, 5), POSTV)</span>
<span class="sd">            &gt;&gt;&gt; name_delta_df = infr.get_wbia_name_delta()</span>
<span class="sd">            &gt;&gt;&gt; result = str(name_delta_df)</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">                old_name new_name</span>
<span class="sd">            aid</span>
<span class="sd">            2     06_410   07_061</span>
<span class="sd">            3     06_410   07_061</span>
<span class="sd">            4     06_410   07_061</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_wbia import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(&#39;PZ_MTEST&#39;, aids=list(range(1, 10)),</span>
<span class="sd">            &gt;&gt;&gt;                             autoinit=&#39;annotmatch&#39;, verbose=4)</span>
<span class="sd">            &gt;&gt;&gt; name_delta_df = infr.get_wbia_name_delta()</span>
<span class="sd">            &gt;&gt;&gt; result = str(name_delta_df)</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">            Empty DataFrame</span>
<span class="sd">            Columns: [old_name, new_name]</span>
<span class="sd">            Index: []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;constructing name delta&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">relabel</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">relabel_using_reviews</span><span class="p">(</span><span class="n">rectify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">node_to_new_label</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;name_label&#39;</span><span class="p">)</span>
        <span class="n">aids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_to_new_label</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">old_names</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_name_texts</span><span class="p">(</span><span class="n">aids</span><span class="p">,</span> <span class="n">distinguish_unknowns</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Indicate that unknown names should be replaced</span>
        <span class="n">old_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">UNKNOWN</span><span class="p">)</span> <span class="k">else</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">old_names</span>
        <span class="p">]</span>
        <span class="n">new_labels</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">node_to_new_label</span><span class="p">,</span> <span class="n">aids</span><span class="p">)</span>
        <span class="c1"># Recycle as many old names as possible</span>
        <span class="n">label_to_name</span><span class="p">,</span> <span class="n">needs_assign</span><span class="p">,</span> <span class="n">unknown_labels</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_rectify_names</span><span class="p">(</span>
            <span class="n">old_names</span><span class="p">,</span> <span class="n">new_labels</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ignore_unknown</span><span class="p">:</span>
            <span class="n">label_to_name</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">delete_dict_keys</span><span class="p">(</span><span class="n">label_to_name</span><span class="p">,</span> <span class="n">unknown_labels</span><span class="p">)</span>
            <span class="n">needs_assign</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">setdiff</span><span class="p">(</span><span class="n">needs_assign</span><span class="p">,</span> <span class="n">unknown_labels</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;had </span><span class="si">%d</span><span class="s1"> unknown labels&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unknown_labels</span><span class="p">)),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;ignore_unknown = </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ignore_unknown</span><span class="p">,),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;need to make </span><span class="si">%d</span><span class="s1"> new names&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">needs_assign</span><span class="p">)),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Overwrite names of labels with temporary names</span>
        <span class="n">needed_names</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">make_next_name</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">needs_assign</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">unassigned_label</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">needs_assign</span><span class="p">,</span> <span class="n">needed_names</span><span class="p">):</span>
            <span class="n">label_to_name</span><span class="p">[</span><span class="n">unassigned_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span>
        <span class="c1"># Assign each node to the rectified label</span>
        <span class="k">if</span> <span class="n">ignore_unknown</span><span class="p">:</span>
            <span class="n">unknown_labels_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">unknown_labels</span><span class="p">)</span>
            <span class="n">node_to_new_label</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">node</span><span class="p">:</span> <span class="n">label</span>
                <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">node_to_new_label</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unknown_labels_</span>
            <span class="p">}</span>
        <span class="n">aid_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_to_new_label</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">new_name_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">label_to_name</span><span class="p">,</span> <span class="n">node_to_new_label</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">old_name_list</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_name_texts</span><span class="p">(</span><span class="n">aid_list</span><span class="p">,</span> <span class="n">distinguish_unknowns</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Put into a dataframe for convinience</span>
        <span class="n">name_delta_df_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span><span class="s1">&#39;old_name&#39;</span><span class="p">:</span> <span class="n">old_name_list</span><span class="p">,</span> <span class="s1">&#39;new_name&#39;</span><span class="p">:</span> <span class="n">new_name_list</span><span class="p">},</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;old_name&#39;</span><span class="p">,</span> <span class="s1">&#39;new_name&#39;</span><span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">aid_list</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;aid&#39;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">changed_flags</span> <span class="o">=</span> <span class="n">name_delta_df_</span><span class="p">[</span><span class="s1">&#39;old_name&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">name_delta_df_</span><span class="p">[</span><span class="s1">&#39;new_name&#39;</span><span class="p">]</span>
        <span class="n">name_delta_df</span> <span class="o">=</span> <span class="n">name_delta_df_</span><span class="p">[</span><span class="n">changed_flags</span><span class="p">]</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;finished making name delta&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name_delta_df</span></div>

<div class="viewcode-block" id="IBEISIO.read_wbia_staging_feedback"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.read_wbia_staging_feedback">[docs]</a>    <span class="k">def</span> <span class="nf">read_wbia_staging_feedback</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads feedback from review staging table.</span>

<span class="sd">        Args:</span>
<span class="sd">            infr (?):</span>

<span class="sd">        Returns:</span>
<span class="sd">            ?: feedback</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.mixin_wbia read_wbia_staging_feedback</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_wbia import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; ibs = wbia.opendb(&#39;GZ_Master1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(ibs=ibs, aids=&#39;all&#39;)</span>
<span class="sd">            &gt;&gt;&gt; feedback = infr.read_wbia_staging_feedback()</span>
<span class="sd">            &gt;&gt;&gt; result = (&#39;feedback = %s&#39; % (ut.repr2(feedback),))</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: READ ONLY AFTER THE LATEST ANNOTMATCH TIME STAMP</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;read_wbia_staging_feedback&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>

        <span class="kn">from</span> <span class="nn">wbia.control.manual_review_funcs</span> <span class="k">import</span> <span class="n">hack_create_aidpair_index</span>

        <span class="n">hack_create_aidpair_index</span><span class="p">(</span><span class="n">ibs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">review_ids</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_review_rowids_from_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">review_ids</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_review_rowids_between</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">aids</span><span class="p">)</span>

        <span class="n">review_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">review_ids</span><span class="p">)</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;read </span><span class="si">%d</span><span class="s1"> staged reviews&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">review_ids</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">wbia.control.manual_review_funcs</span> <span class="k">import</span> <span class="p">(</span>
            <span class="c1"># REVIEW_UUID,</span>
            <span class="n">REVIEW_AID1</span><span class="p">,</span>
            <span class="n">REVIEW_AID2</span><span class="p">,</span>
            <span class="n">REVIEW_COUNT</span><span class="p">,</span>
            <span class="n">REVIEW_EVIDENCE_DECISION</span><span class="p">,</span>
            <span class="n">REVIEW_META_DECISION</span><span class="p">,</span>
            <span class="n">REVIEW_USER_IDENTITY</span><span class="p">,</span>
            <span class="n">REVIEW_USER_CONFIDENCE</span><span class="p">,</span>
            <span class="n">REVIEW_TAGS</span><span class="p">,</span>
            <span class="n">REVIEW_TIME_CLIENT_START</span><span class="p">,</span>
            <span class="n">REVIEW_TIME_CLIENT_END</span><span class="p">,</span>
            <span class="n">REVIEW_TIME_SERVER_START</span><span class="p">,</span>
            <span class="n">REVIEW_TIME_SERVER_END</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">add_review_alias</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">odict</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="n">REVIEW_AID1</span><span class="p">,</span> <span class="s1">&#39;aid1&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_AID2</span><span class="p">,</span> <span class="s1">&#39;aid2&#39;</span><span class="p">),</span>
                <span class="c1"># (REVIEW_UUID              , &#39;uuid&#39;),</span>
                <span class="p">(</span><span class="n">REVIEW_EVIDENCE_DECISION</span><span class="p">,</span> <span class="s1">&#39;evidence_decision&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_META_DECISION</span><span class="p">,</span> <span class="s1">&#39;meta_decision&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_USER_IDENTITY</span><span class="p">,</span> <span class="s1">&#39;user_id&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_USER_CONFIDENCE</span><span class="p">,</span> <span class="s1">&#39;confidence&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_TAGS</span><span class="p">,</span> <span class="s1">&#39;tags&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_TIME_CLIENT_START</span><span class="p">,</span> <span class="s1">&#39;timestamp_c1&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_TIME_CLIENT_END</span><span class="p">,</span> <span class="s1">&#39;timestamp_c2&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_TIME_SERVER_START</span><span class="p">,</span> <span class="s1">&#39;timestamp_s1&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_TIME_SERVER_END</span><span class="p">,</span> <span class="s1">&#39;timestamp&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">REVIEW_COUNT</span><span class="p">,</span> <span class="s1">&#39;num_reviews&#39;</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">add_review_alias</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">feedback_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">add_review_alias</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">review_data</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">staging</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">REVIEW_TABLE</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">review_ids</span><span class="p">)</span>
        <span class="c1"># table = infr.ibs.staging.get_table_as_pandas(</span>
        <span class="c1">#     ibs.const.REVIEW_TABLE, rowids=review_ids, columns=columns)</span>

        <span class="n">lookup_decision</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">EVIDENCE_DECISION</span><span class="o">.</span><span class="n">INT_TO_CODE</span>
        <span class="n">lookup_meta</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">META_DECISION</span><span class="o">.</span><span class="n">INT_TO_CODE</span>
        <span class="n">lookup_conf</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">CONFIDENCE</span><span class="o">.</span><span class="n">INT_TO_CODE</span>

        <span class="n">feedback</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">review_data</span><span class="p">:</span>
            <span class="n">feedback_item</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">feedback_keys</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
            <span class="n">aid1</span> <span class="o">=</span> <span class="n">feedback_item</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;aid1&#39;</span><span class="p">)</span>
            <span class="n">aid2</span> <span class="o">=</span> <span class="n">feedback_item</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;aid2&#39;</span><span class="p">)</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">e_</span><span class="p">(</span><span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span><span class="p">)</span>

            <span class="n">tags</span> <span class="o">=</span> <span class="n">feedback_item</span><span class="p">[</span><span class="s1">&#39;tags&#39;</span><span class="p">]</span>
            <span class="n">feedback_item</span><span class="p">[</span><span class="s1">&#39;meta_decision&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookup_meta</span><span class="p">[</span><span class="n">feedback_item</span><span class="p">[</span><span class="s1">&#39;meta_decision&#39;</span><span class="p">]]</span>
            <span class="n">feedback_item</span><span class="p">[</span><span class="s1">&#39;evidence_decision&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookup_decision</span><span class="p">[</span>
                <span class="n">feedback_item</span><span class="p">[</span><span class="s1">&#39;evidence_decision&#39;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">feedback_item</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookup_conf</span><span class="p">[</span><span class="n">feedback_item</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]]</span>
            <span class="n">feedback_item</span><span class="p">[</span><span class="s1">&#39;tags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">tags</span> <span class="k">else</span> <span class="n">tags</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span>

            <span class="n">feedback</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feedback_item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">feedback</span></div>

<div class="viewcode-block" id="IBEISIO.read_wbia_annotmatch_feedback"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.read_wbia_annotmatch_feedback">[docs]</a>    <span class="k">def</span> <span class="nf">read_wbia_annotmatch_feedback</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads feedback from annotmatch table and returns the result.</span>
<span class="sd">        Internal state is not changed.</span>

<span class="sd">        Args:</span>
<span class="sd">            only_existing_edges (bool): if True only reads info existing edges</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.core read_wbia_annotmatch_feedback</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.core import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; infr = testdata_infr(&#39;testdb1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; feedback = infr.read_wbia_annotmatch_feedback()</span>
<span class="sd">            &gt;&gt;&gt; items = feedback[(2, 3)]</span>
<span class="sd">            &gt;&gt;&gt; result = (&#39;feedback = %s&#39; % (ut.repr2(feedback, nl=2),))</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">            &gt;&gt;&gt; assert len(feedback) &gt;= 2, &#39;should contain at least 2 edges&#39;</span>
<span class="sd">            &gt;&gt;&gt; assert len(items) == 1, &#39;2-3 should have one review&#39;</span>
<span class="sd">            &gt;&gt;&gt; assert items[0][&#39;evidence_decision&#39;] == POSTV, &#39;2-3 must match&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;read_wbia_annotmatch_feedback&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">annots</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">aids</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">()</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;read </span><span class="si">%d</span><span class="s1"> annotmatch rowids&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Use explicit truth state to mark truth</span>
        <span class="n">aids1</span> <span class="o">=</span> <span class="n">matches</span><span class="o">.</span><span class="n">aid1</span>
        <span class="n">aids2</span> <span class="o">=</span> <span class="n">matches</span><span class="o">.</span><span class="n">aid2</span>

        <span class="n">column_lists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;evidence_decision&#39;</span><span class="p">:</span> <span class="n">matches</span><span class="o">.</span><span class="n">evidence_decision_code</span><span class="p">,</span>
            <span class="s1">&#39;meta_decision&#39;</span><span class="p">:</span> <span class="n">matches</span><span class="o">.</span><span class="n">meta_decision_code</span><span class="p">,</span>
            <span class="s1">&#39;timestamp_c1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">),</span>
            <span class="s1">&#39;timestamp_c2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">),</span>
            <span class="s1">&#39;timestamp_s1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">),</span>
            <span class="s1">&#39;timestamp&#39;</span><span class="p">:</span> <span class="n">matches</span><span class="o">.</span><span class="n">posixtime_modified</span><span class="p">,</span>
            <span class="s1">&#39;tags&#39;</span><span class="p">:</span> <span class="n">matches</span><span class="o">.</span><span class="n">case_tags</span><span class="p">,</span>
            <span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="n">matches</span><span class="o">.</span><span class="n">reviewer</span><span class="p">,</span>
            <span class="s1">&#39;confidence&#39;</span><span class="p">:</span> <span class="n">matches</span><span class="o">.</span><span class="n">confidence_code</span><span class="p">,</span>
            <span class="s1">&#39;num_reviews&#39;</span><span class="p">:</span> <span class="n">matches</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">feedback</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">aids1</span><span class="p">,</span> <span class="n">aids2</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">column_lists</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">e_</span><span class="p">(</span><span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span><span class="p">)</span>
            <span class="n">feedback_item</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">column_lists</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">row</span><span class="p">))</span>
            <span class="n">feedback</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feedback_item</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;read </span><span class="si">%d</span><span class="s1"> annotmatch entries&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feedback</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">feedback</span></div>

<div class="viewcode-block" id="IBEISIO.reset_staging_with_ensure"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.reset_staging_with_ensure">[docs]</a>    <span class="k">def</span> <span class="nf">reset_staging_with_ensure</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure staging has all info that annotmatch has.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">staging_feedback</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">read_wbia_staging_feedback</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">staging_feedback</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">internal_feedback</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">read_wbia_annotmatch_feedback</span><span class="p">()</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">write_wbia_staging_feedback</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">external_feedback</span> <span class="o">=</span> <span class="n">staging_feedback</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">internal_feedback</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>
        <span class="c1"># edge_delta_df = infr.match_state_delta(old=&#39;staging&#39;,</span>
        <span class="c1"># new=&#39;annotmatch&#39;)</span>

    <span class="k">def</span> <span class="nf">_pandas_feedback_format</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">feedback</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

        <span class="n">aid_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">feedback</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">aids1</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take_column</span><span class="p">(</span><span class="n">aid_pairs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">aids2</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take_column</span><span class="p">(</span><span class="n">aid_pairs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="n">am_rowids</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_annotmatch_rowid_from_undirected_superkey</span><span class="p">(</span><span class="n">aids1</span><span class="p">,</span> <span class="n">aids2</span><span class="p">)</span>
        <span class="n">rectified_feedback_</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_rectify_feedback</span><span class="p">(</span><span class="n">feedback</span><span class="p">)</span>
        <span class="n">rectified_feedback</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">rectified_feedback_</span><span class="p">,</span> <span class="n">aid_pairs</span><span class="p">)</span>
        <span class="n">decision</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take_column</span><span class="p">(</span><span class="n">rectified_feedback</span><span class="p">,</span> <span class="s1">&#39;evidence_decision&#39;</span><span class="p">)</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take_column</span><span class="p">(</span><span class="n">rectified_feedback</span><span class="p">,</span> <span class="s1">&#39;tags&#39;</span><span class="p">)</span>
        <span class="n">confidence</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take_column</span><span class="p">(</span><span class="n">rectified_feedback</span><span class="p">,</span> <span class="s1">&#39;confidence&#39;</span><span class="p">)</span>
        <span class="n">timestamp_c1</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take_column</span><span class="p">(</span><span class="n">rectified_feedback</span><span class="p">,</span> <span class="s1">&#39;timestamp_c1&#39;</span><span class="p">)</span>
        <span class="n">timestamp_c2</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take_column</span><span class="p">(</span><span class="n">rectified_feedback</span><span class="p">,</span> <span class="s1">&#39;timestamp_c2&#39;</span><span class="p">)</span>
        <span class="n">timestamp_s1</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take_column</span><span class="p">(</span><span class="n">rectified_feedback</span><span class="p">,</span> <span class="s1">&#39;timestamp_s1&#39;</span><span class="p">)</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take_column</span><span class="p">(</span><span class="n">rectified_feedback</span><span class="p">,</span> <span class="s1">&#39;timestamp&#39;</span><span class="p">)</span>
        <span class="n">user_id</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take_column</span><span class="p">(</span><span class="n">rectified_feedback</span><span class="p">,</span> <span class="s1">&#39;user_id&#39;</span><span class="p">)</span>
        <span class="n">meta_decision</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take_column</span><span class="p">(</span><span class="n">rectified_feedback</span><span class="p">,</span> <span class="s1">&#39;meta_decision&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([])</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;evidence_decision&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decision</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;meta_decision&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_decision</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;aid1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aids1</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;aid2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aids2</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;tags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span> <span class="k">if</span> <span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">confidence</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;timestamp_c1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">timestamp_c1</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;timestamp_c2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">timestamp_c2</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;timestamp_s1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">timestamp_s1</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">timestamp</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;user_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;am_rowid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">am_rowids</span>
        <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;aid1&#39;</span><span class="p">,</span> <span class="s1">&#39;aid2&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">_feedback_df</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.core import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">            &gt;&gt;&gt; infr = testdata_infr(&#39;testdb1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; assert &#39;meta_decision&#39; in infr._feedback_df(&#39;annotmatch&#39;).columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;annotmatch&#39;</span><span class="p">:</span>
            <span class="n">feedback</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">read_wbia_annotmatch_feedback</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;staging&#39;</span><span class="p">:</span>
            <span class="n">feedback</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">read_wbia_staging_feedback</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">feedback</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">all_feedback</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
            <span class="n">feedback</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">internal_feedback</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_pandas_feedback_format</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;external&#39;</span><span class="p">:</span>
            <span class="n">feedback</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">external_feedback</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;key=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_pandas_feedback_format</span><span class="p">(</span><span class="n">feedback</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

<div class="viewcode-block" id="IBEISIO.match_state_delta"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISIO.match_state_delta">[docs]</a>    <span class="k">def</span> <span class="nf">match_state_delta</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="s1">&#39;annotmatch&#39;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns information about state change of annotmatches</span>

<span class="sd">        By default this will return a pandas dataframe indicating which edges</span>
<span class="sd">        in the annotmatch table have changed and all new edges relative to the</span>
<span class="sd">        current infr.graph state.</span>

<span class="sd">        Notes:</span>
<span class="sd">            valid values for `old` and `new` are {&#39;annotmatch&#39;, &#39;staging&#39;,</span>
<span class="sd">            &#39;all&#39;, &#39;internal&#39;, or &#39;external&#39;}.</span>

<span class="sd">            The args old/new=&#39;all&#39; resolves to the internal graph state,</span>
<span class="sd">            &#39;annotmatch&#39; resolves to the on-disk annotmatch table, and</span>
<span class="sd">            &#39;staging&#39; resolves to the on-disk staging table (you can further</span>
<span class="sd">            separate all by specifying &#39;internal&#39; or &#39;external&#39;).  You any of</span>
<span class="sd">            these old/new combinations to check differences in the state.</span>
<span class="sd">            However, the default values are what you use to sync the graph</span>
<span class="sd">            state to annotmatch.</span>

<span class="sd">        Args:</span>
<span class="sd">            old (str): indicates the old data (i.e. the place that will be</span>
<span class="sd">                written to)</span>
<span class="sd">            new (str): indicates the new data (i.e. the data to write)</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame - edge_delta_df - indicates the old and new values</span>
<span class="sd">                of the changed edge attributes.</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.core match_state_delta</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.mixin_wbia import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import wbia</span>
<span class="sd">            &gt;&gt;&gt; infr = wbia.AnnotInference(&#39;PZ_MTEST&#39;, aids=list(range(1, 10)),</span>
<span class="sd">            &gt;&gt;&gt;                             autoinit=&#39;annotmatch&#39;, verbose=4)</span>
<span class="sd">            &gt;&gt;&gt; # Split a PCC and then merge two other PCCs</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((1, 2), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((6, 7), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((5, 8), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((4, 5), POSTV)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((7, 8), POSTV)</span>
<span class="sd">            &gt;&gt;&gt; edge_delta_df = infr.match_state_delta()</span>
<span class="sd">            &gt;&gt;&gt; subset = edge_delta_df[[&#39;old_evidence_decision&#39;, &#39;new_evidence_decision&#39;]]</span>
<span class="sd">            &gt;&gt;&gt; result = str(subset)</span>
<span class="sd">            &gt;&gt;&gt; # if this doctest fails maybe PZ_MTEST has a non-determenistic reset?</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">                      old_evidence_decision new_evidence_decision</span>
<span class="sd">            aid1 aid2</span>
<span class="sd">            1    2                    match               nomatch</span>
<span class="sd">            5    8               unreviewed               nomatch</span>
<span class="sd">            6    7               unreviewed               nomatch</span>
<span class="sd">            7    8                    match                 match</span>
<span class="sd">            4    5                      NaN                 match</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_feedback</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_feedback_df</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new_feedback</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_feedback_df</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="n">edge_delta_df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_make_state_delta</span><span class="p">(</span><span class="n">old_feedback</span><span class="p">,</span> <span class="n">new_feedback</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edge_delta_df</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_make_state_delta</span><span class="p">(</span><span class="n">AnnotInference</span><span class="p">,</span> <span class="n">old_feedback</span><span class="p">,</span> <span class="n">new_feedback</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia.algo.graph.mixin_wbia IBEISIO._make_state_delta</span>
<span class="sd">            python -m wbia.algo.graph.mixin_wbia IBEISIO._make_state_delta:0</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.core import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">            &gt;&gt;&gt; columns = [&#39;evidence_decision&#39;, &#39;aid1&#39;, &#39;aid2&#39;, &#39;am_rowid&#39;, &#39;tags&#39;]</span>
<span class="sd">            &gt;&gt;&gt; new_feedback = old_feedback = pd.DataFrame([</span>
<span class="sd">            &gt;&gt;&gt; ], columns=columns).set_index([&#39;aid1&#39;, &#39;aid2&#39;], drop=True)</span>
<span class="sd">            &gt;&gt;&gt; edge_delta_df = AnnotInference._make_state_delta(old_feedback,</span>
<span class="sd">            &gt;&gt;&gt;                                                  new_feedback)</span>
<span class="sd">            &gt;&gt;&gt; result = (&#39;edge_delta_df =\n%s&#39; % (edge_delta_df,))</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">            edge_delta_df =</span>
<span class="sd">            Empty DataFrame</span>
<span class="sd">            Columns: [am_rowid, old_evidence_decision, new_evidence_decision, old_tags, new_tags, is_new]</span>
<span class="sd">            Index: []</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from wbia.algo.graph.core import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">            &gt;&gt;&gt; columns = [&#39;evidence_decision&#39;, &#39;meta_decision&#39;, &#39;aid1&#39;, &#39;aid2&#39;, &#39;am_rowid&#39;, &#39;tags&#39;]</span>
<span class="sd">            &gt;&gt;&gt; old_feedback = pd.DataFrame([</span>
<span class="sd">            &gt;&gt;&gt;     [NEGTV, &#39;diff&#39;, 100, 101, 1000, []],</span>
<span class="sd">            &gt;&gt;&gt;     [POSTV, &#39;same&#39;, 101, 102, 1001, []],</span>
<span class="sd">            &gt;&gt;&gt;     [POSTV, &#39;null&#39;, 103, 104, 1002, []],</span>
<span class="sd">            &gt;&gt;&gt;     [NEGTV, &#39;null&#39;, 101, 104, 1004, []],</span>
<span class="sd">            &gt;&gt;&gt; ], columns=columns).set_index([&#39;aid1&#39;, &#39;aid2&#39;], drop=True)</span>
<span class="sd">            &gt;&gt;&gt; new_feedback = pd.DataFrame([</span>
<span class="sd">            &gt;&gt;&gt;     [POSTV, &#39;null&#39;, 101, 102, 1001, []],</span>
<span class="sd">            &gt;&gt;&gt;     [NEGTV, &#39;null&#39;, 103, 104, 1002, []],</span>
<span class="sd">            &gt;&gt;&gt;     [POSTV, &#39;null&#39;, 101, 104, 1004, []],</span>
<span class="sd">            &gt;&gt;&gt;     [NEGTV, &#39;null&#39;, 102, 103, None, []],</span>
<span class="sd">            &gt;&gt;&gt;     [NEGTV, &#39;null&#39;, 100, 103, None, []],</span>
<span class="sd">            &gt;&gt;&gt;     [INCMP, &#39;same&#39;, 107, 109, None, []],</span>
<span class="sd">            &gt;&gt;&gt; ], columns=columns).set_index([&#39;aid1&#39;, &#39;aid2&#39;], drop=True)</span>
<span class="sd">            &gt;&gt;&gt; edge_delta_df = AnnotInference._make_state_delta(old_feedback,</span>
<span class="sd">            &gt;&gt;&gt;                                                  new_feedback)</span>
<span class="sd">            &gt;&gt;&gt; result = (&#39;edge_delta_df =\n%s&#39; % (edge_delta_df,))</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">                       am_rowid old_decision new_decision old_tags new_tags is_new</span>
<span class="sd">            aid1 aid2</span>
<span class="sd">            101  104     1004.0      nomatch        match       []       []  False</span>
<span class="sd">            103  104     1002.0        match      nomatch       []       []  False</span>
<span class="sd">            100  103        NaN          NaN      nomatch      NaN       []   True</span>
<span class="sd">            102  103        NaN          NaN      nomatch      NaN       []   True</span>
<span class="sd">            107  109        NaN          NaN      notcomp      NaN       []   True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">wbia</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="n">reduce</span>
        <span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">op</span>

        <span class="c1"># Ensure input is in the expected format</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">new_feedback</span><span class="o">.</span><span class="n">index</span>
        <span class="n">old_index</span> <span class="o">=</span> <span class="n">old_feedback</span><span class="o">.</span><span class="n">index</span>
        <span class="k">assert</span> <span class="n">new_index</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;aid1&#39;</span><span class="p">,</span> <span class="s1">&#39;aid2&#39;</span><span class="p">],</span> <span class="s1">&#39;not indexed on edges&#39;</span>
        <span class="k">assert</span> <span class="n">old_index</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;aid1&#39;</span><span class="p">,</span> <span class="s1">&#39;aid2&#39;</span><span class="p">],</span> <span class="s1">&#39;not indexed on edges&#39;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">u</span> <span class="o">&lt;</span> <span class="n">v</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_index</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="s1">&#39;bad direction&#39;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">u</span> <span class="o">&lt;</span> <span class="n">v</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">old_index</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="s1">&#39;bad direction&#39;</span>
        <span class="c1"># Determine what edges have changed</span>
        <span class="n">isect_edges</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">old_index</span><span class="p">)</span>
        <span class="n">isect_new</span> <span class="o">=</span> <span class="n">new_feedback</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">isect_edges</span><span class="p">]</span>
        <span class="n">isect_old</span> <span class="o">=</span> <span class="n">old_feedback</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">isect_edges</span><span class="p">]</span>

        <span class="c1"># If any important column is different we mark the row as changed</span>
        <span class="n">data_columns</span> <span class="o">=</span> <span class="n">wbia</span><span class="o">.</span><span class="n">AnnotInference</span><span class="o">.</span><span class="n">feedback_data_keys</span>
        <span class="n">important_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;meta_decision&#39;</span><span class="p">,</span> <span class="s1">&#39;evidence_decision&#39;</span><span class="p">,</span> <span class="s1">&#39;tags&#39;</span><span class="p">]</span>
        <span class="n">other_columns</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">setdiff</span><span class="p">(</span><span class="n">data_columns</span><span class="p">,</span> <span class="n">important_columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">changed_gen</span> <span class="o">=</span> <span class="p">[</span><span class="n">isect_new</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">isect_old</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">important_columns</span><span class="p">]</span>
            <span class="n">is_changed</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">changed_gen</span><span class="p">)</span>
            <span class="n">new_df_</span> <span class="o">=</span> <span class="n">isect_new</span><span class="p">[</span><span class="n">is_changed</span><span class="p">]</span>
            <span class="n">old_df</span> <span class="o">=</span> <span class="n">isect_old</span><span class="p">[</span><span class="n">is_changed</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_df_</span> <span class="o">=</span> <span class="n">isect_new</span>
            <span class="n">old_df</span> <span class="o">=</span> <span class="n">isect_old</span>
        <span class="c1"># Determine what edges have been added</span>
        <span class="n">add_edges</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">old_index</span><span class="p">)</span>
        <span class="n">add_df</span> <span class="o">=</span> <span class="n">new_feedback</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">add_edges</span><span class="p">]</span>
        <span class="c1"># Concat the changed and added edges</span>
        <span class="n">new_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">new_df_</span><span class="p">,</span> <span class="n">add_df</span><span class="p">])</span>
        <span class="c1"># Prepare the data frames for merging</span>
        <span class="n">old_colmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="s1">&#39;old_&#39;</span> <span class="o">+</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">data_columns</span><span class="p">}</span>
        <span class="n">new_colmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="s1">&#39;new_&#39;</span> <span class="o">+</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">data_columns</span><span class="p">}</span>
        <span class="n">prep_old</span> <span class="o">=</span> <span class="n">old_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">old_colmap</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">prep_new</span> <span class="o">=</span> <span class="n">new_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_colmap</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="c1"># defer to new values for non-important columns</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">other_columns</span><span class="p">:</span>
            <span class="n">oldcol</span> <span class="o">=</span> <span class="s1">&#39;old_&#39;</span> <span class="o">+</span> <span class="n">col</span>
            <span class="k">if</span> <span class="n">oldcol</span> <span class="ow">in</span> <span class="n">prep_old</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">prep_old</span><span class="p">[</span><span class="n">oldcol</span><span class="p">]</span>
        <span class="c1"># Combine into a single delta data frame</span>
        <span class="n">merge_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;aid1&#39;</span><span class="p">,</span> <span class="s1">&#39;aid2&#39;</span><span class="p">,</span> <span class="s1">&#39;am_rowid&#39;</span><span class="p">]</span>
        <span class="n">merged_df</span> <span class="o">=</span> <span class="n">prep_old</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">prep_new</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="n">merge_keys</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="n">merge_keys</span>
        <span class="p">)</span>
        <span class="c1"># Reorder the columns</span>
        <span class="n">col_order</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;old_evidence_decision&#39;</span><span class="p">,</span>
            <span class="s1">&#39;new_evidence_decision&#39;</span><span class="p">,</span>
            <span class="s1">&#39;old_tags&#39;</span><span class="p">,</span>
            <span class="s1">&#39;new_tags&#39;</span><span class="p">,</span>
            <span class="s1">&#39;old_meta_decision&#39;</span><span class="p">,</span>
            <span class="s1">&#39;new_meta_decision&#39;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">edge_delta_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">setdiff</span><span class="p">(</span><span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">col_order</span><span class="p">)</span> <span class="o">+</span> <span class="n">col_order</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">edge_delta_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;aid1&#39;</span><span class="p">,</span> <span class="s1">&#39;aid2&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">edge_delta_df</span> <span class="o">=</span> <span class="n">edge_delta_df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">is_new</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">add_edges</span><span class="p">):</span>
            <span class="n">edge_delta_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">add_edges</span><span class="p">,</span> <span class="s1">&#39;is_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">edge_delta_df</span>

    <span class="k">def</span> <span class="nf">_debug_edge_gt</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="c1"># Look at annotmatch and staging table for this edge</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[</span><span class="n">edge</span><span class="p">])</span>
        <span class="n">review_ids</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_review_rowids_between</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

        <span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">max_rows</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">max_columns</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">160</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">float_format</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%.4f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>

        <span class="n">df_a</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;annotmatch&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">as_pandas</span><span class="p">(</span><span class="n">matches</span><span class="o">.</span><span class="n">_rowids</span><span class="p">)</span>
        <span class="n">df_s</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">staging</span><span class="p">[</span><span class="s1">&#39;reviews&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">as_pandas</span><span class="p">(</span><span class="n">review_ids</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;=====&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;AnnotMatch Raw&#39;</span><span class="p">)</span>
        <span class="n">df_a</span> <span class="o">=</span> <span class="n">df_a</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;annotmatch_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df_a</span><span class="o">.</span><span class="n">columns</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">df_s</span> <span class="o">=</span> <span class="n">df_s</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;annot_rowid1&#39;</span><span class="p">:</span> <span class="s1">&#39;aid1&#39;</span><span class="p">,</span>
                <span class="s1">&#39;annot_rowid2&#39;</span><span class="p">:</span> <span class="s1">&#39;aid2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;reviewer&#39;</span><span class="p">:</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
                <span class="s1">&#39;tag_text&#39;</span><span class="p">:</span> <span class="s1">&#39;tag&#39;</span><span class="p">,</span>
                <span class="s1">&#39;posixtime_modified&#39;</span><span class="p">:</span> <span class="s1">&#39;ts_s2&#39;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df_a</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;AnnotMatch Feedback&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">_pandas_feedback_format</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">read_wbia_staging_feedback</span><span class="p">([</span><span class="n">edge</span><span class="p">])))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Staging Raw&#39;</span><span class="p">)</span>
        <span class="n">df_s</span> <span class="o">=</span> <span class="n">df_s</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;review_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df_s</span><span class="o">.</span><span class="n">columns</span><span class="p">})</span>
        <span class="n">df_s</span> <span class="o">=</span> <span class="n">df_s</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;annot_1_rowid&#39;</span><span class="p">:</span> <span class="s1">&#39;aid1&#39;</span><span class="p">,</span>
                <span class="s1">&#39;annot_2_rowid&#39;</span><span class="p">:</span> <span class="s1">&#39;aid2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;user_identity&#39;</span><span class="p">:</span> <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
                <span class="s1">&#39;user_confidence&#39;</span><span class="p">:</span> <span class="s1">&#39;confidence&#39;</span><span class="p">,</span>
                <span class="s1">&#39;client_start_time_posix&#39;</span><span class="p">:</span> <span class="s1">&#39;ts_c1&#39;</span><span class="p">,</span>
                <span class="s1">&#39;client_end_time_posix&#39;</span><span class="p">:</span> <span class="s1">&#39;ts_c2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;server_end_time_posix&#39;</span><span class="p">:</span> <span class="s1">&#39;ts_s2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;server_start_time_posix&#39;</span><span class="p">:</span> <span class="s1">&#39;ts_s1&#39;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="n">df_s</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">pandas_reorder</span><span class="p">(</span>
            <span class="n">df_s</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="s1">&#39;rowid&#39;</span><span class="p">,</span>
                <span class="s1">&#39;aid1&#39;</span><span class="p">,</span>
                <span class="s1">&#39;aid2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;count&#39;</span><span class="p">,</span>
                <span class="s1">&#39;evidence_decision&#39;</span><span class="p">,</span>
                <span class="s1">&#39;meta_decision&#39;</span><span class="p">,</span>
                <span class="s1">&#39;tags&#39;</span><span class="p">,</span>
                <span class="s1">&#39;confidence&#39;</span><span class="p">,</span>
                <span class="s1">&#39;user_id&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ts_s1&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ts_c1&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ts_c2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ts_s2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;uuid&#39;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df_s</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Staging Feedback&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">_pandas_feedback_format</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">read_wbia_annotmatch_feedback</span><span class="p">([</span><span class="n">edge</span><span class="p">])))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;____&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="IBEISGroundtruth"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISGroundtruth">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">ReloadingMetaclass</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">IBEISGroundtruth</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Methods for generating training labels for classifiers</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IBEISGroundtruth.wbia_guess_if_comparable"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISGroundtruth.wbia_guess_if_comparable">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">wbia_guess_if_comparable</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">aid_pairs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a guess as to which annots are not comparable based on scores and</span>
<span class="sd">        viewpoints. If either viewpoints is null assume they are comparable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aid_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aid_pairs</span><span class="p">)</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>

        <span class="n">dists</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_annotedge_viewdist</span><span class="p">(</span><span class="n">aid_pairs</span><span class="p">)</span>

        <span class="n">comp_by_viewpoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">dists</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>

        <span class="n">is_comp_guess</span> <span class="o">=</span> <span class="n">comp_by_viewpoint</span>
        <span class="k">return</span> <span class="n">is_comp_guess</span></div>

<div class="viewcode-block" id="IBEISGroundtruth.wbia_is_comparable"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISGroundtruth.wbia_is_comparable">[docs]</a>    <span class="k">def</span> <span class="nf">wbia_is_comparable</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">aid_pairs</span><span class="p">,</span> <span class="n">allow_guess</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Guesses by default when real comparable information is not available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="k">if</span> <span class="n">allow_guess</span><span class="p">:</span>
            <span class="c1"># Guess if comparability information is unavailable</span>
            <span class="n">is_comp_guess</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">wbia_guess_if_comparable</span><span class="p">(</span><span class="n">aid_pairs</span><span class="p">)</span>
            <span class="n">is_comp</span> <span class="o">=</span> <span class="n">is_comp_guess</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aid_pairs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1"># But use information that we have</span>
        <span class="n">am_rowids</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_annotmatch_rowid_from_edges</span><span class="p">(</span><span class="n">aid_pairs</span><span class="p">)</span>
        <span class="n">truths</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">replace_nones</span><span class="p">(</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annotmatch_evidence_decision</span><span class="p">(</span><span class="n">am_rowids</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">truths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">truths</span><span class="p">)</span>
        <span class="n">is_notcomp_have</span> <span class="o">=</span> <span class="n">truths</span> <span class="o">==</span> <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">EVIDENCE_DECISION</span><span class="o">.</span><span class="n">INCOMPARABLE</span>
        <span class="n">is_comp_have</span> <span class="o">=</span> <span class="p">(</span><span class="n">truths</span> <span class="o">==</span> <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">EVIDENCE_DECISION</span><span class="o">.</span><span class="n">POSITIVE</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span>
            <span class="n">truths</span> <span class="o">==</span> <span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">EVIDENCE_DECISION</span><span class="o">.</span><span class="n">NEGATIVE</span>
        <span class="p">)</span>
        <span class="n">is_comp</span><span class="p">[</span><span class="n">is_notcomp_have</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">is_comp</span><span class="p">[</span><span class="n">is_comp_have</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">is_comp</span></div>

<div class="viewcode-block" id="IBEISGroundtruth.wbia_is_photobomb"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISGroundtruth.wbia_is_photobomb">[docs]</a>    <span class="k">def</span> <span class="nf">wbia_is_photobomb</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">aid_pairs</span><span class="p">):</span>
        <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
        <span class="n">am_rowids</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_annotmatch_rowid_from_edges</span><span class="p">(</span><span class="n">aid_pairs</span><span class="p">)</span>
        <span class="n">am_tags</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_annotmatch_case_tags</span><span class="p">(</span><span class="n">am_rowids</span><span class="p">)</span>
        <span class="n">is_pb</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">filterflags_general_tags</span><span class="p">(</span><span class="n">am_tags</span><span class="p">,</span> <span class="n">has_any</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;photobomb&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">is_pb</span></div>

<div class="viewcode-block" id="IBEISGroundtruth.wbia_is_same"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.IBEISGroundtruth.wbia_is_same">[docs]</a>    <span class="k">def</span> <span class="nf">wbia_is_same</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">aid_pairs</span><span class="p">):</span>
        <span class="n">aids1</span><span class="p">,</span> <span class="n">aids2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aid_pairs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">nids1</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_nids</span><span class="p">(</span><span class="n">aids1</span><span class="p">)</span>
        <span class="n">nids2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_nids</span><span class="p">(</span><span class="n">aids2</span><span class="p">)</span>
        <span class="n">is_same</span> <span class="o">=</span> <span class="n">nids1</span> <span class="o">==</span> <span class="n">nids2</span>
        <span class="k">return</span> <span class="n">is_same</span></div></div>


<span class="c1"># VVVVV Non-complete non-general functions  VVVV</span>


<span class="k">def</span> <span class="nf">_update_staging_to_annotmatch</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BE VERY CAREFUL WITH THIS FUNCTION</span>

<span class="sd">    &gt;&gt;&gt; import wbia</span>
<span class="sd">    &gt;&gt;&gt; ibs = wbia.opendb(&#39;PZ_Master1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; infr = wbia.AnnotInference(ibs, aids=ibs.get_valid_aids())</span>

<span class="sd">    infr.reset_feedback(&#39;annotmatch&#39;, apply=True)</span>
<span class="sd">    infr.status()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finding entries in annotmatch that are missing in staging&#39;</span><span class="p">)</span>
    <span class="n">reverse_df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">match_state_delta</span><span class="p">(</span><span class="s1">&#39;annotmatch&#39;</span><span class="p">,</span> <span class="s1">&#39;staging&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reverse_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="s1">&#39;Cannot update staging because &#39;</span> <span class="s1">&#39;some staging items have not been commited.&#39;</span>
        <span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">match_state_delta</span><span class="p">(</span><span class="s1">&#39;staging&#39;</span><span class="p">,</span> <span class="s1">&#39;annotmatch&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s1">&#39;There are </span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1"> annotmatch items that do not exist in staging&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;is_new&#39;</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">repr4</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">wbia_edge_delta_info</span><span class="p">(</span><span class="n">df</span><span class="p">)))</span>

    <span class="c1"># Find places that exist in annotmatch but not in staging</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;old_evidence_decision&#39;</span><span class="p">])</span>
    <span class="n">missing_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">flags</span><span class="p">]</span>
    <span class="n">alias</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new_&#39;</span> <span class="o">+</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">feedback_data_keys</span><span class="p">}</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">missing_df</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">alias</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">alias</span><span class="p">)</span>
    <span class="n">missing_feedback</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tmp</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">feedback</span> <span class="o">=</span> <span class="n">missing_feedback</span>

    <span class="n">infr</span><span class="o">.</span><span class="n">_write_wbia_staging_feedback</span><span class="p">(</span><span class="n">feedback</span><span class="p">)</span>

    <span class="c1"># am_fb = infr.read_wbia_annotmatch_feedback()</span>
    <span class="c1"># staging_fb = infr.read_wbia_staging_feedback()</span>
    <span class="c1"># set(am_fb.keys()) - set(staging_fb.keys())</span>
    <span class="c1"># set(staging_fb.keys()) == set(am_fb.keys())</span>


<div class="viewcode-block" id="fix_annotmatch_to_undirected_upper"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.fix_annotmatch_to_undirected_upper">[docs]</a><span class="k">def</span> <span class="nf">fix_annotmatch_to_undirected_upper</span><span class="p">(</span><span class="n">ibs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enforce that all items in annotmatch are undirected upper</span>

<span class="sd">    import wbia</span>
<span class="sd">    # ibs = wbia.opendb(&#39;PZ_Master1&#39;)</span>
<span class="sd">    ibs = wbia.opendb(&#39;PZ_PB_RF_TRAIN&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">get_table_as_pandas</span><span class="p">(</span><span class="s1">&#39;annotmatch&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">,</span> <span class="s1">&#39;annot_rowid2&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># We want everything in upper triangular form</span>
    <span class="n">is_upper</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid2&#39;</span><span class="p">]</span>
    <span class="n">is_lower</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid2&#39;</span><span class="p">]</span>
    <span class="n">is_equal</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid2&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_equal</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">is_lower</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">is_upper</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

    <span class="n">upper_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">estarmap</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">e_</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">is_upper</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="n">lower_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">estarmap</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">e_</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">is_lower</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="n">both_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">isect</span><span class="p">(</span><span class="n">upper_edges</span><span class="p">,</span> <span class="n">lower_edges</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">both_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">both_upper</span> <span class="o">=</span> <span class="n">both_edges</span>
        <span class="n">both_lower</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">both_edges</span><span class="p">]</span>

        <span class="n">df1</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">both_upper</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">both_lower</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">df3</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;annotmatch_evidence_decision&#39;</span><span class="p">,</span>
            <span class="s1">&#39;annotmatch_meta_decision&#39;</span><span class="p">,</span>
            <span class="s1">&#39;annotmatch_confidence&#39;</span><span class="p">,</span>
            <span class="s1">&#39;annotmatch_tag_text&#39;</span><span class="p">,</span>
            <span class="s1">&#39;annotmatch_posixtime_modified&#39;</span><span class="p">,</span>
            <span class="s1">&#39;annotmatch_reviewer&#39;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">ed_key</span> <span class="o">=</span> <span class="s1">&#39;annotmatch_evidence_decision&#39;</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df3</span><span class="p">[</span><span class="n">col</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">df3</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">annotmatch_posixtime_modified</span><span class="p">)),</span> <span class="s1">&#39;should not happen&#39;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">annotmatch_reviewer</span><span class="p">)),</span> <span class="s1">&#39;should not happen&#39;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">annotmatch_confidence</span><span class="p">)),</span> <span class="s1">&#39;should not happen&#39;</span>

        <span class="n">flags</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">df3</span><span class="p">[</span><span class="n">ed_key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">df2</span><span class="p">[</span><span class="n">ed_key</span><span class="p">])</span>
            <span class="o">&amp;</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df3</span><span class="p">[</span><span class="n">ed_key</span><span class="p">])</span>
            <span class="o">&amp;</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df2</span><span class="p">[</span><span class="n">ed_key</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">annotmatch_posixtime_modified</span><span class="p">)):</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;need to rectify&#39;</span>

        <span class="n">tags2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">annotmatch_tag_text</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">{</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="p">})</span>
        <span class="n">tags3</span> <span class="o">=</span> <span class="n">df3</span><span class="o">.</span><span class="n">annotmatch_tag_text</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">{</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="p">})</span>

        <span class="c1"># Merge the tags</span>
        <span class="n">df3</span><span class="p">[</span><span class="s1">&#39;annotmatch_tag_text&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">t2</span><span class="p">)))</span> <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tags3</span><span class="p">,</span> <span class="n">tags2</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="n">delete_df</span> <span class="o">=</span> <span class="n">df3</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df3</span><span class="p">[</span><span class="n">ed_key</span><span class="p">])]</span>

        <span class="n">df4</span> <span class="o">=</span> <span class="n">df3</span><span class="p">[</span><span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df3</span><span class="p">[</span><span class="n">ed_key</span><span class="p">])]</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_evidence_decision</span><span class="p">(</span>
            <span class="n">df4</span><span class="o">.</span><span class="n">annotmatch_rowid</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df4</span><span class="p">[</span><span class="n">ed_key</span><span class="p">]],</span>
        <span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_tag_text</span><span class="p">(</span>
            <span class="n">df4</span><span class="o">.</span><span class="n">annotmatch_rowid</span><span class="p">,</span> <span class="n">df4</span><span class="o">.</span><span class="n">annotmatch_tag_text</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_confidence</span><span class="p">(</span>
            <span class="n">df4</span><span class="o">.</span><span class="n">annotmatch_rowid</span><span class="p">,</span>
            <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df4</span><span class="o">.</span><span class="n">annotmatch_confidence</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_reviewer</span><span class="p">(</span>
            <span class="n">df4</span><span class="o">.</span><span class="n">annotmatch_rowid</span><span class="p">,</span>
            <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df4</span><span class="o">.</span><span class="n">annotmatch_reviewer</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">set_annotmatch_posixtime_modified</span><span class="p">(</span>
            <span class="n">df4</span><span class="o">.</span><span class="n">annotmatch_rowid</span><span class="p">,</span>
            <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df4</span><span class="o">.</span><span class="n">annotmatch_posixtime_modified</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">ibs</span><span class="o">.</span><span class="n">delete_annotmatch</span><span class="p">(</span><span class="n">delete_df</span><span class="o">.</span><span class="n">annotmatch_rowid</span><span class="p">)</span>

        <span class="c1"># forwards_edge4 = [nxu.e_(u, v) for u, v in df4[[&#39;annot_rowid1&#39;, &#39;annot_rowid2&#39;]].values.tolist()]</span>
        <span class="c1"># forwards_rowids4 = ibs.get_annotmatch_rowid_from_superkey(forwards_edge4)</span>
        <span class="n">backwards_edge4</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">nxu</span><span class="o">.</span><span class="n">e_</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">df4</span><span class="p">[[</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">,</span> <span class="s1">&#39;annot_rowid2&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="n">backwards_rowids4</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_annotmatch_rowid_from_superkey</span><span class="p">(</span><span class="n">backwards_edge4</span><span class="p">)</span>
        <span class="n">ibs</span><span class="o">.</span><span class="n">delete_annotmatch</span><span class="p">(</span><span class="n">backwards_rowids4</span><span class="p">)</span>

    <span class="c1"># -------------------------</span>

    <span class="c1"># NOW WE HAVE RECIFIED DUPLICATE PAIRS AND THERE IS ONLY ONE AID PAIR PER DB</span>
    <span class="c1"># SO WE CAN SAFELY FLIP EVERYTHING TO BE IN UPPER TRIANGULAR MODE</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">get_table_as_pandas</span><span class="p">(</span><span class="s1">&#39;annotmatch&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">,</span> <span class="s1">&#39;annot_rowid2&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># We want everything in upper triangular form</span>
    <span class="n">is_upper</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid2&#39;</span><span class="p">]</span>
    <span class="n">is_lower</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid2&#39;</span><span class="p">]</span>
    <span class="n">is_equal</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid2&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_equal</span><span class="p">)</span>

    <span class="n">bad_lower_edges</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">is_lower</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">upper_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">estarmap</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">e_</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">is_upper</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="n">fix_lower_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">estarmap</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">e_</span><span class="p">,</span> <span class="n">bad_lower_edges</span><span class="p">)</span>
    <span class="n">both_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">isect</span><span class="p">(</span><span class="n">upper_edges</span><span class="p">,</span> <span class="n">fix_lower_edges</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">both_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;should not have any both edges anymore&#39;</span>

    <span class="n">lower_rowids</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">get_annotmatch_rowid_from_superkey</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">bad_lower_edges</span><span class="p">)))</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lower_rowids</span><span class="p">)</span>

    <span class="c1"># Ensure all edges are upper triangular in the database</span>
    <span class="n">id_iter</span> <span class="o">=</span> <span class="n">lower_rowids</span>
    <span class="n">colnames</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">,</span> <span class="s1">&#39;annot_rowid2&#39;</span><span class="p">)</span>
    <span class="n">ibs</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;annotmatch&#39;</span><span class="p">,</span> <span class="n">colnames</span><span class="p">,</span> <span class="n">fix_lower_edges</span><span class="p">,</span> <span class="n">id_iter</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">get_table_as_pandas</span><span class="p">(</span><span class="s1">&#39;annotmatch&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">,</span> <span class="s1">&#39;annot_rowid2&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># We want everything in upper triangular form</span>
    <span class="n">is_lower</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid1&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;annot_rowid2&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">is_lower</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span></div>


<span class="k">def</span> <span class="nf">_is_staging_above_annotmatch</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    conversion step: make sure the staging db is ahead of match</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        _update_staging_to_annotmatch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ibs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">ibs</span>
    <span class="n">n_stage</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">staging</span><span class="o">.</span><span class="n">get_row_count</span><span class="p">(</span><span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">REVIEW_TABLE</span><span class="p">)</span>
    <span class="n">n_annotmatch</span> <span class="o">=</span> <span class="n">ibs</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">get_row_count</span><span class="p">(</span><span class="n">ibs</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">ANNOTMATCH_TABLE</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n_stage</span> <span class="o">&gt;=</span> <span class="n">n_annotmatch</span>
    <span class="c1"># stage_fb = infr.read_wbia_staging_feedback()</span>
    <span class="c1"># match_fb = infr.read_wbia_annotmatch_feedback()</span>
    <span class="c1"># set(match_fb.keys()) - set(stage_fb.keys())</span>
    <span class="c1"># set(stage_fb.keys()) == set(match_fb.keys())</span>


<div class="viewcode-block" id="needs_conversion"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.mixin_wbia.needs_conversion">[docs]</a><span class="k">def</span> <span class="nf">needs_conversion</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
    <span class="c1"># not sure what the criteria is exactly. probably depricate</span>
    <span class="n">num_names</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">get_node_attrs</span><span class="p">(</span><span class="s1">&#39;name_label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">num_pccs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">number_of_components</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">num_pccs</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_names</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m wbia.algo.graph.mixin_wbia</span>
<span class="sd">        python -m wbia.algo.graph.mixin_wbia --allexamples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>

    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>  <span class="c1"># for win32</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>  <span class="c1"># NOQA</span>

    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

          </div>

        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">wbia</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../wbia.html">wbia - Wildbook IA</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../wbia.html">wbia</a><ul>
  <li><a href="../../algo.html">wbia.algo</a><ul>
  <li><a href="../graph.html">wbia.algo.graph</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Wild Me.

      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>

    </div>




  </body>
</html>
