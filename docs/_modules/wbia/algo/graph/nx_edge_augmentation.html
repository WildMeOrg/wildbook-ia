<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wbia.algo.graph.nx_edge_augmentation &mdash; wildbook-ia 4.0.1.dev11+dirty documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> wildbook-ia
          </a>
              <div class="version">
                4.0.1.dev11+dirty
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">wildbook-ia</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
          <li><a href="../../algo.html">wbia.algo</a> &raquo;</li>
          <li><a href="../graph.html">wbia.algo.graph</a> &raquo;</li>
      <li>wbia.algo.graph.nx_edge_augmentation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wbia.algo.graph.nx_edge_augmentation</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#    Copyright (C) 2004-2017 by</span>
<span class="c1">#    Aric Hagberg &lt;hagberg@lanl.gov&gt;</span>
<span class="c1">#    Dan Schult &lt;dschult@colgate.edu&gt;</span>
<span class="c1">#    Pieter Swart &lt;swart@lanl.gov&gt;</span>
<span class="c1">#    All rights reserved.</span>
<span class="c1">#    BSD license.</span>
<span class="c1">#</span>
<span class="c1"># Authors: Jon Crall (erotemic@gmail.com)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Algorithms for finding k-edge-augmentations</span>

<span class="sd">A k-edge-augmentation is a set of edges, that once added to a graph, ensures</span>
<span class="sd">that the graph is k-edge-connected. Typically, the goal is to find the</span>
<span class="sd">augmentation with minimum weight. In general, it is not gaurenteed that a</span>
<span class="sd">k-edge-augmentation exists.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="kn">import</span> <span class="n">not_implemented_for</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">namedtuple</span>

<span class="c1"># Patch</span>
<span class="kn">from</span> <span class="nn">wbia.algo.graph</span> <span class="kn">import</span> <span class="n">nx_edge_kcomponents</span> <span class="k">as</span> <span class="n">nx_ec</span>  <span class="c1"># NOQA</span>
<span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

<span class="nb">print</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">inject2</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;wbia&#39;</span><span class="p">)</span>

<span class="c1"># __all__ = [</span>
<span class="c1">#     &#39;k_edge_augmentation&#39;,</span>
<span class="c1">#     &#39;is_k_edge_connected&#39;,</span>
<span class="c1">#     &#39;is_locally_k_edge_connected&#39;,</span>
<span class="c1"># ]</span>


<div class="viewcode-block" id="is_k_edge_connected"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.is_k_edge_connected">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;directed&#39;</span><span class="p">)</span>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;multigraph&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_k_edge_connected</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests to see if a graph is k-edge-connected</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    is_locally_k_edge_connected</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.barbell_graph(10, 0)</span>
<span class="sd">    &gt;&gt;&gt; is_k_edge_connected(G, k=1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_k_edge_connected(G, k=2)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;k must be positive, not </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
    <span class="c1"># First try to quickly determine if G is not k-edge-connected</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise perform the full check</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">has_bridges</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># return nx.edge_connectivity(G, cutoff=k) &gt;= k</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span></div>


<div class="viewcode-block" id="is_locally_k_edge_connected"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.is_locally_k_edge_connected">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;directed&#39;</span><span class="p">)</span>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;multigraph&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_locally_k_edge_connected</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests to see if an edge in a graph is locally k-edge-connected</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    is_k_edge_connected</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.barbell_graph(10, 0)</span>
<span class="sd">    &gt;&gt;&gt; is_locally_k_edge_connected(G, 5, 15, k=1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_locally_k_edge_connected(G, 5, 15, k=2)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_locally_k_edge_connected(G, 1, 5, k=2)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;k must be positive, not </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

    <span class="c1"># First try to quickly determine s, t is not k-locally-edge-connected in G</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise perform the full check</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">has_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">localk</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">local_edge_connectivity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">localk</span> <span class="o">&gt;=</span> <span class="n">k</span></div>


<div class="viewcode-block" id="k_edge_augmentation"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.k_edge_augmentation">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;directed&#39;</span><span class="p">)</span>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;multigraph&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">k_edge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds set of edges to k-edge-connect G.</span>

<span class="sd">    This function uses the most efficient function available (depending on the</span>
<span class="sd">    value of k and if the problem is weighted or unweighted) to search for a</span>
<span class="sd">    minimum weight subset of available edges that k-edge-connects G.</span>
<span class="sd">    In general, finding a k-edge-augmentation is NP-hard, so solutions are not</span>
<span class="sd">    garuenteed to be minimal.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>

<span class="sd">    k : Integer</span>
<span class="sd">        Desired edge connectivity</span>

<span class="sd">    avail : dict or a set 2 or 3 tuples</span>
<span class="sd">        The available edges that can be used in the augmentation.</span>

<span class="sd">        If unspecified, then all edges in the complement of G are available.</span>
<span class="sd">        Otherwise, each item is an available edge (with an optinal weight).</span>

<span class="sd">        In the unweighted case, each item is an edge ``(u, v)``.</span>

<span class="sd">        In the weighted case, each item is a 3-tuple ``(u, v, d)`` or a dict</span>
<span class="sd">        with items ``(u, v): d``.  The third item, ``d``, can be a dictionary</span>
<span class="sd">        or a real number.  If ``d`` is a dictionary ``d[weight]``</span>
<span class="sd">        correspondings to the weight.</span>

<span class="sd">    weight : string</span>
<span class="sd">        key to use to find weights if avail is a set of 3-tuples where the</span>
<span class="sd">        third item in each tuple is a dictionary.</span>

<span class="sd">    partial : Boolean</span>
<span class="sd">        If partial is True and no feasible k-edge-augmentation exists, then all</span>
<span class="sd">        available edges are returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    aug_edges : a generator of edges. If these edges are added to G, then</span>
<span class="sd">        the G would become k-edge-connected. If partial is False, an error</span>
<span class="sd">        is raised if this is not possible. Otherwise, all available edges</span>
<span class="sd">        are generated.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXNotImplemented:</span>
<span class="sd">        If the input graph is directed or a multigraph.</span>

<span class="sd">    ValueError:</span>
<span class="sd">        If k is less than 1</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When k=1 this returns an optimal solution.</span>

<span class="sd">    When k=2 and avail is None, this returns an optimal solution.</span>
<span class="sd">    Otherwise when k=2, this returns a 2-approximation of the optimal solution.</span>

<span class="sd">    For k&gt;3, this problem is NP-hard and this uses a randomized algorithm that</span>
<span class="sd">        produces a feasible solution, but provides no gaurentees on the</span>
<span class="sd">        solution weight.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; # Unweighted cases</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(5)</span>
<span class="sd">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=1))</span>
<span class="sd">    [(1, 5)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=2))</span>
<span class="sd">    [(1, 5), (5, 4)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=3))</span>
<span class="sd">    [(1, 4), (1, 5), (2, 5), (3, 5), (4, 5)]</span>
<span class="sd">    &gt;&gt;&gt; complement = list(k_edge_augmentation(G, k=5, partial=True))</span>
<span class="sd">    &gt;&gt;&gt; G.add_edges_from(complement)</span>
<span class="sd">    &gt;&gt;&gt; nx.edge_connectivity(G)</span>
<span class="sd">    4</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; # Weighted cases</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(5)</span>
<span class="sd">    &gt;&gt;&gt; # avail can be a tuple with a dict</span>
<span class="sd">    &gt;&gt;&gt; avail = [(1, 5, {&#39;weight&#39;: 11}), (2, 5, {&#39;weight&#39;: 10})]</span>
<span class="sd">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=1, avail=avail, weight=&#39;weight&#39;))</span>
<span class="sd">    [(2, 5)]</span>
<span class="sd">    &gt;&gt;&gt; # or avail can be a 3-tuple with a real number</span>
<span class="sd">    &gt;&gt;&gt; avail = [(1, 5, 11), (2, 5, 10), (4, 3, 1), (4, 5, 51)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=2, avail=avail))</span>
<span class="sd">    [(1, 5), (2, 5), (4, 5)]</span>
<span class="sd">    &gt;&gt;&gt; # or avail can be a dict</span>
<span class="sd">    &gt;&gt;&gt; avail = {(1, 5): 11, (2, 5): 10, (4, 3): 1, (4, 5): 51}</span>
<span class="sd">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=2, avail=avail))</span>
<span class="sd">    [(1, 5), (2, 5), (4, 5)]</span>
<span class="sd">    &gt;&gt;&gt; # If augmentation is infeasible, then all edges in avail are returned</span>
<span class="sd">    &gt;&gt;&gt; avail = {(1, 5): 11}</span>
<span class="sd">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=2, avail=avail, partial=True))</span>
<span class="sd">    [(1, 5)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;k must be a positive integer, not </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;impossible to </span><span class="si">{}</span><span class="s1"> connect in graph with less than </span><span class="si">{}</span><span class="s1"> &#39;</span> <span class="s1">&#39;nodes&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">avail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">avail</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_k_edge_connected</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">(</span><span class="s1">&#39;no available edges&#39;</span><span class="p">)</span>
            <span class="n">aug_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">aug_edges</span> <span class="o">=</span> <span class="n">one_edge_augmentation</span><span class="p">(</span>
                <span class="n">G</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="n">partial</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">aug_edges</span> <span class="o">=</span> <span class="n">bridge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># raise NotImplementedError(</span>
            <span class="c1">#    &#39;not implemented for k&gt;2. k={}&#39;.format(k))</span>
            <span class="n">aug_edges</span> <span class="o">=</span> <span class="n">greedy_k_edge_augmentation</span><span class="p">(</span>
                <span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
        <span class="c1"># Do eager evaulation so we can catch any exceptions</span>
        <span class="c1"># Before executing partial code.</span>
        <span class="k">yield from</span> <span class="nb">list</span><span class="p">(</span><span class="n">aug_edges</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">partial</span><span class="p">:</span>
            <span class="c1"># Return all available edges</span>
            <span class="k">if</span> <span class="n">avail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aug_edges</span> <span class="o">=</span> <span class="n">complement_edges</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If we cant k-edge-connect the entire graph, try to</span>
                <span class="c1"># k-edge-connect as much as possible</span>
                <span class="n">aug_edges</span> <span class="o">=</span> <span class="n">partial_k_edge_augmentation</span><span class="p">(</span>
                    <span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span>
                <span class="p">)</span>
            <span class="k">yield from</span> <span class="n">aug_edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span></div>


<div class="viewcode-block" id="partial_k_edge_augmentation"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.partial_k_edge_augmentation">[docs]</a><span class="k">def</span> <span class="nf">partial_k_edge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds augmentation that k-edge-connects as much of the graph as possible</span>

<span class="sd">    When a k-edge-augmentation is not possible, we can still try to find a</span>
<span class="sd">    small set of edges that partially k-edge-connects as much of the graph as</span>
<span class="sd">    possible.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Construct H that augments G with all edges in avail.</span>
<span class="sd">    Find the k-edge-subgraphs of H.</span>
<span class="sd">    For each k-edge-subgraph, if the number of nodes is more than k, then find</span>
<span class="sd">    the k-edge-augmentation of that graph and add it to the solution. Then add</span>
<span class="sd">    all edges in avail between k-edge subgraphs to the solution.</span>

<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(8)</span>
<span class="sd">    &gt;&gt;&gt; avail = [(1, 3), (1, 4), (1, 5), (2, 4), (2, 5), (3, 5), (1, 8)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(partial_k_edge_augmentation(G, k=2, avail=avail))</span>
<span class="sd">    [(1, 5), (1, 8)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_edges_between_disjoint</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">only1</span><span class="p">,</span> <span class="n">only2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;finds edges between disjoint nodes&quot;&quot;&quot;</span>
        <span class="n">only1_adj</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">only1</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">neighbs</span> <span class="ow">in</span> <span class="n">only1_adj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Find the neighbors of u in only1 that are also in only2</span>
            <span class="n">neighbs12</span> <span class="o">=</span> <span class="n">neighbs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">only2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neighbs12</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="n">avail_uv</span><span class="p">,</span> <span class="n">avail_w</span> <span class="o">=</span> <span class="n">_unpack_available_edges</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">)</span>

    <span class="c1"># Find which parts of the graph can be k-edge-connected</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">H</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span>
        <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span> <span class="s1">&#39;generator&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="n">avail_w</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">k_edge_subgraphs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx_ec</span><span class="o">.</span><span class="n">k_edge_subgraphs</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">))</span>

    <span class="c1"># Generate edges to k-edge-connect internal components</span>
    <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">k_edge_subgraphs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Get the k-edge-connected subgraph</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Find the internal edges that were available</span>
            <span class="n">sub_avail</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">]:</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;generator&#39;</span> <span class="ow">in</span> <span class="n">d</span>
            <span class="p">}</span>
            <span class="c1"># Remove potential augmenting edges</span>
            <span class="n">C</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">sub_avail</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="c1"># Find a subset of these edges that makes the compoment</span>
            <span class="c1"># k-edge-connected and ignore the rest</span>
            <span class="k">yield from</span> <span class="n">k_edge_augmentation</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="n">sub_avail</span><span class="p">)</span>

    <span class="c1"># Generate all edges between CCs that could not be k-edge-connected</span>
    <span class="k">for</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">k_edge_subgraphs</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_edges_between_disjoint</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;generator&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">edge</span></div>


<div class="viewcode-block" id="one_edge_augmentation"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.one_edge_augmentation">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;multigraph&#39;</span><span class="p">)</span>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;directed&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">one_edge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds minimum weight set of edges to connect G.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Uses either :func:`unconstrained_one_edge_augmentation` or</span>
<span class="sd">    :func:`weighted_one_edge_augmentation` depending on whether ``avail`` is</span>
<span class="sd">    specified. Both algorithms are based on finding a minimum spanning tree.</span>
<span class="sd">    As such both algorithms find optimal solutions and run in linear time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">avail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unconstrained_one_edge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">weighted_one_edge_augmentation</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="n">partial</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="bridge_augmentation"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.bridge_augmentation">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;multigraph&#39;</span><span class="p">)</span>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;directed&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bridge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds the a set of edges that bridge connects G.</span>

<span class="sd">    Adding these edges to G will make it 2-edge-connected.</span>
<span class="sd">    If no constraints are specified the returned set of edges is minimum an</span>
<span class="sd">    optimal, otherwise the solution is approximated.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If there are no constraints the solution can be computed in linear time</span>
<span class="sd">    using :func:`unconstrained_bridge_augmentation`. Otherwise, the problem</span>
<span class="sd">    becomes NP-hard and is the solution is approximated by</span>
<span class="sd">    :func:`weighted_bridge_augmentation`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">(</span><span class="s1">&#39;impossible to bridge connect less than 3 nodes&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">avail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unconstrained_bridge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">weighted_bridge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>


<span class="c1"># --- Algorithms and Helpers ---</span>


<span class="k">def</span> <span class="nf">_ordered</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">v</span> <span class="k">else</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unpack_available_edges</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to separate avail into edges and corresponding weights&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;weight&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">avail_uv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">avail</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">avail_w</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">avail</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">_try_getitem</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">weight</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">d</span>

        <span class="n">avail_uv</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">avail</span><span class="p">]</span>
        <span class="n">avail_w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">_try_getitem</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">avail</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">G</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Edges already in the graph are filtered</span>
        <span class="c1"># flags = [(G.has_node(u) and G.has_node(v) and not G.has_edge(u, v))</span>
        <span class="c1">#          for u, v in avail_uv]</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">avail_uv</span><span class="p">]</span>
        <span class="n">avail_uv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">avail_uv</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
        <span class="n">avail_w</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">avail_w</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">avail_uv</span><span class="p">,</span> <span class="n">avail_w</span>


<span class="n">MetaEdge</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;MetaEdge&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;meta_uv&#39;</span><span class="p">,</span> <span class="s1">&#39;uv&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_lightest_meta_edges</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">avail_uv</span><span class="p">,</span> <span class="n">avail_w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Maps available edges in the original graph to edges in the metagraph</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mapping : dict</span>
<span class="sd">        mapping produced by :func:`collapse`, that maps each node in the</span>
<span class="sd">        original graph to a node in the meta graph</span>

<span class="sd">    avail_uv : list</span>
<span class="sd">        list of edges</span>

<span class="sd">    avail_w : list</span>
<span class="sd">        list of edge weights</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each node in the metagraph is a k-edge-cc in the original graph.  We dont</span>
<span class="sd">    care about any edge within the same k-edge-cc, so we ignore self edges.  We</span>
<span class="sd">    also are only intereseted in the minimum weight edge bridging each</span>
<span class="sd">    k-edge-cc so, we group the edges by meta-edge and take the lightest in each</span>
<span class="sd">    group.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; # Each group represents a meta-node</span>
<span class="sd">    &gt;&gt;&gt; groups = ([1, 2, 3], [4, 5], [6])</span>
<span class="sd">    &gt;&gt;&gt; mapping = {n: meta_n for meta_n, ns in enumerate(groups) for n in ns}</span>
<span class="sd">    &gt;&gt;&gt; avail_uv = [(1, 2), (3, 6), (1, 4), (5, 2), (6, 1), (2, 6), (3, 1)]</span>
<span class="sd">    &gt;&gt;&gt; avail_w =  [    20,     99,     20,     15,     50,     99,     20]</span>
<span class="sd">    &gt;&gt;&gt; sorted(_lightest_meta_edges(mapping, avail_uv, avail_w))</span>
<span class="sd">    [MetaEdge(meta_uv=(0, 1), uv=(5, 2), w=15), MetaEdge(meta_uv=(0, 2), uv=(6, 1), w=50)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grouped_wuv</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">avail_w</span><span class="p">,</span> <span class="n">avail_uv</span><span class="p">):</span>
        <span class="c1"># Order the meta-edge so it can be used as a dict key</span>
        <span class="n">meta_uv</span> <span class="o">=</span> <span class="n">_ordered</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">mapping</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="c1"># Group each available edge using the meta-edge as a key</span>
        <span class="n">grouped_wuv</span><span class="p">[</span><span class="n">meta_uv</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

    <span class="c1"># Now that all available edges are grouped, choose one per group</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">),</span> <span class="n">choices_wuv</span> <span class="ow">in</span> <span class="n">grouped_wuv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Ignore available edges within the same meta-node</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="o">!=</span> <span class="n">mv</span><span class="p">:</span>
            <span class="c1"># Choose the lightest available edge belonging to each meta-edge</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">choices_wuv</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">MetaEdge</span><span class="p">((</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span>


<div class="viewcode-block" id="unconstrained_one_edge_augmentation"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.unconstrained_one_edge_augmentation">[docs]</a><span class="k">def</span> <span class="nf">unconstrained_one_edge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds the smallest set of edges to connect G.</span>

<span class="sd">    This is a variant of the unweighted MST problem.</span>
<span class="sd">    If G is not empty, a feasible solution always exists.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.Graph([(1, 2), (2, 3), (4, 5)])</span>
<span class="sd">    &gt;&gt;&gt; G.add_nodes_from([6, 7, 8])</span>
<span class="sd">    &gt;&gt;&gt; sorted(unconstrained_one_edge_augmentation(G))</span>
<span class="sd">    [(1, 4), (4, 6), (6, 7), (7, 8)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ccs1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">collapse</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">ccs1</span><span class="p">)</span>
    <span class="c1"># When we are not constrained, we can just make a meta graph tree.</span>
    <span class="n">meta_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="c1"># build a path in the metagraph</span>
    <span class="n">meta_aug</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">meta_nodes</span><span class="p">,</span> <span class="n">meta_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="c1"># map that path to the original graph</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;mapping&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">inverse</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">meta_aug</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">inverse</span><span class="p">[</span><span class="n">mu</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">inverse</span><span class="p">[</span><span class="n">mv</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="weighted_one_edge_augmentation"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.weighted_one_edge_augmentation">[docs]</a><span class="k">def</span> <span class="nf">weighted_one_edge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds the minimum weight set of edges to connect G if one exists.</span>

<span class="sd">    This is a variant of the weighted MST problem.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.Graph([(1, 2), (2, 3), (4, 5)])</span>
<span class="sd">    &gt;&gt;&gt; G.add_nodes_from([6, 7, 8])</span>
<span class="sd">    &gt;&gt;&gt; # any edge not in avail has an implicit weight of infinity</span>
<span class="sd">    &gt;&gt;&gt; avail = [(1, 3), (1, 5), (4, 7), (4, 8), (6, 1), (8, 1), (8, 2)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(weighted_one_edge_augmentation(G, avail))</span>
<span class="sd">    [(1, 5), (4, 7), (6, 1), (8, 1)]</span>
<span class="sd">    &gt;&gt;&gt; # find another solution by giving large weights to edges in the</span>
<span class="sd">    &gt;&gt;&gt; # previous solution (note some of the old edges must be used)</span>
<span class="sd">    &gt;&gt;&gt; avail = [(1, 3), (1, 5, 99), (4, 7, 9), (6, 1, 99), (8, 1, 99), (8, 2)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(weighted_one_edge_augmentation(G, avail))</span>
<span class="sd">    [(1, 5), (4, 7), (6, 1), (8, 2)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avail_uv</span><span class="p">,</span> <span class="n">avail_w</span> <span class="o">=</span> <span class="n">_unpack_available_edges</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">)</span>
    <span class="c1"># Collapse CCs in the original graph into nodes in a metagraph</span>
    <span class="c1"># Then find an MST of the metagraph instead of the original graph</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">collapse</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;mapping&#39;</span><span class="p">]</span>
    <span class="c1"># Assign each available edge to an edge in the metagraph</span>
    <span class="n">candidate_mapping</span> <span class="o">=</span> <span class="n">_lightest_meta_edges</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">avail_uv</span><span class="p">,</span> <span class="n">avail_w</span><span class="p">)</span>
    <span class="c1"># nx.set_edge_attributes(C, name=&#39;weight&#39;, values=0)</span>
    <span class="n">C</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span>
        <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span> <span class="s1">&#39;generator&#39;</span><span class="p">:</span> <span class="n">uv</span><span class="p">})</span> <span class="k">for</span> <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">),</span> <span class="n">uv</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">candidate_mapping</span>
    <span class="p">)</span>
    <span class="c1"># Find MST of the meta graph</span>
    <span class="n">meta_mst</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">partial</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">meta_mst</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">(</span><span class="s1">&#39;Not possible to connect G with available edges&#39;</span><span class="p">)</span>
    <span class="c1"># Yield the edge that generated the meta-edge</span>
    <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">meta_mst</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;generator&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">edge</span></div>


<div class="viewcode-block" id="unconstrained_bridge_augmentation"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.unconstrained_bridge_augmentation">[docs]</a><span class="k">def</span> <span class="nf">unconstrained_bridge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds an optimal 2-edge-augmentation of G using the fewest edges.</span>

<span class="sd">    This is an implementation of the algorithm detailed in [1]_.</span>
<span class="sd">    The basic idea is to construct a meta-graph of bridge-ccs, connect leaf</span>
<span class="sd">    nodes of the trees to connect the entire graph, and finally connect the</span>
<span class="sd">    leafs of the tree in dfs-preorder to bridge connect the entire graph.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Input: a graph G.</span>
<span class="sd">    First find the bridge components of G and collapse each bridge-cc into a</span>
<span class="sd">    node of a metagraph graph C, which is gaurenteed to be a forest of trees.</span>

<span class="sd">    C contains p &quot;leafs&quot; --- nodes with exactly one incident edge.</span>
<span class="sd">    C contains q &quot;isolated nodes&quot; --- nodes with no incident edges.</span>

<span class="sd">    Theorem: If p + q &gt; 1, then at least :math:`ceil(p / 2) + q` edges are</span>
<span class="sd">        needed to bridge connect C. This algorithm achieves this min number.</span>

<span class="sd">    The method first adds enough edges to make G into a tree and then pairs</span>
<span class="sd">    leafs in a simple fashion.</span>

<span class="sd">    Let n be the number of trees in C. Let v(i) be an isolated vertex in the</span>
<span class="sd">    i-th tree if one exists, otherwise it is a pair of distinct leafs nodes</span>
<span class="sd">    in the i-th tree. Alternating edges from these sets (i.e.  adding edges</span>
<span class="sd">    A1 = [(v(i)[0], v(i + 1)[1]), v(i + 1)[0], v(i + 2)[1])...]) connects C</span>
<span class="sd">    into a tree T. This tree has p&#39; = p + 2q - 2(n -1) leafs and no isolated</span>
<span class="sd">    vertices. A1 has n - 1 edges. The next step finds ceil(p&#39; / 2) edges to</span>
<span class="sd">    biconnect any tree with p&#39; leafs.</span>

<span class="sd">    Convert T into an arborescence T&#39; by picking an arbitrary root node with</span>
<span class="sd">    degree &gt;= 2 and directing all edges away from the root. Note the</span>
<span class="sd">    implementation implicitly constructs T&#39;.</span>

<span class="sd">    The leafs of T are the nodes with no existing edges in T&#39;.</span>
<span class="sd">    Order the leafs of T&#39; by DFS prorder. Then break this list in half</span>
<span class="sd">    and add the zipped pairs to A2.</span>

<span class="sd">    The set A = A1 + A2 is the minimum augmentation in the metagraph.</span>

<span class="sd">    To convert this to edges in the original graph</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Eswaran, Kapali P., and R. Endre Tarjan. (1975) Augmentation problems.</span>
<span class="sd">        http://epubs.siam.org/doi/abs/10.1137/0205044</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))</span>
<span class="sd">    &gt;&gt;&gt; sorted(unconstrained_bridge_augmentation(G))</span>
<span class="sd">    [(1, 7)]</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 2, 4, 5, 6, 7))</span>
<span class="sd">    &gt;&gt;&gt; sorted(unconstrained_bridge_augmentation(G))</span>
<span class="sd">    [(1, 3), (3, 7)]</span>
<span class="sd">    &gt;&gt;&gt; G = nx.Graph([(0, 1), (0, 2), (1, 2)])</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(4)</span>
<span class="sd">    &gt;&gt;&gt; sorted(unconstrained_bridge_augmentation(G))</span>
<span class="sd">    [(1, 4), (4, 0)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># -----</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mapping of terms from (Eswaran and Tarjan):</span>
<span class="sd">        G = G_0 - the input graph</span>
<span class="sd">        C = G_0&#39; - the bridge condensation of G. (This is a forest of trees)</span>
<span class="sd">        A1 = A_1 - the edges to connect the forest into a tree</span>
<span class="sd">        leaf = pendant - a node with degree of 1</span>

<span class="sd">        alpha(v) = maps the node v in G to its meta-node in C</span>
<span class="sd">        beta(x) = maps the meta-node x in C to any node in the bridge component</span>
<span class="sd">            of G corresponding to x.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># find the 2-edge-connected components of G</span>
    <span class="n">bridge_ccs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">bridge_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="c1"># condense G into an forest C</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">collapse</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">bridge_ccs</span><span class="p">)</span>

    <span class="c1"># Choose pairs of distinct leaf nodes in each tree. If this is not</span>
    <span class="c1"># possible then make a pair using the single isolated node in the tree.</span>
    <span class="n">vset1</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">tuple</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># case1: an isolated node</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">else</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">degree</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># case2: pair of leaf nodes</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vset1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Use this set to construct edges that connect C into a tree.</span>
        <span class="n">nodes1</span> <span class="o">=</span> <span class="p">[</span><span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">vset1</span><span class="p">]</span>
        <span class="n">nodes2</span> <span class="o">=</span> <span class="p">[</span><span class="n">vs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">vset1</span><span class="p">]</span>
        <span class="n">A1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nodes1</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">nodes2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Connect each tree in the forest to construct an arborescence</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">T</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">A1</span><span class="p">)</span>

    <span class="c1"># If there are only two leaf nodes, we simply connect them.</span>
    <span class="n">leafs</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leafs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">A2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leafs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">A2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">leafs</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Choose an arbitrary non-leaf root</span>
        <span class="n">root</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># order the leaves of C by (induced directed) preorder</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">T</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># connecting first half of the leafs in pre-order to the second</span>
        <span class="c1"># half will bridge connect the tree with the fewest edges.</span>
        <span class="n">half</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">))</span>
        <span class="n">A2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">v2</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="o">-</span><span class="n">half</span><span class="p">:]))</span>

    <span class="c1"># collect the edges used to augment the original forest</span>
    <span class="n">aug_tree_edges</span> <span class="o">=</span> <span class="n">A1</span> <span class="o">+</span> <span class="n">A2</span>

    <span class="c1"># Construct the mapping (beta) from meta-nodes to regular nodes</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;mapping&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">inverse</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># sort so we choose minimum degree nodes first</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">mu</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">u</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mapped</span> <span class="ow">in</span> <span class="n">inverse</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1"># For each meta-edge, map back to an arbitrary pair in the original graph</span>
    <span class="n">G2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">aug_tree_edges</span><span class="p">:</span>
        <span class="c1"># Find the first available edge that doesn&#39;t exist and return it</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">inverse</span><span class="p">[</span><span class="n">mu</span><span class="p">],</span> <span class="n">inverse</span><span class="p">[</span><span class="n">mv</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">G2</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="n">G2</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span>
                <span class="k">break</span></div>


<div class="viewcode-block" id="weighted_bridge_augmentation"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.weighted_bridge_augmentation">[docs]</a><span class="k">def</span> <span class="nf">weighted_bridge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds an approximate min-weight 2-edge-augmentation of G.</span>

<span class="sd">    This is an implementation of the approximation algorithm detailed in [1]_.</span>
<span class="sd">    It chooses a set of edges from avail to add to G that renders it</span>
<span class="sd">    2-edge-connected if such a subset exists.  This is done by finding a</span>
<span class="sd">    minimum spanning arborescence of a specially constructed metagraph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>

<span class="sd">    avail : set of 2 or 3 tuples.</span>
<span class="sd">        candidate edges (with optional weights) to choose from</span>

<span class="sd">    weight : string</span>
<span class="sd">        key to use to find weights if avail is a set of 3-tuples where the</span>
<span class="sd">        third item in each tuple is a dictionary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    aug_edges (set): subset of avail chosen to augment G</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Finding a weighted 2-edge-augmentation is NP-hard.</span>
<span class="sd">    Any edge not in ``avail`` is considered to have a weight of infinity.</span>
<span class="sd">    The approximation factor is 2 if ``G`` is connected and 3 if it is not.</span>
<span class="sd">    Runs in :math:`O(m + n log(n))` time</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Khuller, Samir, and Ramakrishna Thurimella. (1993) Approximation</span>
<span class="sd">        algorithms for graph augmentation.</span>
<span class="sd">        http://www.sciencedirect.com/science/article/pii/S0196677483710102</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; # When the weights are equal, (1, 4) is the best</span>
<span class="sd">    &gt;&gt;&gt; avail = [(1, 4, 1), (1, 3, 1), (2, 4, 1)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(weighted_bridge_augmentation(G, avail))</span>
<span class="sd">    [(1, 4)]</span>
<span class="sd">    &gt;&gt;&gt; # Giving (1, 4) a high weight makes the two edge solution the best.</span>
<span class="sd">    &gt;&gt;&gt; avail = [(1, 4, 1000), (1, 3, 1), (2, 4, 1)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(weighted_bridge_augmentation(G, avail))</span>
<span class="sd">    [(1, 3), (2, 4)]</span>
<span class="sd">    &gt;&gt;&gt; #------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(5)</span>
<span class="sd">    &gt;&gt;&gt; avail = [(1, 5, 11), (2, 5, 10), (4, 3, 1), (4, 5, 1)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(weighted_bridge_augmentation(G, avail=avail))</span>
<span class="sd">    [(1, 5), (4, 5)]</span>
<span class="sd">    &gt;&gt;&gt; avail = [(1, 5, 11), (2, 5, 10), (4, 3, 1), (4, 5, 51)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(weighted_bridge_augmentation(G, avail=avail))</span>
<span class="sd">    [(1, 5), (2, 5), (4, 5)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;weight&#39;</span>

    <span class="c1"># If input G is not connected the approximation factor increases to 3</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">connectors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">one_edge_augmentation</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">))</span>
        <span class="n">H</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">connectors</span><span class="p">)</span>

        <span class="k">yield from</span> <span class="n">connectors</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connectors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">G</span>

    <span class="c1"># assert nx.is_connected(H), &#39;should have been one-connected&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">avail</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">has_bridges</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">(</span><span class="s1">&#39;no augmentation possible&#39;</span><span class="p">)</span>

    <span class="n">avail_uv</span><span class="p">,</span> <span class="n">avail_w</span> <span class="o">=</span> <span class="n">_unpack_available_edges</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>

    <span class="c1"># Collapse input into a metagraph. Meta nodes are bridge-ccs</span>
    <span class="n">bridge_ccs</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">bridge_components</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">collapse</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">bridge_ccs</span><span class="p">)</span>

    <span class="c1"># Use the meta graph to shrink avail to a small feasible subset</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;mapping&#39;</span><span class="p">]</span>
    <span class="c1"># Choose the minimum weight feasible edge in each group</span>
    <span class="n">meta_to_wuv</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">):</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">uv</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">),</span> <span class="n">uv</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">_lightest_meta_edges</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">avail_uv</span><span class="p">,</span> <span class="n">avail_w</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mapping of terms from (Khuller and Thurimella):</span>
<span class="sd">        C         : G_0 = (V, E^0)</span>
<span class="sd">           This is the metagraph where each node is a 2-edge-cc in G.</span>
<span class="sd">           The edges in C represent bridges in the original graph.</span>
<span class="sd">        (mu, mv)  : E - E^0  # they group both avail and given edges in E</span>
<span class="sd">        T         : \Gamma</span>
<span class="sd">        D         : G^D = (V, E_D)</span>

<span class="sd">        The paper uses ancestor because children point to parents, which is</span>
<span class="sd">        contrary to networkx standards.  So, we actually need to run</span>
<span class="sd">        nx.least_common_ancestor on the reversed Tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Pick an arbitrary leaf from C as the root</span>
    <span class="n">root</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Root C into a tree TR by directing all edges away from the root</span>
    <span class="c1"># Note in their paper T directs edges towards the root</span>
    <span class="n">TR</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dfs_tree</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>

    <span class="c1"># Add to D the directed edges of T and set their weight to zero</span>
    <span class="c1"># This indicates that it costs nothing to use edges that were given.</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">TR</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># The LCA of mu and mv in T is the shared ancestor of mu and mv that is</span>
    <span class="c1"># located farthest from the root.</span>
    <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">):</span>
        <span class="n">lca_gen</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">((</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">),</span> <span class="n">_lowest_common_anscestor</span><span class="p">(</span><span class="n">TR</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">root</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">meta_to_wuv</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lca_gen</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">tree_all_pairs_lowest_common_ancestor</span><span class="p">(</span>
            <span class="n">TR</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">pairs</span><span class="o">=</span><span class="n">meta_to_wuv</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">),</span> <span class="n">lca</span> <span class="ow">in</span> <span class="n">lca_gen</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">meta_to_wuv</span><span class="p">[(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">lca</span> <span class="o">==</span> <span class="n">mu</span><span class="p">:</span>
            <span class="c1"># If u is an ancestor of v in TR, then add edge u-&gt;v to D</span>
            <span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">lca</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="n">uv</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lca</span> <span class="o">==</span> <span class="n">mv</span><span class="p">:</span>
            <span class="c1"># If v is an ancestor of u in TR, then add edge v-&gt;u to D</span>
            <span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">lca</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="n">uv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If neither u nor v is a ancestor of the other in TR</span>
            <span class="c1"># let t = lca(TR, u, v) and add edges t-&gt;u and t-&gt;v</span>
            <span class="c1"># Track the original edge that GENERATED these edges.</span>
            <span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">lca</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="n">uv</span><span class="p">)</span>
            <span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">lca</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="n">uv</span><span class="p">)</span>

    <span class="c1"># Then compute a minimum rooted branching</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Note the original edges must be directed towards to root for the</span>
        <span class="c1"># branching to give us a bridge-augmentation.</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">_minimum_rooted_branching</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXException</span><span class="p">:</span>
        <span class="c1"># If there is no branching then augmentation is not possible</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">(</span><span class="s1">&#39;no 2-edge-augmentation possible&#39;</span><span class="p">)</span>

    <span class="c1"># For each edge e, in the branching that did not belong to the directed</span>
    <span class="c1"># tree T, add the correponding edge that **GENERATED** it (this is not</span>
    <span class="c1"># necesarilly e itself!)</span>

    <span class="c1"># ensure the third case does not generate edges twice</span>
    <span class="n">bridge_connectors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mv</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;generator&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="c1"># Add the avail edge that generated the branching edge.</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">]</span>
            <span class="n">bridge_connectors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="k">yield from</span> <span class="n">bridge_connectors</span></div>


<span class="k">def</span> <span class="nf">_minimum_rooted_branching</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes minimum rooted branching (aka rooted arborescence)</span>

<span class="sd">    Before the branching can be computed, the directed graph must be rooted by</span>
<span class="sd">    removing the predecessors of root.</span>

<span class="sd">    A branching / arborescence of rooted graph G is a subgraph that contains a</span>
<span class="sd">    directed path from the root to every other vertex. It is the directed</span>
<span class="sd">    analog of the minimum spanning tree problem.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Khuller, Samir (2002) Advanced Algorithms Lecture 24 Notes.</span>
<span class="sd">    https://www.cs.umd.edu/class/spring2011/cmsc651/lec07.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rooted</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># root the graph by removing all predecessors to `root`.</span>
    <span class="n">rooted</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">root</span><span class="p">)])</span>
    <span class="c1"># Then compute the branching / arborescence.</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_spanning_arborescence</span><span class="p">(</span><span class="n">rooted</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span>


<span class="k">def</span> <span class="nf">_lowest_common_anscestor</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="c1"># Find a least common anscestors</span>
    <span class="n">v_branch</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="n">v</span><span class="p">})</span>
    <span class="n">u_branch</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="n">u</span><span class="p">})</span>
    <span class="n">common</span> <span class="o">=</span> <span class="n">v_branch</span> <span class="o">&amp;</span> <span class="n">u_branch</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">common</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lca</span>


<div class="viewcode-block" id="collapse"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.collapse">[docs]</a><span class="k">def</span> <span class="nf">collapse</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">grouped_nodes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Collapses each group of nodes into a single node.</span>

<span class="sd">    This is similar to condensation, but works on undirected graphs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">       A directed graph.</span>

<span class="sd">    grouped_nodes:  list or generator</span>
<span class="sd">       Grouping of nodes to collapse. The grouping must be disjoint.</span>
<span class="sd">       If grouped_nodes are strongly_connected_components then this is</span>
<span class="sd">       equivalent to condensation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : NetworkX Graph</span>
<span class="sd">       The collapsed graph C of G with respect to the node grouping.  The node</span>
<span class="sd">       labels are integers corresponding to the index of the component in the</span>
<span class="sd">       list of strongly connected components of G.  C has a graph attribute</span>
<span class="sd">       named &#39;mapping&#39; with a dictionary mapping the original nodes to the</span>
<span class="sd">       nodes in C to which they belong.  Each node in C also has a node</span>
<span class="sd">       attribute &#39;members&#39; with the set of original nodes in G that form the</span>
<span class="sd">       group that the node in C represents.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Collapses a graph using disjoint groups, but not necesarilly connected</span>
<span class="sd">    &gt;&gt;&gt; G = nx.Graph([(1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 6), (5, 7)])</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(&#39;A&#39;)</span>
<span class="sd">    &gt;&gt;&gt; grouped_nodes = [{0, 1, 2, 3}, {5, 6, 7}]</span>
<span class="sd">    &gt;&gt;&gt; C = collapse(G, grouped_nodes)</span>
<span class="sd">    &gt;&gt;&gt; members = nx.get_node_attributes(C, &#39;members&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sorted(members.keys())</span>
<span class="sd">    [0, 1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; member_values = set(map(frozenset, members.values()))</span>
<span class="sd">    &gt;&gt;&gt; assert {0, 1, 2, 3} in member_values</span>
<span class="sd">    &gt;&gt;&gt; assert {4} in member_values</span>
<span class="sd">    &gt;&gt;&gt; assert {5, 6, 7} in member_values</span>
<span class="sd">    &gt;&gt;&gt; assert {&#39;A&#39;} in member_values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">members</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># required if G is empty</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grouped_nodes</span><span class="p">):</span>
        <span class="n">group</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">remaining</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span>
            <span class="n">group</span>
        <span class="p">),</span> <span class="s1">&#39;grouped nodes must exist in G and be disjoint&#39;</span>
        <span class="n">remaining</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">members</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="n">mapping</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">group</span><span class="p">)</span>
    <span class="c1"># remaining nodes are in their own group</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">group</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
        <span class="n">members</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="n">mapping</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">group</span><span class="p">)</span>
    <span class="n">number_of_groups</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">C</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">number_of_groups</span><span class="p">))</span>
    <span class="n">C</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span>
        <span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">mapping</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">mapping</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="c1"># Add a list of members (ie original nodes) to each node (ie scc) in C.</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;members&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">members</span><span class="p">)</span>
    <span class="c1"># Add mapping dict as graph attribute</span>
    <span class="n">C</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;mapping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span>
    <span class="k">return</span> <span class="n">C</span></div>


<div class="viewcode-block" id="complement_edges"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.complement_edges">[docs]</a><span class="k">def</span> <span class="nf">complement_edges</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns only the edges in the complement of G</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; sorted(complement_edges(G))</span>
<span class="sd">    [(1, 3), (1, 4), (2, 4)]</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4), nx.DiGraph())</span>
<span class="sd">    &gt;&gt;&gt; sorted(complement_edges(G))</span>
<span class="sd">    [(1, 3), (1, 4), (2, 1), (2, 4), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3)]</span>
<span class="sd">    &gt;&gt;&gt; G = nx.complete_graph(1000)</span>
<span class="sd">    &gt;&gt;&gt; sorted(complement_edges(G))</span>
<span class="sd">    []</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>


<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">compat_shuffle</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        python2 workaround so shuffle works the same as python3</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        https://stackoverflow.com/questions/38943038/diff-shuffle-py2-py3</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_randbelow</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return a random int in the range [0,n). Raises ValueError if n==0.&quot;&quot;&quot;</span>
            <span class="n">getrandbits</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">getrandbits</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>  <span class="c1"># don&#39;t use (n-1) here because n can be 1</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">getrandbits</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>  <span class="c1"># 0 &lt;= r &lt; 2**k</span>
            <span class="k">while</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">getrandbits</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># pick an element in input[:i+1] with which to exchange input[i]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">_randbelow</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">input</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>


<span class="k">else</span><span class="p">:</span>

<div class="viewcode-block" id="compat_shuffle"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.compat_shuffle">[docs]</a>    <span class="k">def</span> <span class="nf">compat_shuffle</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span></div>


<div class="viewcode-block" id="greedy_k_edge_augmentation"><a class="viewcode-back" href="../../../../wbia.algo.graph.html#wbia.algo.graph.nx_edge_augmentation.greedy_k_edge_augmentation">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;multigraph&#39;</span><span class="p">)</span>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;directed&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greedy_k_edge_augmentation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">avail</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Greedy algorithm for finding a k-edge-augmentation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm is simple. Edges are incrementally added between parts of the</span>
<span class="sd">    graph that are not yet locally k-edge-connected. Then edges are from the</span>
<span class="sd">    augmenting set are pruned as long as local-edge-connectivity is not broken.</span>

<span class="sd">    This algorithm is greedy and does not provide optimiality gaurentees. It</span>
<span class="sd">    exists only to provide :func:`k_edge_augmentation` with the ability to</span>
<span class="sd">    generate a feasible solution for arbitrary k.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))</span>
<span class="sd">    &gt;&gt;&gt; sorted(greedy_k_edge_augmentation(G, k=2))</span>
<span class="sd">    [(1, 7)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(greedy_k_edge_augmentation(G, k=1, avail=[]))</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))</span>
<span class="sd">    &gt;&gt;&gt; avail = {(u, v): 1 for (u, v) in complement_edges(G)}</span>
<span class="sd">    &gt;&gt;&gt; # randomized pruning process can produce different solutions</span>
<span class="sd">    &gt;&gt;&gt; sorted(greedy_k_edge_augmentation(G, k=4, avail=avail, seed=2))</span>
<span class="sd">    [(1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (2, 4), (2, 6), (3, 7), (5, 7)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(greedy_k_edge_augmentation(G, k=4, avail=avail, seed=3))</span>
<span class="sd">    [(1, 3), (1, 5), (1, 6), (2, 4), (2, 6), (3, 7), (4, 7), (5, 7)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Result set</span>
    <span class="n">aug_edges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">done</span> <span class="o">=</span> <span class="n">is_k_edge_connected</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">avail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># all edges are available</span>
        <span class="n">avail_uv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">complement_edges</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
        <span class="n">avail_w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">avail_uv</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Get the unique set of unweighted edges</span>
        <span class="n">avail_uv</span><span class="p">,</span> <span class="n">avail_w</span> <span class="o">=</span> <span class="n">_unpack_available_edges</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">)</span>

    <span class="c1"># Greedy: order lightest edges. Use degree sum to tie-break</span>
    <span class="n">tiebreaker</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">uv</span><span class="p">))</span> <span class="k">for</span> <span class="n">uv</span> <span class="ow">in</span> <span class="n">avail_uv</span><span class="p">]</span>
    <span class="n">avail_wduv</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">avail_w</span><span class="p">,</span> <span class="n">tiebreaker</span><span class="p">,</span> <span class="n">avail_uv</span><span class="p">))</span>
    <span class="n">avail_uv</span> <span class="o">=</span> <span class="p">[</span><span class="n">uv</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">uv</span> <span class="ow">in</span> <span class="n">avail_wduv</span><span class="p">]</span>
    <span class="c1"># avail_w = [w for w, uv in avail_wuv]</span>

    <span class="c1"># Incrementally add edges in until we are k-connected</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">avail_uv</span><span class="p">:</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_locally_k_edge_connected</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">):</span>
            <span class="c1"># Only add edges in parts that are not yet locally k-edge-connected</span>
            <span class="n">aug_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="c1"># Did adding this edge help?</span>
            <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">H</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="n">is_k_edge_connected</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># Check for feasibility</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">(</span><span class="s1">&#39;not able to k-edge-connect with available edges&#39;</span><span class="p">)</span>

    <span class="c1"># Randomized attempt to reduce the size of the solution</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="c1"># rng.shuffle(aug_edges)</span>
    <span class="n">compat_shuffle</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">aug_edges</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">aug_edges</span><span class="p">):</span>
        <span class="c1"># Dont remove if we know it would break connectivity</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="ow">or</span> <span class="n">H</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">H</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">aug_edges</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_k_edge_connected</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">):</span>
            <span class="c1"># If removing this edge breaks feasibility, undo</span>
            <span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">aug_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

    <span class="c1"># Generate results</span>
    <span class="k">yield from</span> <span class="n">aug_edges</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Wild Me.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>