

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ibeis.model.hots.automated_helpers &mdash; ibeis 0.1.0.dev1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="ibeis 0.1.0.dev1 documentation" href="../../../../index.html"/>
        <link rel="up" title="ibeis.model.hots" href="../hots.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../../index.html" class="fa fa-home"> ibeis</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ibeis.html">ibeis package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.all_imports">ibeis.all_imports module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.constants">ibeis.constants module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.ibsfuncs">ibeis.ibsfuncs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.main_module">ibeis.main_module module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.params">ibeis.params module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis">Module contents</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">ibeis</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../../../ibeis.html">ibeis</a> &raquo;</li>
      
          <li><a href="../../model.html">ibeis.model</a> &raquo;</li>
      
          <li><a href="../hots.html">ibeis.model.hots</a> &raquo;</li>
      
    <li>ibeis.model.hots.automated_helpers</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <h1>Source code for ibeis.model.hots.automated_helpers</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Idea:</span>
<span class="sd">    what about the probability of a descriptor match being a score like in SIFT.</span>
<span class="sd">    we can learn that too.</span>

<span class="sd">Have:</span>
<span class="sd">    * semantic and visual uuids</span>
<span class="sd">    * Test that accepts unknown annotations one at a time and</span>
<span class="sd">      for each runs query, makes decision about name, and executes decision.</span>
<span class="sd">    * As a placeholder for exemplar decisions  an exemplar is added if</span>
<span class="sd">      number of exemplars per name is less than threshold.</span>
<span class="sd">    * vs-one reranking query mode</span>
<span class="sd">    * test harness but start with larger test set</span>
<span class="sd">    * vs-one score normalizer ~~/ score normalizer for different values of K * / different params~~</span>
<span class="sd">      vs-many score normalization doesnt actually matter. We just need the ranking.</span>
<span class="sd">    * need to add in the multi-indexer code into the pipeline. Need to</span>
<span class="sd">      decide which subindexers to load given a set of daids</span>
<span class="sd">    * need to use set query as an exemplar if its vs-one reranking scores</span>
<span class="sd">      are below a threshold</span>
<span class="sd">    * flip the vsone ratio score so its &lt; .8 rather than &gt; 1.2 or whatever</span>
<span class="sd">    * start from nothing and let the system make the first few decisions correctly</span>
<span class="sd">    * tell me the correct answer in the automated test</span>
<span class="sd">    * turn on multi-indexing. (should just work..., probably bugs though. Just need to throw the switch)</span>
<span class="sd">    * paramater to only add exemplar if post-normlized score is above a threshold</span>
<span class="sd">    * ensure vsone ratio test is happening correctly</span>
<span class="sd">    * normalization gets a cfgstr based on the query</span>
<span class="sd">    * need to allow for scores to be un-invalidatd post spatial verification</span>
<span class="sd">      e.g. when the first match initially is invalidated through</span>
<span class="sd">      spatial verification but the next matches survive.</span>
<span class="sd">    * keep distinctiveness weights from vsmany for vsone weighting</span>
<span class="sd">      basically involves keeping weights from different filters and not</span>
<span class="sd">      aggregating match weights until the end.</span>
<span class="sd">    * Put test query mode into the main application and work on the interface for it.</span>
<span class="sd">    * add matches to multiple animals (merge)</span>
<span class="sd">    * update normalizer (have setup the datastructure to allow for it need to integrate it seemlessly)</span>
<span class="sd">    * score normalization update. on add the new support data, reapply bayes</span>
<span class="sd">     rule, and save to the current cache for a given algorithm configuration.</span>
<span class="sd">    * spawn background process to reindex chunks of data</span>


<span class="sd">TODO:</span>
<span class="sd">    * Improve vsone scoring.</span>
<span class="sd">    * test case where there is a 360 view that is linkable from the tests case</span>
<span class="sd">    * ~~Remember name_confidence of decisions for manual review~~ Defer</span>

<span class="sd">Tasks:</span>

<span class="sd">    Algorithm::</span>
<span class="sd">        * Incremental query needs to handle</span>
<span class="sd">            - test mode and live mode</span>
<span class="sd">            - normalizer update</span>
<span class="sd">            - use correct distinctivenes score in vsone</span>
<span class="sd">            - tested application of distinctiveness, foreground, ratio,</span>
<span class="sd">                spatial_verification, vsone verification, and score</span>
<span class="sd">                normalization.</span>

<span class="sd">        * Mathematically formal description of the space of choices</span>
<span class="sd">            - getting the proability of each choice will give us a much better</span>
<span class="sd">                confidence measure for our decision. An example of a probability</span>
<span class="sd">                partition might be .2 - merge with rank1.  .2 merge with rank 2, .5</span>
<span class="sd">                merge with rank1 and rank2, .1 others</span>

<span class="sd">        * Improved automated exemplar decision mechanism</span>

<span class="sd">        * Improved automated name decision mechanism</span>

<span class="sd">     SQL::</span>
<span class="sd">         * New Image Columns</span>
<span class="sd">             - image_posix_timedelta</span>

<span class="sd">         * New Name Columns</span>
<span class="sd">             - name_temp_flag</span>
<span class="sd">             - name_alias_text</span>

<span class="sd">             - name_uuid</span>
<span class="sd">             - name_visual_uuid</span>
<span class="sd">             - name_member_annot_rowids_evalstr</span>
<span class="sd">             - name_member_num_annot_rowids</span>

<span class="sd">         * New Encounter Columns</span>
<span class="sd">             - encounter_start_time</span>
<span class="sd">             - encounter_end_time</span>
<span class="sd">             - encounter_lat</span>
<span class="sd">             - encounter_lon</span>
<span class="sd">             - encounter_processed_flag</span>
<span class="sd">             - encounter_shipped_flag</span>

<span class="sd">    Decision UIs::</span>
<span class="sd">        * Query versus top N results</span>
<span class="sd">            - ability to draw an undirected edge between the query and any number of</span>
<span class="sd">                results. ie create a match any of the top results</span>
<span class="sd">            - a match to more than one results should by default merge the two names</span>
<span class="sd">                (this involves a name enhancement subtask). trigger a split / merge dialog</span>
<span class="sd">        * Is Exemplar</span>
<span class="sd">            - allows for user to set the exemplars for a given name</span>
<span class="sd">        * Name Progress</span>
<span class="sd">            - Shows the current name matching progress</span>
<span class="sd">        * Split</span>
<span class="sd">            - Allows a user to split off some images from a name into a new name</span>
<span class="sd">              or some other name.</span>
<span class="sd">        * Merge</span>
<span class="sd">            - Allows a user to join two names.</span>


<span class="sd">    GUI::</span>
<span class="sd">        * NameTree needs to not refresh unless absolutely necessary</span>
<span class="sd">        * Time Sync</span>
<span class="sd">        * Encounter metadata sync from the SMART</span>
<span class="sd">        * Hide shipped encounters</span>
<span class="sd">            - put flag to turn them on</span>
<span class="sd">        * Mark processed encounters</span>
<span class="sd">        * Gui naturally ensures that all annotations in the query belong</span>
<span class="sd">           to the same species</span>
<span class="sd">        * Garbage collection function that removes all non-exemplar</span>
<span class="sd">          information from encounters that have been shipped.</span>
<span class="sd">        * Spawn process that reindexes large chunks of descriptors as the</span>
<span class="sd">          database grows.</span>


<span class="sd">LONG TERM TASKS:</span>

<span class="sd">    Architecture:</span>
<span class="sd">        * Pipeline needs</span>
<span class="sd">            - DEFER: a move from dict based representation to list based</span>
<span class="sd">            - DEFER: spatial verification cyth speedup</span>
<span class="sd">            - DEFER: nearest neighbor (based on visual uuid caching) caching</span>

<span class="sd">    Controller:</span>
<span class="sd">         * LONGTERM: AutogenController</span>
<span class="sd">             - register data convertors for verts / other eval columns. Make</span>
<span class="sd">               several convertors standard and we can tag those columns to</span>
<span class="sd">               autogenerate their functions.</span>
<span class="sd">             - be able to mark a column as determined by the aggregate of other</span>
<span class="sd">               columns. Then the data is either generated on the fly, or it is</span>
<span class="sd">               cached and the necessary book-keeping functions are</span>
<span class="sd">               autogenerated.</span>

<span class="sd">    Decision UIs::</span>
<span class="sd">        * Is Exemplar</span>
<span class="sd">            - LONG TERM: it would be cool if they were visualized by using</span>
<span class="sd">              networkx or some gephi like program and clustered by match score.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">ibeis</span>
<span class="kn">import</span> <span class="nn">utool</span> <span class="kn">as</span> <span class="nn">ut</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">input</span>
<span class="k">print</span><span class="p">,</span> <span class="n">print_</span><span class="p">,</span> <span class="n">printDBG</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&#39;[inchelp]&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="assert_testdb_annot_consistency"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.automated_helpers.assert_testdb_annot_consistency">[docs]</a><span class="k">def</span> <span class="nf">assert_testdb_annot_consistency</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">aid_list2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    just tests uuids</span>

<span class="sd">    if anything goes wrong this should fix it:</span>
<span class="sd">        from ibeis import ibsfuncs</span>
<span class="sd">        aid_list1 = ibs_gt.get_valid_aids()</span>
<span class="sd">        ibs_gt.update_annot_visual_uuids(aid_list1)</span>
<span class="sd">        ibs2.update_annot_visual_uuids(aid_list2)</span>
<span class="sd">        ibsfuncs.fix_remove_visual_dupliate_annotations(ibs_gt)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">aid_list1</span><span class="p">)</span>
    <span class="n">visualtup1</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_visual_uuid_info</span><span class="p">(</span><span class="n">aid_list1</span><span class="p">)</span>
    <span class="n">visualtup2</span> <span class="o">=</span> <span class="n">ibs2</span><span class="o">.</span><span class="n">get_annot_visual_uuid_info</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">)</span>

    <span class="n">_visual_uuid_list1</span> <span class="o">=</span> <span class="p">[</span><span class="n">ut</span><span class="o">.</span><span class="n">augment_uuid</span><span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">)</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">visualtup1</span><span class="p">)]</span>
    <span class="n">_visual_uuid_list2</span> <span class="o">=</span> <span class="p">[</span><span class="n">ut</span><span class="o">.</span><span class="n">augment_uuid</span><span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">)</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">visualtup2</span><span class="p">)]</span>

    <span class="k">assert</span> <span class="n">ut</span><span class="o">.</span><span class="n">hashstr</span><span class="p">(</span><span class="n">visualtup1</span><span class="p">)</span> <span class="o">==</span> <span class="n">ut</span><span class="o">.</span><span class="n">hashstr</span><span class="p">(</span><span class="n">visualtup2</span><span class="p">)</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">assert_lists_eq</span><span class="p">(</span><span class="n">visualtup1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">visualtup2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">assert_lists_eq</span><span class="p">(</span><span class="n">visualtup1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">visualtup2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">assert_lists_eq</span><span class="p">(</span><span class="n">visualtup1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">visualtup2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c">#semantic_uuid_list1 = ibs_gt.get_annot_semantic_uuids(aid_list1)</span>
    <span class="c">#semantic_uuid_list2 = ibs2.get_annot_semantic_uuids(aid_list2)</span>

    <span class="n">visual_uuid_list1</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_visual_uuids</span><span class="p">(</span><span class="n">aid_list1</span><span class="p">)</span>
    <span class="n">visual_uuid_list2</span> <span class="o">=</span> <span class="n">ibs2</span><span class="o">.</span><span class="n">get_annot_visual_uuids</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">)</span>

    <span class="c"># make sure visual uuids are still determenistic</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">assert_lists_eq</span><span class="p">(</span><span class="n">visual_uuid_list1</span><span class="p">,</span> <span class="n">visual_uuid_list2</span><span class="p">)</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">assert_lists_eq</span><span class="p">(</span><span class="n">_visual_uuid_list1</span><span class="p">,</span> <span class="n">visual_uuid_list1</span><span class="p">)</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">assert_lists_eq</span><span class="p">(</span><span class="n">_visual_uuid_list2</span><span class="p">,</span> <span class="n">visual_uuid_list2</span><span class="p">)</span>

    <span class="n">ibs1_dup_annots</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">debug_duplicate_items</span><span class="p">(</span><span class="n">visual_uuid_list1</span><span class="p">)</span>
    <span class="n">ibs2_dup_annots</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">debug_duplicate_items</span><span class="p">(</span><span class="n">visual_uuid_list2</span><span class="p">)</span>

    <span class="c"># if these fail try ibsfuncs.fix_remove_visual_dupliate_annotations</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibs1_dup_annots</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibs2_dup_annots</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

</div>
<span class="nd">@profile</span>
<div class="viewcode-block" id="ensure_testdb_clean_data"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.automated_helpers.ensure_testdb_clean_data">[docs]</a><span class="k">def</span> <span class="nf">ensure_testdb_clean_data</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">aid_list2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    removes previously set names and exemplars</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Make sure that there are not any names in this database</span>
    <span class="n">nid_list2</span> <span class="o">=</span> <span class="n">ibs2</span><span class="o">.</span><span class="n">get_annot_name_rowids</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">,</span> <span class="n">distinguish_unknowns</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Removing names from the incremental test database&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ut</span><span class="o">.</span><span class="n">list_all_eq_to</span><span class="p">(</span><span class="n">nid_list2</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">ibs2</span><span class="o">.</span><span class="n">set_annot_name_rowids</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">,</span> <span class="p">[</span><span class="n">ibs2</span><span class="o">.</span><span class="n">UNKNOWN_NAME_ROWID</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">))</span>
    <span class="n">ibs2</span><span class="o">.</span><span class="n">delete_names</span><span class="p">(</span><span class="n">ibs2</span><span class="o">.</span><span class="n">_get_all_known_name_rowids</span><span class="p">())</span>

    <span class="c">#exemplarflag_list2 = ibs2.get_annot_exemplar_flags(aid_list2)</span>
    <span class="c">#if not ut.list_all_eq_to(exemplarflag_list2, 0):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Unsetting all exemplars from database&#39;</span><span class="p">)</span>
    <span class="n">ibs2</span><span class="o">.</span><span class="n">set_annot_exemplar_flags</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">,</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">))</span>

    <span class="c"># this test is for plains</span>
    <span class="c">#assert  ut.list_all_eq_to(ibs2.get_annot_species_texts(aid_list2), &#39;zebra_plains&#39;)</span>
    <span class="n">ibs2</span><span class="o">.</span><span class="n">delete_empty_nids</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="annot_testdb_consistency_checks"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.automated_helpers.annot_testdb_consistency_checks">[docs]</a><span class="k">def</span> <span class="nf">annot_testdb_consistency_checks</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">aid_list2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">assert_testdb_annot_consistency</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">aid_list2</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="c"># update and try again on failure</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">printex</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;warning: consistency check failed.&#39;</span>
                        <span class="s">&#39;updating and trying once more&#39;</span><span class="p">),</span> <span class="n">iswarning</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">ibs_gt</span><span class="o">.</span><span class="n">update_annot_visual_uuids</span><span class="p">(</span><span class="n">aid_list1</span><span class="p">)</span>
        <span class="n">ibs2</span><span class="o">.</span><span class="n">update_annot_visual_uuids</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">)</span>
        <span class="n">assert_testdb_annot_consistency</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">aid_list2</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="interactive_commandline_prompt"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.automated_helpers.interactive_commandline_prompt">[docs]</a><span class="k">def</span> <span class="nf">interactive_commandline_prompt</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">decisiontype</span><span class="p">):</span>
    <span class="n">prompt_fmtstr</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">codeblock</span><span class="p">(</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Accept system {decisiontype} decision?</span>
<span class="sd">        ==========</span>

<span class="sd">        {msg}</span>

<span class="sd">        ==========</span>
<span class="sd">        * press ENTER to ACCEPT</span>
<span class="sd">        * enter {no_phrase} to REJECT</span>
<span class="sd">        * enter {embed_phrase} to embed into ipython</span>
<span class="sd">        * any other inputs ACCEPT system decision</span>
<span class="sd">        * (input is case insensitive)</span>
<span class="sd">        &#39;&#39;&#39;</span>
    <span class="p">)</span>
    <span class="n">ans_list_embed</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;cmd&#39;</span><span class="p">,</span> <span class="s">&#39;ipy&#39;</span><span class="p">,</span> <span class="s">&#39;embed&#39;</span><span class="p">]</span>
    <span class="n">ans_list_no</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;no&#39;</span><span class="p">,</span> <span class="s">&#39;n&#39;</span><span class="p">]</span>
    <span class="c">#ans_list_yes = [&#39;yes&#39;, &#39;y&#39;]</span>
    <span class="n">prompt_str</span> <span class="o">=</span> <span class="n">prompt_fmtstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">no_phrase</span><span class="o">=</span><span class="n">ut</span><span class="o">.</span><span class="n">cond_phrase</span><span class="p">(</span><span class="n">ans_list_no</span><span class="p">),</span>
        <span class="n">embed_phrase</span><span class="o">=</span><span class="n">ut</span><span class="o">.</span><span class="n">cond_phrase</span><span class="p">(</span><span class="n">ans_list_embed</span><span class="p">),</span>
        <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">,</span>
        <span class="n">decisiontype</span><span class="o">=</span><span class="n">decisiontype</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">prompt_block</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">msgblock</span><span class="p">(</span><span class="s">&#39;USER_INPUT&#39;</span><span class="p">,</span> <span class="n">prompt_str</span><span class="p">)</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt_block</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ans</span> <span class="ow">in</span> <span class="n">ans_list_embed</span><span class="p">:</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">embed</span><span class="p">()</span>
        <span class="c">#print(ibs2.get_dbinfo_str())</span>
        <span class="c">#qreq_ = ut.search_stack_for_localvar(&#39;qreq_&#39;)</span>
        <span class="c">#qreq_.normalizer</span>
    <span class="k">elif</span> <span class="n">ans</span> <span class="ow">in</span> <span class="n">ans_list_no</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

</div>
<div class="viewcode-block" id="make_incremental_test_database"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.automated_helpers.make_incremental_test_database">[docs]</a><span class="k">def</span> <span class="nf">make_incremental_test_database</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">reset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes test database. adds image and annotations but does not transfer names.</span>
<span class="sd">    if reset is true the new database is gaurenteed to be built from a fresh</span>
<span class="sd">    start.</span>

<span class="sd">    Args:</span>
<span class="sd">        ibs_gt    (IBEISController):</span>
<span class="sd">        aid_list1 (list):</span>
<span class="sd">        reset     (bool): if True the test database is completely rebuilt</span>

<span class="sd">    Returns:</span>
<span class="sd">        IBEISController: ibs2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;make_incremental_test_database. reset=</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">reset</span><span class="p">,))</span>
    <span class="n">aids1_hashid</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">hashstr_arr</span><span class="p">(</span><span class="n">aid_list1</span><span class="p">)</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="s">&#39;_INCTEST_&#39;</span> <span class="o">+</span> <span class="n">aids1_hashid</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span>
    <span class="n">dbname2</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_dbname</span><span class="p">()</span>
    <span class="n">ibs2</span> <span class="o">=</span> <span class="n">ibeis</span><span class="o">.</span><span class="n">opendb</span><span class="p">(</span><span class="n">dbname2</span><span class="p">,</span> <span class="n">allow_newdir</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">delete_ibsdir</span><span class="o">=</span><span class="n">reset</span><span class="p">,</span> <span class="n">use_cache</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="c"># reset if flag specified or no data in ibs2</span>
    <span class="k">if</span> <span class="n">reset</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibs2</span><span class="o">.</span><span class="n">get_valid_gids</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibs2</span><span class="o">.</span><span class="n">get_valid_aids</span><span class="p">())</span>  <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibs2</span><span class="o">.</span><span class="n">get_valid_gids</span><span class="p">())</span>  <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibs2</span><span class="o">.</span><span class="n">get_valid_nids</span><span class="p">())</span>  <span class="o">==</span> <span class="mi">0</span>
        <span class="c"># Get annotations and their images from database 1</span>
        <span class="n">gid_list1</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_gids</span><span class="p">(</span><span class="n">aid_list1</span><span class="p">)</span>
        <span class="n">gpath_list1</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_image_paths</span><span class="p">(</span><span class="n">gid_list1</span><span class="p">)</span>
        <span class="c"># Add all images from database 1 to database 2</span>
        <span class="n">gid_list2</span> <span class="o">=</span> <span class="n">ibs2</span><span class="o">.</span><span class="n">add_images</span><span class="p">(</span><span class="n">gpath_list1</span><span class="p">,</span> <span class="n">auto_localize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="c"># Image UUIDS should be consistent between databases</span>
        <span class="n">image_uuid_list1</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_image_uuids</span><span class="p">(</span><span class="n">gid_list1</span><span class="p">)</span>
        <span class="n">image_uuid_list2</span> <span class="o">=</span> <span class="n">ibs2</span><span class="o">.</span><span class="n">get_image_uuids</span><span class="p">(</span><span class="n">gid_list2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">image_uuid_list1</span> <span class="o">==</span> <span class="n">image_uuid_list2</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">assert_lists_eq</span><span class="p">(</span><span class="n">image_uuid_list1</span><span class="p">,</span> <span class="n">image_uuid_list2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ibs2</span>

</div>
<span class="nd">@profile</span>
<div class="viewcode-block" id="setup_incremental_test"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.automated_helpers.setup_incremental_test">[docs]</a><span class="k">def</span> <span class="nf">setup_incremental_test</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">clear_names</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m ibeis.model.hots.automated_helpers --test-setup_incremental_test:0</span>

<span class="sd">        python dev.py -t custom --cfg codename:vsone_unnorm --db PZ_MTEST --allgt --vf --va</span>
<span class="sd">        python dev.py -t custom --cfg codename:vsone_unnorm --db PZ_MTEST --allgt --vf --va --index 0 4 8 --verbose</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.automated_helpers import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import ibeis # NOQA</span>
<span class="sd">        &gt;&gt;&gt; ibs_gt = ibeis.opendb(&#39;PZ_MTEST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs2, aid_list1, aid1_to_aid2 = setup_incremental_test(ibs_gt)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.automated_helpers import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import ibeis  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; ibs_gt = ibeis.opendb(&#39;GZ_ALL&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs2, aid_list1, aid1_to_aid2 = setup_incremental_test(ibs_gt)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">---- SETUP INCREMENTAL TEST ---</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="c"># Take a known dataase</span>
    <span class="c"># Create an empty database to test in</span>

    <span class="n">ONLY_GT</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="n">ONLY_GT</span><span class="p">:</span>
        <span class="c"># use only annotations that will have matches in test</span>
        <span class="n">aid_list1_</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_aids_with_groundtruth</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># use every annotation in test</span>
        <span class="n">aid_list1_</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_valid_aids</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">ut</span><span class="o">.</span><span class="n">get_argflag</span><span class="p">(</span><span class="s">&#39;--gzdev&#39;</span><span class="p">):</span>
        <span class="c"># Use a custom selection of gzall</span>
        <span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">devcases</span>
        <span class="k">assert</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_dbname</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;GZ_ALL&#39;</span><span class="p">,</span> <span class="s">&#39;not gzall&#39;</span>
        <span class="n">vuuid_list</span><span class="p">,</span> <span class="n">ignore_vuuids</span> <span class="o">=</span> <span class="n">devcases</span><span class="o">.</span><span class="n">get_gzall_small_test</span><span class="p">()</span>
        <span class="c"># TODO; include all names of these annots too</span>
        <span class="n">aid_list</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_aids_from_visual_uuid</span><span class="p">(</span><span class="n">vuuid_list</span><span class="p">)</span>
        <span class="n">ignore_aid_list</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_aids_from_visual_uuid</span><span class="p">(</span><span class="n">ignore_vuuids</span><span class="p">)</span>
        <span class="n">ignore_nid_list</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_nids</span><span class="p">(</span><span class="n">ignore_aid_list</span><span class="p">)</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">assert_all_not_None</span><span class="p">(</span><span class="n">aid_list</span><span class="p">)</span>
        <span class="n">other_aids</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_groundtruth</span><span class="p">(</span><span class="n">aid_list</span><span class="p">))</span>
        <span class="n">aid_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other_aids</span><span class="p">)</span>
        <span class="n">aid_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">aid_list</span><span class="p">))</span>
        <span class="n">nid_list</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_nids</span><span class="p">(</span><span class="n">aid_list</span><span class="p">)</span>
        <span class="n">isinvalid_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">nid</span> <span class="ow">in</span> <span class="n">ignore_nid_list</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">nid_list</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Filtering </span><span class="si">%r</span><span class="s"> annots specified to ignore&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">isinvalid_list</span><span class="p">),))</span>
        <span class="n">aid_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">filterfalse_items</span><span class="p">(</span><span class="n">aid_list</span><span class="p">,</span> <span class="n">isinvalid_list</span><span class="p">)</span>
        <span class="c">#ut.embed()</span>
        <span class="n">aid_list1_</span> <span class="o">=</span> <span class="n">aid_list</span>
        <span class="c">#ut.embed()</span>

    <span class="c"># Add aids in a random order</span>
    <span class="n">VALID_ORDERS</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;shuffle&#39;</span><span class="p">,</span> <span class="s">&#39;stagger&#39;</span><span class="p">,</span> <span class="s">&#39;same&#39;</span><span class="p">]</span>
    <span class="c">#AID_ORDER = &#39;shuffle&#39;</span>
    <span class="n">AID_ORDER</span> <span class="o">=</span> <span class="s">&#39;stagger&#39;</span>
    <span class="k">assert</span> <span class="n">VALID_ORDERS</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">AID_ORDER</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">AID_ORDER</span> <span class="o">==</span> <span class="s">&#39;shuffle&#39;</span><span class="p">:</span>
        <span class="n">aid_list1</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">deterministic_shuffle</span><span class="p">(</span><span class="n">aid_list1_</span><span class="p">[:])</span>
    <span class="k">elif</span> <span class="n">AID_ORDER</span> <span class="o">==</span> <span class="s">&#39;stagger&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="n">zip_longest</span><span class="p">,</span> <span class="nb">filter</span>
        <span class="n">aid_groups</span><span class="p">,</span> <span class="n">unique_nid_list</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">group_annots_by_name</span><span class="p">(</span><span class="n">aid_list1_</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">stagger_group</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ut</span><span class="o">.</span><span class="n">filter_Nones</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">iflatten</span><span class="p">(</span><span class="n">zip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">list_</span><span class="p">)))</span>
        <span class="n">aid_multiton_group</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">aids</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">aids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">aid_groups</span><span class="p">))</span>
        <span class="n">aid_list1</span> <span class="o">=</span> <span class="n">stagger_group</span><span class="p">(</span><span class="n">aid_multiton_group</span><span class="p">)</span>
        <span class="c">#aid_list1 = ibs_gt.get_annot_rowid_sample(per_name=10, aid_list=aid_list1_, stagger_names=True)</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">AID_ORDER</span> <span class="o">==</span> <span class="s">&#39;same&#39;</span><span class="p">:</span>
        <span class="n">aid_list1</span> <span class="o">=</span> <span class="n">aid_list1_</span>

    <span class="c"># If reset is true the test database is started completely from scratch</span>
    <span class="n">reset</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">get_argflag</span><span class="p">(</span><span class="s">&#39;--reset&#39;</span><span class="p">)</span>

    <span class="n">aid1_to_aid2</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># annotation mapping</span>

    <span class="n">ibs2</span> <span class="o">=</span> <span class="n">make_incremental_test_database</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span>

    <span class="c"># Preadd all annotatinos to the test database</span>
    <span class="n">aids_chunk1</span> <span class="o">=</span> <span class="n">aid_list1</span>
    <span class="n">aid_list2</span> <span class="o">=</span> <span class="n">add_annot_chunk</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aids_chunk1</span><span class="p">,</span> <span class="n">aid1_to_aid2</span><span class="p">)</span>

    <span class="c">#ut.embed()</span>
    <span class="c"># Assert annotation visual uuids are in agreement</span>
    <span class="k">if</span> <span class="n">ut</span><span class="o">.</span><span class="n">DEBUG2</span><span class="p">:</span>
        <span class="n">annot_testdb_consistency_checks</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">aid_list2</span><span class="p">)</span>

    <span class="c"># Remove names and exemplar information from test database</span>
    <span class="k">if</span> <span class="n">clear_names</span><span class="p">:</span>
        <span class="n">ensure_testdb_clean_data</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">aid_list2</span><span class="p">)</span>

    <span class="c"># Preprocess features before testing</span>
    <span class="n">ibs2</span><span class="o">.</span><span class="n">ensure_annotation_data</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">,</span> <span class="n">featweights</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aid_list1</span><span class="p">,</span> <span class="n">aid1_to_aid2</span>

</div>
<div class="viewcode-block" id="check_results"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.automated_helpers.check_results">[docs]</a><span class="k">def</span> <span class="nf">check_results</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aid1_to_aid2</span><span class="p">,</span> <span class="n">aids_list1_</span><span class="p">,</span> <span class="n">incinfo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reports how well the incremental query ran when the oracle was calling the</span>
<span class="sd">    shots.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;--------- CHECKING RESULTS ------------&#39;</span><span class="p">)</span>
    <span class="n">testcases</span> <span class="o">=</span> <span class="n">incinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;testcases&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">testcases</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">count_dict</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">count_dict_vals</span><span class="p">(</span><span class="n">testcases</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;+--&#39;</span><span class="p">)</span>
        <span class="c">#print(ut.dict_str(testcases))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;---&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">dict_str</span><span class="p">(</span><span class="n">count_dict</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;L__&#39;</span><span class="p">)</span>
    <span class="c"># TODO: dont include initially added aids in the result reporting</span>
    <span class="n">aid_list1</span> <span class="o">=</span> <span class="n">aids_list1_</span>  <span class="c"># ibs_gt.get_valid_aids()</span>
    <span class="c">#aid_list1 = ibs_gt.get_aids_with_groundtruth()</span>
    <span class="n">aid_list2</span> <span class="o">=</span> <span class="n">ibs2</span><span class="o">.</span><span class="n">get_valid_aids</span><span class="p">()</span>

    <span class="n">nid_list1</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_nids</span><span class="p">(</span><span class="n">aid_list1</span><span class="p">)</span>
    <span class="n">nid_list2</span> <span class="o">=</span> <span class="n">ibs2</span><span class="o">.</span><span class="n">get_annot_nids</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">)</span>

    <span class="c"># Group annotations from test and gt database by their respective names</span>
    <span class="n">grouped_dict1</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">group_items</span><span class="p">(</span><span class="n">aid_list1</span><span class="p">,</span> <span class="n">nid_list1</span><span class="p">)</span>
    <span class="n">grouped_dict2</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">group_items</span><span class="p">(</span><span class="n">aid_list2</span><span class="p">,</span> <span class="n">nid_list2</span><span class="p">)</span>
    <span class="n">grouped_aids1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">grouped_dict1</span><span class="p">))</span>
    <span class="n">grouped_aids2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">grouped_dict2</span><span class="p">)))</span>
    <span class="c">#group_nids1 = list(six.iterkeys(grouped_dict1))</span>
    <span class="c">#group_nids2 = list(six.iterkeys(grouped_dict2))</span>

    <span class="c"># Transform annotation ids from database1 space to database2 space</span>
    <span class="n">grouped_aids1_t</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">dict_take_list</span><span class="p">(</span><span class="n">aid1_to_aid2</span><span class="p">,</span> <span class="n">aids1</span><span class="p">))</span> <span class="k">for</span> <span class="n">aids1</span> <span class="ow">in</span> <span class="n">grouped_aids1</span><span class="p">]</span>

    <span class="n">set_grouped_aids1_t</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grouped_aids1_t</span><span class="p">)</span>
    <span class="n">set_grouped_aids2</span>   <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grouped_aids2</span><span class="p">)</span>

    <span class="c"># Find names we got right. (correct groupings of annotations)</span>
    <span class="c"># these are the annotation groups that are intersecting between</span>
    <span class="c"># the test database and groundtruth database</span>
    <span class="n">perfect_groups</span> <span class="o">=</span> <span class="n">set_grouped_aids2</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">set_grouped_aids1_t</span><span class="p">)</span>
    <span class="c"># Find names we got wrong. (incorrect groupings of annotations)</span>
    <span class="c"># The test database sets that were not perfect</span>
    <span class="n">nonperfect_groups</span> <span class="o">=</span> <span class="n">set_grouped_aids2</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">perfect_groups</span><span class="p">)</span>
    <span class="c"># What we should have got</span>
    <span class="c"># The ground truth database sets that were not fully identified</span>
    <span class="n">missed_groups</span> <span class="o">=</span> <span class="n">set_grouped_aids1_t</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">perfect_groups</span><span class="p">)</span>

    <span class="c"># Mark non perfect groups by their error type</span>
    <span class="n">false_negative_groups</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># failed to link enough</span>
    <span class="n">false_positive_groups</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># linked too much</span>
    <span class="k">for</span> <span class="n">nonperfect_group</span> <span class="ow">in</span> <span class="n">nonperfect_groups</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ut</span><span class="o">.</span><span class="n">is_subset_of_any</span><span class="p">(</span><span class="n">nonperfect_group</span><span class="p">,</span> <span class="n">missed_groups</span><span class="p">):</span>
            <span class="n">false_negative_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonperfect_group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">false_positive_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonperfect_group</span><span class="p">)</span>

    <span class="c"># Get some more info on the nonperfect groups</span>
    <span class="c"># find which groups should have been linked</span>
    <span class="n">aid2_to_aid1</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">invert_dict</span><span class="p">(</span><span class="n">aid1_to_aid2</span><span class="p">)</span>
    <span class="n">false_negative_groups_t</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">dict_take_list</span><span class="p">(</span><span class="n">aid2_to_aid1</span><span class="p">,</span> <span class="n">aids2</span><span class="p">))</span> <span class="k">for</span> <span class="n">aids2</span> <span class="ow">in</span> <span class="n">false_negative_groups</span><span class="p">]</span>
    <span class="n">false_negative_group_nids_t</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">unflat_map</span><span class="p">(</span><span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_nids</span><span class="p">,</span> <span class="n">false_negative_groups_t</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">list_allsame</span><span class="p">,</span> <span class="n">false_negative_group_nids_t</span><span class="p">)),</span> <span class="s">&#39;inconsistent nids&#39;</span>
    <span class="n">false_negative_group_nid_t</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">get_list_column</span><span class="p">(</span><span class="n">false_negative_group_nids_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c"># These are the links that should have been made</span>
    <span class="n">missed_links</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">group_items</span><span class="p">(</span><span class="n">false_negative_groups</span><span class="p">,</span> <span class="n">false_negative_group_nid_t</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">dict_str</span><span class="p">(</span><span class="n">missed_links</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s">&#39;# Name with failed links (FN) = </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_negative_groups</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;... should have reduced to </span><span class="si">%d</span><span class="s"> names.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missed_links</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;# Name with wrong links (FP)  = </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_positive_groups</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;# Name correct names (TP)     = </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">perfect_groups</span><span class="p">))</span>
    <span class="c">#ut.embed()</span>

</div>
<span class="nd">@profile</span>
<div class="viewcode-block" id="add_annot_chunk"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.automated_helpers.add_annot_chunk">[docs]</a><span class="k">def</span> <span class="nf">add_annot_chunk</span><span class="p">(</span><span class="n">ibs_gt</span><span class="p">,</span> <span class="n">ibs2</span><span class="p">,</span> <span class="n">aids_chunk1</span><span class="p">,</span> <span class="n">aid1_to_aid2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    adds annotations to the tempoarary database and prevents duplicate</span>
<span class="sd">    additions.</span>

<span class="sd">    aids_chunk1 = aid_list1</span>

<span class="sd">    Args:</span>
<span class="sd">        ibs_gt       (IBEISController):</span>
<span class="sd">        ibs2         (IBEISController):</span>
<span class="sd">        aids_chunk1  (list):</span>
<span class="sd">        aid1_to_aid2 (dict):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: aids_chunk2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Visual info</span>
    <span class="n">guuids_chunk1</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_image_uuids</span><span class="p">(</span><span class="n">aids_chunk1</span><span class="p">)</span>
    <span class="n">verts_chunk1</span>  <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_verts</span><span class="p">(</span><span class="n">aids_chunk1</span><span class="p">)</span>
    <span class="n">thetas_chunk1</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_thetas</span><span class="p">(</span><span class="n">aids_chunk1</span><span class="p">)</span>
    <span class="c"># Non-name semantic info</span>
    <span class="n">species_chunk1</span> <span class="o">=</span> <span class="n">ibs_gt</span><span class="o">.</span><span class="n">get_annot_species_texts</span><span class="p">(</span><span class="n">aids_chunk1</span><span class="p">)</span>
    <span class="n">gids_chunk2</span> <span class="o">=</span> <span class="n">ibs2</span><span class="o">.</span><span class="n">get_image_gids_from_uuid</span><span class="p">(</span><span class="n">guuids_chunk1</span><span class="p">)</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">assert_all_not_None</span><span class="p">(</span><span class="n">aids_chunk1</span><span class="p">,</span> <span class="s">&#39;aids_chunk1&#39;</span><span class="p">)</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">assert_all_not_None</span><span class="p">(</span><span class="n">guuids_chunk1</span><span class="p">,</span> <span class="s">&#39;guuids_chunk1&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">assert_all_not_None</span><span class="p">(</span><span class="n">gids_chunk2</span><span class="p">,</span> <span class="s">&#39;gids_chunk2&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="c">#index = ut.get_first_None_position(gids_chunk2)</span>
        <span class="c">#set(ibs2.get_valid_gids()).difference(set(gids_chunk2))</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">printex</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;gids_chunk2&#39;</span><span class="p">])</span>
        <span class="c">#ut.embed()</span>
        <span class="c">#raise</span>
    <span class="c"># Add this new unseen test case to the database</span>
    <span class="n">aids_chunk2</span> <span class="o">=</span> <span class="n">ibs2</span><span class="o">.</span><span class="n">add_annots</span><span class="p">(</span><span class="n">gids_chunk2</span><span class="p">,</span>
                                  <span class="n">species_list</span><span class="o">=</span><span class="n">species_chunk1</span><span class="p">,</span>
                                  <span class="n">vert_list</span><span class="o">=</span><span class="n">verts_chunk1</span><span class="p">,</span>
                                  <span class="n">theta_list</span><span class="o">=</span><span class="n">thetas_chunk1</span><span class="p">,</span>
                                  <span class="n">prevent_visual_duplicates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">register_annot_mapping</span><span class="p">(</span><span class="n">aids_chunk1</span><span class="p">,</span> <span class="n">aids_chunk2</span><span class="p">,</span> <span class="n">aid1_to_aid2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        called by add_annot_chunk</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Should be 1 to 1</span>
        <span class="k">for</span> <span class="n">aid1</span><span class="p">,</span> <span class="n">aid2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">aids_chunk1</span><span class="p">,</span> <span class="n">aids_chunk2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">aid1</span> <span class="ow">in</span> <span class="n">aid1_to_aid2</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">aid1_to_aid2</span><span class="p">[</span><span class="n">aid1</span><span class="p">]</span> <span class="o">==</span> <span class="n">aid2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aid1_to_aid2</span><span class="p">[</span><span class="n">aid1</span><span class="p">]</span> <span class="o">=</span> <span class="n">aid2</span>
    <span class="c"># Register the mapping from ibs_gt to ibs2</span>
    <span class="n">register_annot_mapping</span><span class="p">(</span><span class="n">aids_chunk1</span><span class="p">,</span> <span class="n">aids_chunk2</span><span class="p">,</span> <span class="n">aid1_to_aid2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Added: aids_chunk2=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">truncate_str</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">aids_chunk2</span><span class="p">),</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">60</span><span class="p">),))</span>
    <span class="k">return</span> <span class="n">aids_chunk2</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m ibeis.model.hots.automated_helpers</span>
<span class="sd">        python -m ibeis.model.hots.automated_helpers --allexamples</span>
<span class="sd">        python -m ibeis.model.hots.automated_helpers --allexamples --noface --nosrc</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>
    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>  <span class="c"># for win32</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="kn">as</span> <span class="nn">ut</span>  <span class="c"># NOQA</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Jon Crall.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.1.0.dev1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>