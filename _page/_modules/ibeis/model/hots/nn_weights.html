

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ibeis.model.hots.nn_weights &mdash; ibeis 0.1.0.dev1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="ibeis 0.1.0.dev1 documentation" href="../../../../index.html"/>
        <link rel="up" title="ibeis.model.hots" href="../hots.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../../index.html" class="fa fa-home"> ibeis</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ibeis.html">ibeis package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.all_imports">ibeis.all_imports module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.constants">ibeis.constants module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.ibsfuncs">ibeis.ibsfuncs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.main_module">ibeis.main_module module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis.params">ibeis.params module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ibeis.html#module-ibeis">Module contents</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">ibeis</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../../../ibeis.html">ibeis</a> &raquo;</li>
      
          <li><a href="../../model.html">ibeis.model</a> &raquo;</li>
      
          <li><a href="../hots.html">ibeis.model.hots</a> &raquo;</li>
      
    <li>ibeis.model.hots.nn_weights</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <h1>Source code for ibeis.model.hots.nn_weights</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">utool</span>
<span class="kn">import</span> <span class="nn">utool</span> <span class="kn">as</span> <span class="nn">ut</span>
<span class="c">#import six</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vtool</span> <span class="kn">as</span> <span class="nn">vt</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">scoring</span>
<span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">name_scoring</span>
<span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">hstypes</span>
<span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">_pipeline_helpers</span> <span class="k">as</span> <span class="n">plh</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">zip</span>
<span class="k">print</span><span class="p">,</span> <span class="n">print_</span><span class="p">,</span>  <span class="n">printDBG</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">utool</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&#39;[nnweight]&#39;</span><span class="p">)</span>


<span class="n">NN_WEIGHT_FUNC_DICT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">MISC_WEIGHT_FUNC_DICT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">EPS</span> <span class="o">=</span> <span class="mf">1E-8</span>


<span class="k">def</span> <span class="nf">_register_nn_normalized_weight_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator for weighting functions</span>

<span class="sd">    Registers a nearest neighbor normalized weighting</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">NN_WEIGHT_FUNC_DICT</span>
    <span class="n">filtkey</span> <span class="o">=</span> <span class="n">utool</span><span class="o">.</span><span class="n">get_funcname</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;_fn&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">utool</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;[nn_weights] registering norm func: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filtkey</span><span class="p">,))</span>
    <span class="n">filtfunc</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">nn_normalized_weight</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="n">NN_WEIGHT_FUNC_DICT</span><span class="p">[</span><span class="n">filtkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtfunc</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_register_nn_simple_weight_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">filtkey</span> <span class="o">=</span> <span class="n">utool</span><span class="o">.</span><span class="n">get_funcname</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;_match_weighter&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">utool</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;[nn_weights] registering simple func: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filtkey</span><span class="p">,))</span>
    <span class="n">NN_WEIGHT_FUNC_DICT</span><span class="p">[</span><span class="n">filtkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_register_misc_weight_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">filtkey</span> <span class="o">=</span> <span class="n">utool</span><span class="o">.</span><span class="n">get_funcname</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;_match_weighter&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">utool</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;[nn_weights] registering simple func: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filtkey</span><span class="p">,))</span>
    <span class="n">MISC_WEIGHT_FUNC_DICT</span><span class="p">[</span><span class="n">filtkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="nd">@_register_nn_simple_weight_func</span>
<div class="viewcode-block" id="dupvote_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.dupvote_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">dupvote_match_weighter</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    dupvotes gives duplicate name votes a weight close to 0.</span>

<span class="sd">    Densve version of name weighting</span>
<span class="sd">    TODO: move to name_scoring</span>
<span class="sd">    TODO: sparse version of name weighting</span>

<span class="sd">    Each query feature is only allowed to vote for each name at most once.</span>
<span class="sd">    IE: a query feature can vote for multiple names, but it cannot vote</span>
<span class="sd">    for the same name twice.</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python dev.py --allgt -t best --db PZ_MTEST</span>
<span class="sd">        python dev.py --allgt -t nsum --db PZ_MTEST</span>
<span class="sd">        python dev.py --allgt -t dupvote --db PZ_MTEST</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m ibeis.model.hots.nn_weights --test-dupvote_match_weighter</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;testdb1&#39;, cfgdict=dict(K=10, Knorm=10))</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; # Test Function Call</span>
<span class="sd">        &gt;&gt;&gt; dupvote_weight_list = nn_weights.dupvote_match_weighter(nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; print(ut.numpy_str(dupvote_weight_list[0], precision=1))</span>
<span class="sd">        &gt;&gt;&gt; # Check consistency</span>
<span class="sd">        &gt;&gt;&gt; qaid = qreq_.get_external_qaids()[0]</span>
<span class="sd">        &gt;&gt;&gt; qfx2_dupvote_weight = dupvote_weight_list[0]</span>
<span class="sd">        &gt;&gt;&gt; flags = qfx2_dupvote_weight  &gt; .5</span>
<span class="sd">        &gt;&gt;&gt; qfx2_topnid = ibs.get_annot_name_rowids(qreq_.indexer.get_nn_aids(nns_list[0][0]))</span>
<span class="sd">        &gt;&gt;&gt; isunique_list = [ut.isunique(row[flag]) for row, flag in zip(qfx2_topnid, flags)]</span>
<span class="sd">        &gt;&gt;&gt; assert all(isunique_list), &#39;dupvote should only allow one vote per name&#39;</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        ./dev.py -t nsum --db GZ_ALL --show --va -w --qaid 1032</span>
<span class="sd">        ./dev.py -t nsum_nosv --db GZ_ALL --show --va -w --qaid 1032</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dupvote_weight_list</span> <span class="o">=</span> <span class="n">name_scoring</span><span class="o">.</span><span class="n">name_scoring_dense_old</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dupvote_weight_list</span>

</div>
<div class="viewcode-block" id="componentwise_uint8_dot"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.componentwise_uint8_dot">[docs]</a><span class="k">def</span> <span class="nf">componentwise_uint8_dot</span><span class="p">(</span><span class="n">qfx2_qvec</span><span class="p">,</span> <span class="n">qfx2_dvec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; a dot product is a componentwise multiplication of</span>
<span class="sd">    two vector and then a sum. Do that for arbitary vectors.</span>
<span class="sd">    Remember to cast uint8 to float32 and then divide by 255**2.</span>
<span class="sd">    BUT THESE ARE SIFT DESCRIPTORS WHICH USE THE SMALL UINT8 TRICK</span>
<span class="sd">    DIVIDE BY 512**2 instead</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr1</span> <span class="o">=</span> <span class="n">qfx2_qvec</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">hstypes</span><span class="o">.</span><span class="n">FS_DTYPE</span><span class="p">)</span>
    <span class="n">arr2</span> <span class="o">=</span> <span class="n">qfx2_dvec</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">hstypes</span><span class="o">.</span><span class="n">FS_DTYPE</span><span class="p">)</span>
    <span class="n">cosangle</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">componentwise_dot</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">)</span> <span class="o">/</span> <span class="n">hstypes</span><span class="o">.</span><span class="n">PSEUDO_UINT8_MAX_SQRD</span>
    <span class="k">return</span> <span class="n">cosangle</span>

</div>
<span class="nd">@_register_nn_simple_weight_func</span>
<div class="viewcode-block" id="cos_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.cos_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">cos_match_weighter</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;, cfgdict=dict(cos_on=True, K=10, Knorm=10))</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; assert qreq_.qparams.cos_on, &#39;bug setting custom params cos_weight&#39;</span>
<span class="sd">        &gt;&gt;&gt; cos_weight_list = nn_weights.cos_match_weighter(nns_list, nnvalid0_list, qreq_)</span>

<span class="sd">    Dev::</span>
<span class="sd">        qnid = ibs.get_annot_name_rowids(qaid)</span>
<span class="sd">        qfx2_nids = ibs.get_annot_name_rowids(qreq_.indexer.get_nn_aids(qfx2_idx.T[0:K].T))</span>

<span class="sd">        # remove first match</span>
<span class="sd">        qfx2_nids_ = qfx2_nids.T[1:].T</span>
<span class="sd">        qfx2_cos_  = qfx2_cos.T[1:].T</span>

<span class="sd">        # flags of unverified &#39;correct&#39; matches</span>
<span class="sd">        qfx2_samename = qfx2_nids_ == qnid</span>

<span class="sd">        for k in [1, None]:</span>
<span class="sd">            for alpha in [.01, .1, 1, 3, 10, 20, 50]:</span>
<span class="sd">                print(&#39;-------&#39;)</span>
<span class="sd">                print(&#39;alpha = %r&#39; % alpha)</span>
<span class="sd">                print(&#39;k = %r&#39; % k)</span>
<span class="sd">                qfx2_cosweight = np.multiply(np.sign(qfx2_cos_), np.power(qfx2_cos_, alpha))</span>
<span class="sd">                if k is None:</span>
<span class="sd">                    qfx2_weight = qfx2_cosweight</span>
<span class="sd">                    flag = qfx2_samename</span>
<span class="sd">                else:</span>
<span class="sd">                    qfx2_weight = qfx2_cosweight.T[0:k].T</span>
<span class="sd">                    flag = qfx2_samename.T[0:k].T</span>
<span class="sd">                #print(qfx2_weight)</span>
<span class="sd">                #print(flag)</span>
<span class="sd">                good_stats_ = ut.get_stats(qfx2_weight[flag])</span>
<span class="sd">                bad_stats_ = ut.get_stats(qfx2_weight[~flag])</span>
<span class="sd">                print(&#39;good_matches = &#39; + ut.dict_str(good_stats_))</span>
<span class="sd">                print(&#39;bad_matchees = &#39; + ut.dict_str(bad_stats_))</span>
<span class="sd">                print(&#39;diff_mean = &#39; + str(good_stats_[&#39;mean&#39;] - bad_stats_[&#39;mean&#39;]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Prealloc output</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">K</span>
    <span class="n">cos_weight_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">qaid_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_internal_qaids</span><span class="p">()</span>
    <span class="c"># Database feature index to chip index</span>
    <span class="k">for</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">nns</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qaid_list</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">):</span>
        <span class="p">(</span><span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">)</span> <span class="o">=</span> <span class="n">nns</span>
        <span class="n">qfx2_qvec</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_vecs</span><span class="p">(</span><span class="n">qaid</span><span class="p">,</span> <span class="n">qreq_</span><span class="o">=</span><span class="n">qreq_</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="c"># database forground weights</span>
        <span class="n">qfx2_dvec</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">get_nn_vecs</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">K</span><span class="p">])</span>
        <span class="c"># Component-wise dot product + selectivity function</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="n">qfx2_cosweight</span> <span class="o">=</span> <span class="n">scoring</span><span class="o">.</span><span class="n">sift_selectivity_score</span><span class="p">(</span><span class="n">qfx2_qvec</span><span class="p">,</span> <span class="n">qfx2_dvec</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">cos_weight_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qfx2_cosweight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cos_weight_list</span>

</div>
<span class="nd">@_register_nn_simple_weight_func</span>
<div class="viewcode-block" id="fg_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.fg_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">fg_match_weighter</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    foreground feature match weighting</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; print(ut.dict_str(qreq_.qparams.__dict__, sorted_=True))</span>
<span class="sd">        &gt;&gt;&gt; assert qreq_.qparams.fg_on == True, &#39;bug setting custom params fg_on&#39;</span>
<span class="sd">        &gt;&gt;&gt; fgvotes_list = fg_match_weighter(nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Prealloc output</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">K</span>
    <span class="n">fgvotes_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">qaid_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_internal_qaids</span><span class="p">()</span>
    <span class="c"># Database feature index to chip index</span>
    <span class="k">for</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">nns</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qaid_list</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">):</span>
        <span class="p">(</span><span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">)</span> <span class="o">=</span> <span class="n">nns</span>
        <span class="c"># database forground weights</span>
        <span class="n">qfx2_dfgw</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">get_nn_fgws</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">K</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c"># query forground weights</span>
        <span class="n">qfx2_qfgw</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_fgweights</span><span class="p">([</span><span class="n">qaid</span><span class="p">],</span> <span class="n">ensure</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">qreq_</span><span class="o">=</span><span class="n">qreq_</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c"># feature match forground weight</span>
        <span class="n">qfx2_fgvote_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qfx2_qfgw</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">qfx2_dfgw</span><span class="p">)</span>
        <span class="n">fgvotes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qfx2_fgvote_weight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fgvotes_list</span>

</div>
<span class="nd">@_register_misc_weight_func</span>
<div class="viewcode-block" id="distinctiveness_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.distinctiveness_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">distinctiveness_match_weighter</span><span class="p">(</span><span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;, codename=&#39;vsone_dist_extern_distinctiveness&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>

<span class="sd">    TODO: finish intergration</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dstcnvs_normer</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">dstcnvs_normer</span>
    <span class="k">assert</span> <span class="n">dstcnvs_normer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
    <span class="n">qaid_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_external_qaids</span><span class="p">()</span>
    <span class="n">vecs_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_vecs</span><span class="p">(</span><span class="n">qaid_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="o">=</span><span class="n">qreq_</span><span class="p">)</span>
    <span class="n">dstcvs_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">vecs</span> <span class="ow">in</span> <span class="n">vecs_list</span><span class="p">:</span>
        <span class="n">qfx2_vec</span> <span class="o">=</span> <span class="n">vecs</span>
        <span class="n">dstcvs</span> <span class="o">=</span> <span class="n">dstcnvs_normer</span><span class="o">.</span><span class="n">get_distinctiveness</span><span class="p">(</span><span class="n">qfx2_vec</span><span class="p">)</span>
        <span class="n">dstcvs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dstcvs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dstcvs_list</span>

</div>
<div class="viewcode-block" id="nn_normalized_weight"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.nn_normalized_weight">[docs]</a><span class="k">def</span> <span class="nf">nn_normalized_weight</span><span class="p">(</span><span class="n">normweight_fn</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic function to weight nearest neighbors</span>

<span class="sd">    ratio, lnbnn, and other nearest neighbor based functions use this</span>

<span class="sd">    Args:</span>
<span class="sd">        normweight_fn (func): chosen weight function e.g. lnbnn</span>
<span class="sd">        nns_list (dict): query descriptor nearest neighbors and distances. (qfx2_nnx, qfx2_dist)</span>
<span class="sd">        qreq_ (QueryRequest): hyper-parameters</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: weights_list</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; normweight_fn = lnbnn_fn</span>
<span class="sd">        &gt;&gt;&gt; weights_list1 = nn_weights.nn_normalized_weight(normweight_fn, nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; weights1 = weights_list1[0]</span>
<span class="sd">        &gt;&gt;&gt; nn_normonly_weight = nn_weights.NN_WEIGHT_FUNC_DICT[&#39;lnbnn&#39;]</span>
<span class="sd">        &gt;&gt;&gt; weights_list2 = nn_normonly_weight(nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; weights2 = weights_list2[0]</span>
<span class="sd">        &gt;&gt;&gt; assert np.all(weights1 == weights2)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; normweight_fn = ratio_fn</span>
<span class="sd">        &gt;&gt;&gt; weights_list1 = nn_weights.nn_normalized_weight(normweight_fn, nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; weights1 = weights_list1[0]</span>
<span class="sd">        &gt;&gt;&gt; nn_normonly_weight = nn_weights.NN_WEIGHT_FUNC_DICT[&#39;ratio&#39;]</span>
<span class="sd">        &gt;&gt;&gt; weights_list2 = nn_normonly_weight(nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; weights2 = weights_list2[0]</span>
<span class="sd">        &gt;&gt;&gt; assert np.all(weights1 == weights2)</span>

<span class="sd">    Ignore:</span>
<span class="sd">        #from ibeis.model.hots import neighbor_index as hsnbrx</span>
<span class="sd">        #nnindexer = hsnbrx.request_ibeis_nnindexer(qreq_)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#utool.stash_testdata(&#39;nns_list&#39;)</span>
    <span class="c">#</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">K</span>

    <span class="n">Knorm</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">Knorm</span>
    <span class="n">rule</span>  <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">normalizer_rule</span>
    <span class="c">#with_metadata = qreq_.qparams.with_metadata</span>
    <span class="c">#normweight_upper_bound = 30  # TODO:  make this specific to each normweight func</span>

    <span class="c"># Prealloc output</span>
    <span class="n">weight_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c">#if with_metadata:</span>
    <span class="c">#    metadata = qreq_.metadata</span>
    <span class="c">#    metakey = ut.get_funcname(normweight_fn) + &#39;_norm_meta&#39;</span>
    <span class="c">#    metadata[metakey] = {}</span>
    <span class="c">#    metakey_metadata = metadata[metakey]</span>
    <span class="c">#else:</span>
    <span class="c">#    metakey_metadata = None</span>
    <span class="c"># Database feature index to chip index</span>
    <span class="n">qaid_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_internal_qaids</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">nns</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qaid_list</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">):</span>
        <span class="p">(</span><span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">)</span> <span class="o">=</span> <span class="n">nns</span>
        <span class="c"># Apply normalized weights</span>
        <span class="n">qfx2_normweight</span> <span class="o">=</span> <span class="n">apply_normweight</span><span class="p">(</span>
            <span class="n">normweight_fn</span><span class="p">,</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Knorm</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">)</span>
        <span class="c">#with_metadata, metakey_metadata)</span>
        <span class="c">#qfx2_normweight[qfx2_normweight &gt; normweight_upper_bound] = normweight_upper_bound</span>
        <span class="c">#qfx2_normweight /= normweight_upper_bound</span>
        <span class="c"># Output</span>
        <span class="n">weight_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qfx2_normweight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weight_list</span>

</div>
<div class="viewcode-block" id="apply_normweight"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.apply_normweight">[docs]</a><span class="k">def</span> <span class="nf">apply_normweight</span><span class="p">(</span><span class="n">normweight_fn</span><span class="p">,</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Knorm</span><span class="p">,</span>
                     <span class="n">qreq_</span><span class="p">):</span>
    <span class="c">#, with_metadata, metakey_metadata):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    helper: applies the normalized weight function to one query annotation</span>

<span class="sd">    Args:</span>
<span class="sd">        normweight_fn (func): chosen weight function e.g. lnbnn</span>
<span class="sd">        qaid (int): query annotation id</span>
<span class="sd">        qfx2_idx (ndarray):</span>
<span class="sd">        qfx2_dist (ndarray):</span>
<span class="sd">        rule (str):</span>
<span class="sd">        K (int):</span>
<span class="sd">        Knorm (int):</span>
<span class="sd">        qreq_ (QueryRequest): hyper-parameters</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: qfx2_normweight</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # SLOW_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; cfgdict = {&#39;K&#39;:10, &#39;Knorm&#39;: 10, &#39;normalizer_rule&#39;: &#39;name&#39;}</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors()</span>
<span class="sd">        &gt;&gt;&gt; qaid = qreq_.get_external_qaids()[0]</span>
<span class="sd">        &gt;&gt;&gt; K = qreq_.qparams.K</span>
<span class="sd">        &gt;&gt;&gt; Knorm = qreq_.qparams.Knorm</span>
<span class="sd">        &gt;&gt;&gt; normweight_fn = lnbnn_fn</span>
<span class="sd">        &gt;&gt;&gt; rule  = qreq_.qparams.normalizer_rule</span>
<span class="sd">        &gt;&gt;&gt; (qfx2_idx, qfx2_dist) = nns_list[0]</span>
<span class="sd">        &gt;&gt;&gt; qfx2_normweight = nn_weights.apply_normweight(normweight_fn, qaid, qfx2_idx,</span>
<span class="sd">        ...         qfx2_dist, rule, K, Knorm, qreq_)</span>

<span class="sd">    Timeits:</span>
<span class="sd">        %timeit qfx2_dist.T[0:K].T</span>
<span class="sd">        %timeit qfx2_dist[:, 0:K]</span>

<span class="sd">    Ignore:</span>
<span class="sd">        print(&#39;\n&#39;.join(((</span>
<span class="sd">        &#39;&gt;&gt;&gt; ndist = np.&#39; + np.array_repr(ndist.T).replace(&#39; ...,&#39;, &#39;&#39;) + &#39;.T&#39;),</span>
<span class="sd">        &#39;&gt;&gt;&gt; vdist = np.&#39; + np.array_repr(vdist.T).replace(&#39; ...,&#39;, &#39;&#39;) + &#39;.T&#39;)</span>
<span class="sd">        ))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">qfx2_nndist</span> <span class="o">=</span> <span class="n">qfx2_dist</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">K</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">rule</span> <span class="o">==</span> <span class="s">&#39;last&#39;</span><span class="p">:</span>
        <span class="c"># Normalizers for &#39;last&#39; rule</span>
        <span class="n">qfx2_normk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qfx2_dist</span><span class="p">),</span> <span class="n">hstypes</span><span class="o">.</span><span class="n">FK_DTYPE</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="n">Knorm</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rule</span> <span class="o">==</span> <span class="s">&#39;name&#39;</span><span class="p">:</span>
        <span class="c"># Normalizers for &#39;name&#39; rule</span>
        <span class="n">qfx2_normk</span> <span class="o">=</span> <span class="n">get_name_normalizers</span><span class="p">(</span><span class="n">qaid</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Knorm</span><span class="p">,</span> <span class="n">qfx2_idx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rule</span> <span class="o">==</span> <span class="s">&#39;external&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;[nn_weights] no rule=</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">rule</span><span class="p">)</span>
    <span class="n">qfx2_normdist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dists</span><span class="p">[</span><span class="n">normk</span><span class="p">]</span>
                              <span class="k">for</span> <span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">normk</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qfx2_dist</span><span class="p">,</span> <span class="n">qfx2_normk</span><span class="p">)])</span>
    <span class="c">#qfx2_normidx  = np.array([idxs[normk]</span>
    <span class="c">#                          for (idxs, normk) in zip(qfx2_idx, qfx2_normk)])</span>
    <span class="c"># Ensure shapes are valid</span>
    <span class="n">qfx2_normdist</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">vdist</span> <span class="o">=</span> <span class="n">qfx2_nndist</span>    <span class="c"># voting distance</span>
    <span class="n">ndist</span> <span class="o">=</span> <span class="n">qfx2_normdist</span>  <span class="c"># normalizer distance</span>
    <span class="n">qfx2_normweight</span> <span class="o">=</span> <span class="n">normweight_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">)</span>
    <span class="c"># build meta</span>
    <span class="c">#if with_metadata:</span>
    <span class="c">#    normmeta_header = (&#39;normalizer_metadata&#39;, [&#39;norm_aid&#39;, &#39;norm_fx&#39;, &#39;norm_k&#39;])</span>
    <span class="c">#    qfx2_normmeta = np.array(</span>
    <span class="c">#        [</span>
    <span class="c">#            (qreq_.indexer.get_nn_aids(idx), qreq_.indexer.get_nn_featxs(idx), normk)</span>
    <span class="c">#            for (normk, idx) in zip(qfx2_normk, qfx2_normidx)</span>
    <span class="c">#        ]</span>
    <span class="c">#    )</span>
    <span class="c">#    metakey_metadata[qaid] = (normmeta_header, qfx2_normmeta)</span>
    <span class="k">return</span> <span class="n">qfx2_normweight</span>

</div>
<div class="viewcode-block" id="get_name_normalizers"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.get_name_normalizers">[docs]</a><span class="k">def</span> <span class="nf">get_name_normalizers</span><span class="p">(</span><span class="n">qaid</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Knorm</span><span class="p">,</span> <span class="n">qfx2_idx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    helper: normalizers for &#39;name&#39; rule</span>

<span class="sd">    Args:</span>
<span class="sd">        qaid (int): query annotation id</span>
<span class="sd">        qreq_ (QueryRequest): hyper-parameters</span>
<span class="sd">        K (int):</span>
<span class="sd">        Knorm (int):</span>
<span class="sd">        qfx2_idx (ndarray):</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray : qfx2_normk</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors()</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; K = ibs.cfg.query_cfg.nn_cfg.K</span>
<span class="sd">        &gt;&gt;&gt; Knorm = ibs.cfg.query_cfg.nn_cfg.Knorm</span>
<span class="sd">        &gt;&gt;&gt; normweight_fn = lnbnn_fn</span>
<span class="sd">        &gt;&gt;&gt; (qfx2_idx, qfx2_dist) = nns_list[0]</span>
<span class="sd">        &gt;&gt;&gt; qfx2_nndist = qfx2_dist.T[0:K].T</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Get the top names you do not want your normalizer to be from</span>
    <span class="n">qnid</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_name_rowids</span><span class="p">(</span><span class="n">qaid</span><span class="p">)</span>
    <span class="n">nTop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
    <span class="c"># Get the 0th - Kth matching neighbors</span>
    <span class="n">qfx2_topidx</span> <span class="o">=</span> <span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nTop</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="c"># Get tke Kth - KNth normalizing neighbors</span>
    <span class="n">qfx2_normidx</span> <span class="o">=</span> <span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="n">Knorm</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span>
    <span class="c"># Apply temporary uniquish name</span>
    <span class="n">qfx2_topaid</span>  <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">get_nn_aids</span><span class="p">(</span><span class="n">qfx2_topidx</span><span class="p">)</span>
    <span class="n">qfx2_normaid</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">get_nn_aids</span><span class="p">(</span><span class="n">qfx2_normidx</span><span class="p">)</span>
    <span class="n">qfx2_topnid</span>  <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_name_rowids</span><span class="p">(</span><span class="n">qfx2_topaid</span><span class="p">)</span>
    <span class="n">qfx2_normnid</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_name_rowids</span><span class="p">(</span><span class="n">qfx2_normaid</span><span class="p">)</span>
    <span class="c"># Inspect the potential normalizers</span>
    <span class="n">qfx2_normk</span> <span class="o">=</span> <span class="n">mark_name_valid_normalizers</span><span class="p">(</span><span class="n">qfx2_normnid</span><span class="p">,</span> <span class="n">qfx2_topnid</span><span class="p">,</span> <span class="n">qnid</span><span class="p">)</span>
    <span class="n">qfx2_normk</span> <span class="o">+=</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="n">Knorm</span><span class="p">)</span>  <span class="c"># convert form negative to pos indexes</span>
    <span class="k">return</span> <span class="n">qfx2_normk</span>

</div>
<div class="viewcode-block" id="mark_name_valid_normalizers"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.mark_name_valid_normalizers">[docs]</a><span class="k">def</span> <span class="nf">mark_name_valid_normalizers</span><span class="p">(</span><span class="n">qfx2_normnid</span><span class="p">,</span> <span class="n">qfx2_topnid</span><span class="p">,</span> <span class="n">qnid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    helper: Allows matches only to the first result of a given name</span>

<span class="sd">    Args:</span>
<span class="sd">        qfx2_normnid (ndarray):</span>
<span class="sd">        qfx2_topnid (ndarray):</span>
<span class="sd">        qnid (int): query name id</span>

<span class="sd">    Returns:</span>
<span class="sd">        qfx2_selnorm - index of the selected normalizer for each query feature</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#columns = qfx2_topnid</span>
    <span class="c">#matrix = qfx2_normnid</span>
    <span class="n">Kn</span> <span class="o">=</span> <span class="n">qfx2_normnid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c"># Find the positions in the normalizers that could be valid (assumes Knorm &gt; 1)</span>
    <span class="c"># compare_matrix_columns is probably inefficient</span>
    <span class="n">qfx2_valid</span> <span class="o">=</span> <span class="bp">True</span> <span class="o">-</span> <span class="n">vt</span><span class="o">.</span><span class="n">compare_matrix_columns</span><span class="p">(</span><span class="n">qfx2_normnid</span><span class="p">,</span> <span class="n">qfx2_topnid</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">qnid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># Mark self as invalid, if given that information</span>
        <span class="n">qfx2_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">qfx2_normnid</span> <span class="o">!=</span> <span class="n">qnid</span><span class="p">,</span> <span class="n">qfx2_valid</span><span class="p">)</span>

    <span class="c"># For each query feature find its best normalizer (using negative indices)</span>
    <span class="n">qfx2_validlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">normrow</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">normrow</span> <span class="ow">in</span> <span class="n">qfx2_valid</span><span class="p">]</span>
    <span class="n">qfx2_selnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poslist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">Kn</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poslist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span>
                             <span class="n">poslist</span> <span class="ow">in</span> <span class="n">qfx2_validlist</span><span class="p">],</span> <span class="n">hstypes</span><span class="o">.</span><span class="n">FK_DTYPE</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qfx2_selnorm</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="lnbnn_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.lnbnn_fn">[docs]</a><span class="k">def</span> <span class="nf">lnbnn_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Locale Naive Bayes Nearest Neighbor weighting</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; ndists = np.array([[0, 1, 2], [3, 4, 5], [3, 4, 5], [3, 4, 5],  [9, 7, 6]])</span>
<span class="sd">        &gt;&gt;&gt; ndist = ndists.T[0:1].T</span>
<span class="sd">        &gt;&gt;&gt; vdist = np.array([[3, 2, 1, 5], [3, 2, 5, 6], [3, 4, 5, 3], [3, 4, 5, 8],  [9, 7, 6, 3] ])</span>
<span class="sd">        &gt;&gt;&gt; vdist1 = vdist[:, 0:1]</span>
<span class="sd">        &gt;&gt;&gt; vdist2 = vdist[:, 0:2]</span>
<span class="sd">        &gt;&gt;&gt; vdist3 = vdist[:, 0:3]</span>
<span class="sd">        &gt;&gt;&gt; vdist4 = vdist[:, 0:4]</span>
<span class="sd">        &gt;&gt;&gt; print(lnbnn_fn(vdist1, ndist))</span>
<span class="sd">        &gt;&gt;&gt; print(lnbnn_fn(vdist2, ndist))</span>
<span class="sd">        &gt;&gt;&gt; print(lnbnn_fn(vdist3, ndist))</span>
<span class="sd">        &gt;&gt;&gt; print(lnbnn_fn(vdist4, ndist))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ndist</span> <span class="o">-</span> <span class="n">vdist</span><span class="p">)</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="loglnbnn_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.loglnbnn_fn">[docs]</a><span class="k">def</span> <span class="nf">loglnbnn_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ndist</span> <span class="o">-</span> <span class="n">vdist</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c"># / 1000.0</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="ratio_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.ratio_fn">[docs]</a><span class="k">def</span> <span class="nf">ratio_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        vdist (ndarray): voting array</span>
<span class="sd">        ndist (ndarray): normalizing array</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: out</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; vdist = np.array([[ 0.,  0.,  0.,  0.,  0.,  0.]], dtype=np.float32).T</span>
<span class="sd">        &gt;&gt;&gt; ndist = np.array([[  60408.,   61594.,  111387., 120138., 124307.,  125625.]], dtype=np.float32).T</span>
<span class="sd">        &gt;&gt;&gt; out = ratio_fn(vdist, ndist)</span>
<span class="sd">        &gt;&gt;&gt; result = np.array_repr(out.T, precision=2)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        array([[ 0.,  0.,  0.,  0.,  0.,  0.]], dtype=float32)</span>

<span class="sd">    Example2:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; vdist = np.array([[  79260.,  138617.,   47964.,  127839.,  123543.,  112204.]], dtype=np.float32).T</span>
<span class="sd">        &gt;&gt;&gt; ndist = np.array([[  83370.,  146245.,  128620.,  129598.,  126165.,  124761.]], dtype=np.float32).T</span>
<span class="sd">        &gt;&gt;&gt; out = ratio_fn(vdist, ndist)</span>
<span class="sd">        &gt;&gt;&gt; result = np.array_repr(out.T, precision=2)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        array([[ 0.95,  0.95,  0.37,  0.99,  0.98,  0.9 ]], dtype=float32)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">)</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="dist_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.dist_fn">[docs]</a><span class="k">def</span> <span class="nf">dist_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; just use straight up distance &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vdist</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="logratio_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.logratio_fn">[docs]</a><span class="k">def</span> <span class="nf">logratio_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">ndist</span><span class="p">,</span> <span class="n">vdist</span> <span class="o">+</span> <span class="n">EPS</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="normonly_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.normonly_fn">[docs]</a><span class="k">def</span> <span class="nf">normonly_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ndist</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">vdist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c">#return ndist[None, 0:1]</span>


<span class="c">#@_register_nn_simple_weight_func</span></div>
<div class="viewcode-block" id="gravity_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.gravity_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">gravity_match_weighter</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;have not finished gv weighting&#39;</span><span class="p">)</span>
    <span class="c">#qfx2_nnkpts = qreq_.indexer.get_nn_kpts(qfx2_nnidx)</span>
    <span class="c">#qfx2_nnori = ktool.get_oris(qfx2_nnkpts)</span>
    <span class="c">#qfx2_kpts  = qreq_.ibs.get_annot_kpts(qaid, qreq_=qreq_)  # FIXME: Highly inefficient</span>
    <span class="c">#qfx2_oris  = ktool.get_oris(qfx2_kpts)</span>
    <span class="c">## Get the orientation distance</span>
    <span class="c">#qfx2_oridist = vt.rowwise_oridist(qfx2_nnori, qfx2_oris)</span>
    <span class="c">## Normalize into a weight (close orientations are 1, far are 0)</span>
    <span class="c">#qfx2_gvweight = (TAU - qfx2_oridist) / TAU</span>
    <span class="c">## Apply gravity vector weight to the score</span>
    <span class="c">#qfx2_score *= qfx2_gvweight</span>

</div>
<div class="viewcode-block" id="test_all_normalized_weights"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.test_all_normalized_weights">[docs]</a><span class="k">def</span> <span class="nf">test_all_normalized_weights</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; test_all_normalized_weights()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">nn_weights</span>
    <span class="kn">import</span> <span class="nn">six</span>
    <span class="n">ibs</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span> <span class="o">=</span> <span class="n">plh</span><span class="o">.</span><span class="n">testdata_pre_weight_neighbors</span><span class="p">()</span>
    <span class="n">qaid</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_external_qaids</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">test_weight_fn</span><span class="p">(</span><span class="n">nn_weight</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">qaid</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">nn_weights</span>
        <span class="c">#----</span>
        <span class="n">normweight_fn</span> <span class="o">=</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">nn_weight</span> <span class="o">+</span> <span class="s">&#39;_fn&#39;</span><span class="p">]</span>
        <span class="n">weight_list1</span> <span class="o">=</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">nn_normalized_weight</span><span class="p">(</span><span class="n">normweight_fn</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">)</span>
        <span class="n">weights1</span> <span class="o">=</span> <span class="n">weight_list1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c">#---</span>
        <span class="c"># test NN_WEIGHT_FUNC_DICT</span>
        <span class="c">#---</span>
        <span class="n">nn_normonly_weight</span> <span class="o">=</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">NN_WEIGHT_FUNC_DICT</span><span class="p">[</span><span class="n">nn_weight</span><span class="p">]</span>
        <span class="n">weight_list2</span> <span class="o">=</span> <span class="n">nn_normonly_weight</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">)</span>
        <span class="n">weights2</span> <span class="o">=</span> <span class="n">weight_list2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">weights1</span> <span class="o">==</span> <span class="n">weights2</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">nn_weight</span> <span class="o">+</span> <span class="s">&#39; passed&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">nn_weight</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="n">nn_weights</span><span class="o">.</span><span class="n">NN_WEIGHT_FUNC_DICT</span><span class="p">):</span>
        <span class="n">normweight_key</span> <span class="o">=</span> <span class="n">nn_weight</span> <span class="o">+</span> <span class="s">&#39;_fn&#39;</span>
        <span class="k">if</span> <span class="n">normweight_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">test_weight_fn</span><span class="p">(</span><span class="n">nn_weight</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">qaid</span><span class="p">)</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    python -m ibeis.model.hots.nn_weights --allexamples</span>
<span class="sd">    python -m ibeis.model.hots.nn_weights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>
    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="kn">as</span> <span class="nn">ut</span>  <span class="c"># NOQA</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Jon Crall.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.1.0.dev1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>