

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ibeis.algo.graph.mixin_dynamic &mdash; ibeis 1.9.0.vulcan documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> ibeis
          

          
          </a>

          
            
            
              <div class="version">
                1.9.0.vulcan
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ibeis.html">ibeis package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ibeis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../ibeis.html">ibeis</a> &raquo;</li>
        
          <li><a href="../../algo.html">ibeis.algo</a> &raquo;</li>
        
          <li><a href="../graph.html">ibeis.algo.graph</a> &raquo;</li>
        
      <li>ibeis.algo.graph.mixin_dynamic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ibeis.algo.graph.mixin_dynamic</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">TODO:</span>
<span class="sd">    Negative bookkeeping, needs a small re-organization fix.</span>
<span class="sd">    MOVE FROM neg_redun_metagraph TO neg_metagraph</span>

<span class="sd">    Instead of maintaining a graph that contains PCCS which are neg redundant</span>
<span class="sd">    to each other, the graph should maintain PCCs that have ANY negative edge</span>
<span class="sd">    between them (aka 1 neg redundant). Then that edge should store a flag</span>
<span class="sd">    indicating the strength / redundancy of that connection.</span>
<span class="sd">    A better idea might be to store both neg_redun_metagraph AND neg_metagraph.</span>

<span class="sd">    TODO: this (all neg-redun functionality can be easilly consolidated into</span>
<span class="sd">    the neg-metagraph-update. note, we have to allow inconsistent pccs to be in</span>
<span class="sd">    the neg redun graph, we just filter them out afterwords)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">ibeis</span> <span class="k">import</span> <span class="n">constants</span> <span class="k">as</span> <span class="n">const</span>
<span class="kn">from</span> <span class="nn">ibeis.algo.graph</span> <span class="k">import</span> <span class="n">nx_utils</span> <span class="k">as</span> <span class="n">nxu</span>
<span class="kn">from</span> <span class="nn">ibeis.algo.graph.state</span> <span class="k">import</span> <span class="p">(</span><span class="n">POSTV</span><span class="p">,</span> <span class="n">NEGTV</span><span class="p">,</span> <span class="n">INCMP</span><span class="p">,</span> <span class="n">UNREV</span><span class="p">,</span> <span class="n">UNKWN</span><span class="p">,</span>
                                    <span class="n">UNINFERABLE</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">ibeis.algo.graph.state</span> <span class="k">import</span> <span class="p">(</span><span class="n">SAME</span><span class="p">,</span> <span class="n">DIFF</span><span class="p">,</span> <span class="n">NULL</span><span class="p">)</span>  <span class="c1"># NOQA</span>
<span class="nb">print</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">inject2</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">DECISION_LEVEL</span> <span class="o">=</span> <span class="mi">4</span>


<div class="viewcode-block" id="DynamicUpdate"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.DynamicUpdate">[docs]</a><span class="k">class</span> <span class="nc">DynamicUpdate</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # 12 total possible states</span>

<span class="sd">    # details of these states.</span>
<span class="sd">    POSITIVE, WITHIN, CONSISTENT</span>
<span class="sd">        * pos-within never changes PCC status</span>
<span class="sd">        * never introduces inconsistency</span>
<span class="sd">        * might add pos-redun</span>
<span class="sd">    POSITIVE, WITHIN, INCONSISTENT</span>
<span class="sd">        * pos-within never changes PCC status</span>
<span class="sd">        * might fix inconsistent edge</span>
<span class="sd">    POSITIVE, BETWEEN, BOTH_CONSISTENT</span>
<span class="sd">        * pos-between edge always does merge</span>
<span class="sd">    POSITIVE, BETWEEN, ANY_INCONSISTENT</span>
<span class="sd">        * pos-between edge always does merge</span>
<span class="sd">        * pos-between never fixes inconsistency</span>

<span class="sd">    NEGATIVE, WITHIN, CONSISTENT</span>
<span class="sd">        * might split PCC, results will be consistent</span>
<span class="sd">        * might causes an inconsistency</span>
<span class="sd">    NEGATIVE, WITHIN, INCONSISTENT</span>
<span class="sd">        * might split PCC, results may be inconsistent</span>
<span class="sd">    NEGATIVE, BETWEEN, BOTH_CONSISTENT</span>
<span class="sd">        * might add neg-redun</span>
<span class="sd">    NEGATIVE, BETWEEN, ANY_INCONSISTENT</span>
<span class="sd">        * might add to incon-neg-external</span>
<span class="sd">        * neg-redun not tracked for incon.</span>

<span class="sd">    UNINFERABLE, WITHIN, CONSISTENT</span>
<span class="sd">        * might remove pos-redun</span>
<span class="sd">        * might split PCC, results will be consistent</span>
<span class="sd">    UNINFERABLE, WITHIN, INCONSISTENT</span>
<span class="sd">        * might split PCC, results may be inconsistent</span>
<span class="sd">    UNINFERABLE, BETWEEN, BOTH_CONSISTENT</span>
<span class="sd">        * might remove neg-redun</span>
<span class="sd">    UNINFERABLE, BETWEEN, ANY_INCONSISTENT</span>
<span class="sd">        * might remove incon-neg-external</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DynamicUpdate.ensure_edges_from"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.DynamicUpdate.ensure_edges_from">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_edges_from</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds edges that don&#39;t exist and adds them as unreviwed edges.</span>
<span class="sd">        Returns new edges that were added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="c1"># Only add edges that don&#39;t exist</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">e</span><span class="p">)]</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">,</span>
                                  <span class="n">evidence_decision</span><span class="o">=</span><span class="n">UNREV</span><span class="p">,</span>
                                  <span class="n">meta_decision</span><span class="o">=</span><span class="n">UNREV</span><span class="p">,</span>
                                  <span class="n">decision</span><span class="o">=</span><span class="n">UNREV</span><span class="p">,</span>
                                  <span class="n">num_reviews</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># No inference is needed by expliclty creating unreviewed edges that</span>
        <span class="c1"># already implicitly existsed.</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">_add_review_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">,</span> <span class="n">decision</span><span class="o">=</span><span class="n">UNREV</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_edges</span></div>

<div class="viewcode-block" id="DynamicUpdate.add_review_edge"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.DynamicUpdate.add_review_edge">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">add_review_edge</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds edge to the dynamically connected graphs and updates dynamically</span>
<span class="sd">        inferrable edge attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">decision</span> <span class="o">==</span> <span class="n">POSTV</span><span class="p">:</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_positive_decision</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">decision</span> <span class="o">==</span> <span class="n">NEGTV</span><span class="p">:</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_negative_decision</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">decision</span> <span class="ow">in</span> <span class="n">UNINFERABLE</span><span class="p">:</span>
            <span class="c1"># incomparable and unreview have the same inference structure</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_uninferable_decision</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Unknown decision=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">decision</span><span class="p">,))</span>
        <span class="k">return</span> <span class="n">action</span></div>

    <span class="k">def</span> <span class="nf">_add_review_edges_from</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">decision</span><span class="o">=</span><span class="n">UNREV</span><span class="p">):</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;add </span><span class="si">{}</span><span class="s1"> edges decision=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="n">decision</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Add to review graph corresponding to decision</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">review_graphs</span><span class="p">[</span><span class="n">decision</span><span class="p">]</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="c1"># Remove from previously existing graphs</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">review_graphs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">decision</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_review_edge</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an edge to the appropriate data structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># infr.print(&#39;add review edge=%r, decision=%r&#39; % (edge, decision), 20)</span>
        <span class="c1"># Add to review graph corresponding to decision</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">review_graphs</span><span class="p">[</span><span class="n">decision</span><span class="p">]</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
        <span class="c1"># Remove from previously existing graphs</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">review_graphs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">decision</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">):</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_get_current_decision</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find if any data structure has the edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">decision</span><span class="p">,</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">review_graphs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">decision</span>
        <span class="k">return</span> <span class="n">UNREV</span>

<div class="viewcode-block" id="DynamicUpdate.on_between"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.DynamicUpdate.on_between">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">on_between</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">,</span>
                   <span class="n">merge_nid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback when a review is made between two PCCs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">action</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;between&#39;</span><span class="p">]</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">_update_neg_metagraph</span><span class="p">(</span>
            <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">,</span> <span class="n">merge_nid</span><span class="o">=</span><span class="n">merge_nid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">merge_nid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># A merge occurred</span>
            <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
                <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">merge_nid</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">set_node_attrs</span><span class="p">(</span><span class="s1">&#39;name_label&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="p">[</span><span class="n">merge_nid</span><span class="p">]))</span>
            <span class="c1"># FIXME: this state is ugly</span>
            <span class="n">action</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;merge&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">decision</span> <span class="o">==</span> <span class="n">NEGTV</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;neg-evidence&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">decision</span> <span class="o">==</span> <span class="n">INCMP</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;incomp-evidence&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;other-evidence&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">action</span></div>

<div class="viewcode-block" id="DynamicUpdate.on_within"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.DynamicUpdate.on_within">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">on_within</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">split_nids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback when a review is made inside a PCC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">action</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;within&#39;</span><span class="p">]</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">_update_neg_metagraph</span><span class="p">(</span>
            <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">split_nids</span><span class="o">=</span><span class="n">split_nids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">split_nids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># A split occurred</span>
            <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
                <span class="n">new_nid1</span><span class="p">,</span> <span class="n">new_nid2</span> <span class="o">=</span> <span class="n">split_nids</span>
                <span class="n">cc1</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">)</span>
                <span class="n">cc2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">new_nid2</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">set_node_attrs</span><span class="p">(</span><span class="s1">&#39;name_label&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">cc1</span><span class="p">,</span> <span class="p">[</span><span class="n">new_nid1</span><span class="p">]))</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">set_node_attrs</span><span class="p">(</span><span class="s1">&#39;name_label&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">cc2</span><span class="p">,</span> <span class="p">[</span><span class="n">new_nid2</span><span class="p">]))</span>
            <span class="n">action</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">decision</span> <span class="o">==</span> <span class="n">POSTV</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;pos-evidence&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">decision</span> <span class="o">==</span> <span class="n">INCMP</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;incomp-evidence&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">decision</span> <span class="o">==</span> <span class="n">NEGTV</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;neg-evidence&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;other-evidence&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">action</span></div>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_update_neg_metagraph</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">,</span>
                              <span class="n">merge_nid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">split_nids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the negative metagraph based a new review</span>

<span class="sd">        TODO:</span>
<span class="sd">            we can likely consolidate lots of neg_redun_metagraph</span>
<span class="sd">            functionality into this function. Just check when the</span>
<span class="sd">            weights are above or under the threshold and update</span>
<span class="sd">            accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nmg</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">neg_metagraph</span>

        <span class="k">if</span> <span class="n">decision</span> <span class="o">==</span> <span class="n">NEGTV</span> <span class="ow">and</span> <span class="n">prev_decision</span> <span class="o">!=</span> <span class="n">NEGTV</span><span class="p">:</span>
            <span class="c1"># New negative feedback. Add meta edge or increase weight</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nmg</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">):</span>
                <span class="n">nmg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nmg</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">decision</span> <span class="o">!=</span> <span class="n">NEGTV</span> <span class="ow">and</span> <span class="n">prev_decision</span> <span class="o">==</span> <span class="n">NEGTV</span><span class="p">:</span>
            <span class="c1"># Undid negative feedback. Remove meta edge or decrease weight.</span>
            <span class="n">nmg</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nmg</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nmg</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">merge_nid</span><span class="p">:</span>
            <span class="c1"># Combine the negative edges between the merged PCCS</span>
            <span class="k">assert</span> <span class="n">split_nids</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="c1"># Find external nids marked as negative</span>
            <span class="n">prev_edges</span> <span class="o">=</span> <span class="n">nmg</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">nbunch</span><span class="o">=</span><span class="p">[</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Map external neg edges onto new merged PCC</span>
            <span class="c1"># Accumulate weights between duplicate new name edges</span>
            <span class="n">lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">nid1</span><span class="p">:</span> <span class="n">merge_nid</span><span class="p">,</span> <span class="n">nid2</span><span class="p">:</span> <span class="n">merge_nid</span><span class="p">}</span>
            <span class="n">ne_accum</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">prev_edges</span><span class="p">:</span>
                <span class="n">new_ne</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">e_</span><span class="p">(</span><span class="n">lookup</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="n">lookup</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">new_ne</span> <span class="ow">in</span> <span class="n">ne_accum</span><span class="p">:</span>
                    <span class="n">ne_accum</span><span class="p">[</span><span class="n">new_ne</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ne_accum</span><span class="p">[</span><span class="n">new_ne</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">merged_edges</span> <span class="o">=</span> <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ne_accum</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

            <span class="n">nmg</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">([</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">])</span>
            <span class="n">nmg</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">merge_nid</span><span class="p">)</span>
            <span class="n">nmg</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">merged_edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">split_nids</span><span class="p">:</span>
            <span class="c1"># Splitup the negative edges between the split PCCS</span>
            <span class="k">assert</span> <span class="n">merge_nid</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">nid1</span> <span class="o">==</span> <span class="n">nid2</span>
            <span class="n">old_nid</span> <span class="o">=</span> <span class="n">nid1</span>

            <span class="c1"># Find the nodes we need to check against</span>
            <span class="n">extern_nids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nmg</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">old_nid</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">old_nid</span> <span class="ow">in</span> <span class="n">extern_nids</span><span class="p">:</span>
                <span class="n">extern_nids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">old_nid</span><span class="p">)</span>
                <span class="n">extern_nids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">split_nids</span><span class="p">)</span>

            <span class="c1"># Determine how to split existing negative edges between the split</span>
            <span class="c1"># by going back to the original negative graph.</span>
            <span class="n">split_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">new_nid</span> <span class="ow">in</span> <span class="n">split_nids</span><span class="p">:</span>
                <span class="n">cc1</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">new_nid</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">other_nid</span> <span class="ow">in</span> <span class="n">extern_nids</span><span class="p">:</span>
                    <span class="n">cc2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">other_nid</span><span class="p">)</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">edges_between</span><span class="p">(</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">neg_graph</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">,</span> <span class="n">assume_dense</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">num</span><span class="p">:</span>
                        <span class="n">split_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">new_nid</span><span class="p">,</span> <span class="n">other_nid</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">num</span><span class="p">}))</span>

            <span class="n">nmg</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">old_nid</span><span class="p">)</span>
            <span class="n">nmg</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">split_nids</span><span class="p">)</span>
            <span class="n">nmg</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">split_edges</span><span class="p">)</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_positive_decision</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logic for a dynamic positive decision.  A positive decision is evidence</span>
<span class="sd">        that two annots should be in the same PCC</span>

<span class="sd">        Note, this could be an incomparable edge, but with a meta_decision of</span>
<span class="sd">        same.</span>

<span class="sd">        Ignore:</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph.mixin_dynamic import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; kwargs = dict(num_pccs=3, p_incon=0, size=100)</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(infer=False, **kwargs)</span>
<span class="sd">            &gt;&gt;&gt; infr.apply_nondynamic_update()</span>
<span class="sd">            &gt;&gt;&gt; cc1 = next(infr.positive_components())</span>

<span class="sd">            %timeit list(infr.pos_graph.subgraph(cc1, dynamic=True).edges())</span>
<span class="sd">            %timeit list(infr.pos_graph.subgraph(cc1, dynamic=False).edges())</span>
<span class="sd">            %timeit list(nxu.edges_inside(infr.pos_graph, cc1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decision</span> <span class="o">=</span> <span class="n">POSTV</span>
        <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_labels</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">incon1</span><span class="p">,</span> <span class="n">incon2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">has_nodes</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">all_consistent</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">incon1</span> <span class="ow">or</span> <span class="n">incon2</span><span class="p">)</span>
        <span class="n">was_within</span> <span class="o">=</span> <span class="n">nid1</span> <span class="o">==</span> <span class="n">nid2</span>

        <span class="n">print_</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">prev_decision</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_get_current_decision</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">was_within</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">_add_review_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">all_consistent</span><span class="p">:</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;pos-within-clean&#39;</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">update_pos_redun</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;pos-within-dirty&#39;</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_check_inconsistency</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_within</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print_(&#39;Merge case&#39;)</span>
            <span class="n">cc1</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
            <span class="n">cc2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">all_consistent</span><span class="p">:</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;pos-between-dirty-merge&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">incon1</span><span class="p">:</span>
                    <span class="n">recover_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_inside</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="p">,</span> <span class="n">cc1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">recover_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_inside</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="p">,</span> <span class="n">cc2</span><span class="p">))</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">recover_edges</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_add_review_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
                <span class="n">new_nid</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_cross</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">neg_graph</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">)):</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;pos-between-clean-merge-dirty&#39;</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_add_review_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">)</span>
                <span class="n">new_nid</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_new_inconsistency</span><span class="p">(</span><span class="n">new_nid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;pos-between-clean-merge-clean&#39;</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_add_review_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">)</span>
                <span class="n">new_nid</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">update_extern_neg_redun</span><span class="p">(</span><span class="n">new_nid</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">update_pos_redun</span><span class="p">(</span><span class="n">new_nid</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_between</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">,</span>
                                     <span class="n">merge_nid</span><span class="o">=</span><span class="n">new_nid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">action</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_negative_decision</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logic for a dynamic negative decision.  A negative decision is evidence</span>
<span class="sd">        that two annots should not be in the same PCC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decision</span> <span class="o">=</span> <span class="n">NEGTV</span>
        <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">node_labels</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">incon1</span><span class="p">,</span> <span class="n">incon2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">has_nodes</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">all_consistent</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">incon1</span> <span class="ow">or</span> <span class="n">incon2</span><span class="p">)</span>
        <span class="n">prev_decision</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_get_current_decision</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">_add_review_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">)</span>
        <span class="n">new_nid1</span><span class="p">,</span> <span class="n">new_nid2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_labels</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>

        <span class="n">was_within</span> <span class="o">=</span> <span class="n">nid1</span> <span class="o">==</span> <span class="n">nid2</span>
        <span class="n">was_split</span> <span class="o">=</span> <span class="n">was_within</span> <span class="ow">and</span> <span class="n">new_nid1</span> <span class="o">!=</span> <span class="n">new_nid2</span>

        <span class="n">print_</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">was_within</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">was_split</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">all_consistent</span><span class="p">:</span>
                    <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;neg-within-split-clean&#39;</span><span class="p">)</span>
                    <span class="n">prev_neg_nids</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">update_neg_redun_to</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span> <span class="n">prev_neg_nids</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">update_neg_redun_to</span><span class="p">(</span><span class="n">new_nid2</span><span class="p">,</span> <span class="n">prev_neg_nids</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">update_neg_redun_to</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span> <span class="p">[</span><span class="n">new_nid2</span><span class="p">])</span>
                    <span class="c1"># infr.update_extern_neg_redun(new_nid1, may_remove=False)</span>
                    <span class="c1"># infr.update_extern_neg_redun(new_nid2, may_remove=False)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">update_pos_redun</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">update_pos_redun</span><span class="p">(</span><span class="n">new_nid2</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;neg-within-split-dirty&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">):</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">_purge_error_edges</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">_check_inconsistency</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">_check_inconsistency</span><span class="p">(</span><span class="n">new_nid2</span><span class="p">)</span>
                <span class="c1"># Signal that a split occurred</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_within</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span>
                                        <span class="n">split_nids</span><span class="o">=</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span> <span class="n">new_nid2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">all_consistent</span><span class="p">:</span>
                    <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;neg-within-clean&#39;</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">_new_inconsistency</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;neg-within-dirty&#39;</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">_check_inconsistency</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">)</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_within</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">new_nid1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">all_consistent</span><span class="p">:</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;neg-between-clean&#39;</span><span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">update_neg_redun_to</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span> <span class="p">[</span><span class="n">new_nid2</span><span class="p">],</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;neg-between-dirty&#39;</span><span class="p">)</span>
                <span class="c1"># nothing to do if a negative edge is added between two PCCs</span>
                <span class="c1"># where at least one is inconsistent</span>
                <span class="k">pass</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_between</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">new_nid1</span><span class="p">,</span>
                                     <span class="n">new_nid2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">action</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_uninferable_decision</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logic for a dynamic uninferable negative decision An uninferrable</span>
<span class="sd">        decision does not provide any evidence about PCC status and is either:</span>
<span class="sd">            incomparable, unreviewed, or unknown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_labels</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">incon1</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">incon2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">all_consistent</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">incon1</span> <span class="ow">or</span> <span class="n">incon2</span><span class="p">)</span>

        <span class="n">was_within</span> <span class="o">=</span> <span class="n">nid1</span> <span class="o">==</span> <span class="n">nid2</span>
        <span class="n">prev_decision</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_get_current_decision</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="n">print_</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="p">{</span><span class="n">INCMP</span><span class="p">:</span> <span class="s1">&#39;incmp&#39;</span><span class="p">,</span> <span class="n">UNREV</span><span class="p">:</span> <span class="s1">&#39;unrev&#39;</span><span class="p">,</span>
                      <span class="n">UNKWN</span><span class="p">:</span> <span class="s1">&#39;unkown&#39;</span><span class="p">}[</span><span class="n">decision</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;decision can only be UNREV, INCMP, or UNKWN&#39;</span><span class="p">)</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">_add_review_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">was_within</span><span class="p">:</span>
            <span class="n">new_nid1</span><span class="p">,</span> <span class="n">new_nid2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_labels</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prev_decision</span> <span class="o">==</span> <span class="n">POSTV</span><span class="p">:</span>
                <span class="c1"># changed an existing positive edge</span>
                <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">):</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
                <span class="n">was_split</span> <span class="o">=</span> <span class="n">new_nid1</span> <span class="o">!=</span> <span class="n">new_nid2</span>
                <span class="k">if</span> <span class="n">was_split</span><span class="p">:</span>
                    <span class="n">old_nid</span> <span class="o">=</span> <span class="n">nid1</span>
                    <span class="n">prev_neg_nids</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_purge_redun_flags</span><span class="p">(</span><span class="n">old_nid</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">all_consistent</span><span class="p">:</span>
                        <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-within-pos-split-clean&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">)</span>
                        <span class="c1"># split case</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">update_neg_redun_to</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span> <span class="n">prev_neg_nids</span><span class="p">)</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">update_neg_redun_to</span><span class="p">(</span><span class="n">new_nid2</span><span class="p">,</span> <span class="n">prev_neg_nids</span><span class="p">)</span>
                        <span class="c1"># for other_nid in prev_neg_nids:</span>
                        <span class="c1">#     infr.update_neg_redun_to(new_nid1, [other_nid])</span>
                        <span class="c1">#     infr.update_neg_redun_to(new_nid2, [other_nid])</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">update_neg_redun_to</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span> <span class="p">[</span><span class="n">new_nid2</span><span class="p">])</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">update_pos_redun</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">update_pos_redun</span><span class="p">(</span><span class="n">new_nid2</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-within-pos-split-dirty&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">):</span>
                            <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">_purge_error_edges</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">_check_inconsistency</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">)</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">_check_inconsistency</span><span class="p">(</span><span class="n">new_nid2</span><span class="p">)</span>
                    <span class="c1"># Signal that a split occurred</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_within</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span>
                                            <span class="n">nid1</span><span class="p">,</span> <span class="n">split_nids</span><span class="o">=</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span>
                                                              <span class="n">new_nid2</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">all_consistent</span><span class="p">:</span>
                        <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-within-pos-clean&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">)</span>
                        <span class="n">infr</span><span class="o">.</span><span class="n">update_pos_redun</span><span class="p">(</span><span class="n">new_nid1</span><span class="p">,</span> <span class="n">may_add</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-within-pos-dirty&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">)</span>
                        <span class="c1"># Overwriting a positive edge that is not a split</span>
                        <span class="c1"># in an inconsistent component, means no inference.</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_within</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span>
                                            <span class="n">new_nid1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">prev_decision</span> <span class="o">==</span> <span class="n">NEGTV</span><span class="p">:</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-within-neg-dirty&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">all_consistent</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_check_inconsistency</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_within</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span>
                                        <span class="n">new_nid1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">all_consistent</span><span class="p">:</span>
                    <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-within-clean&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-within-dirty&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">)</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_within</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev_decision</span> <span class="o">==</span> <span class="n">NEGTV</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">all_consistent</span><span class="p">:</span>
                    <span class="c1"># changed and existing negative edge only influences</span>
                    <span class="c1"># consistent pairs of PCCs</span>
                    <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;incon-between-neg-clean&#39;</span><span class="p">)</span>
                    <span class="n">infr</span><span class="o">.</span><span class="n">update_neg_redun_to</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="p">[</span><span class="n">nid2</span><span class="p">],</span> <span class="n">may_add</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;incon-between-neg-dirty&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;incon-between&#39;</span><span class="p">)</span>
                <span class="c1"># HACK, this sortof fixes inferred state not being set</span>
                <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">decision</span> <span class="o">==</span> <span class="n">INCMP</span><span class="p">:</span>
                        <span class="k">pass</span>
                        <span class="c1"># if not infr.is_neg_redundant(cc1, cc2, k=1):</span>
                        <span class="c1">#     # TODO: verify that there isn&#39;t a negative inferred</span>
                        <span class="c1">#     # state</span>
                        <span class="c1">#     infr.set_edge_attrs(</span>
                        <span class="c1">#         &#39;inferred_state&#39;, ut.dzip([edge], [INCMP])</span>
                        <span class="c1">#     )</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">on_between</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">prev_decision</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">action</span></div>


<div class="viewcode-block" id="Recovery"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Recovery">[docs]</a><span class="k">class</span> <span class="nc">Recovery</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; recovery funcs &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Recovery.is_recovering"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Recovery.is_recovering">[docs]</a>    <span class="k">def</span> <span class="nf">is_recovering</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks to see if the graph is inconsinsistent.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge (None): If None, then returns True if the graph contains any</span>
<span class="sd">                inconsistency. Otherwise, returns True if the edge is related</span>
<span class="sd">                to an inconsistent component via a positive or negative</span>
<span class="sd">                connection.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: flag</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m ibeis.algo.graph.mixin_dynamic is_recovering</span>

<span class="sd">        Doctest:</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph.mixin_dynamic import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(num_pccs=4, size=4, ignore_pair=True)</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_cliques(meta_decision=SAME)</span>
<span class="sd">            &gt;&gt;&gt; a, b, c, d = map(list, infr.positive_components())</span>
<span class="sd">            &gt;&gt;&gt; assert infr.is_recovering() is False</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((a[0], a[1]), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; assert infr.is_recovering() is True</span>
<span class="sd">            &gt;&gt;&gt; assert infr.is_recovering((a[2], a[3])) is True</span>
<span class="sd">            &gt;&gt;&gt; assert infr.is_recovering((a[3], b[0])) is True</span>
<span class="sd">            &gt;&gt;&gt; assert infr.is_recovering((b[0], b[1])) is False</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((a[3], b[2]), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; assert infr.is_recovering((b[0], b[1])) is True</span>
<span class="sd">            &gt;&gt;&gt; assert infr.is_recovering((c[0], d[0])) is False</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((b[2], c[0]), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; assert infr.is_recovering((c[0], d[0])) is False</span>
<span class="sd">            &gt;&gt;&gt; result = ut.repr4({</span>
<span class="sd">            &gt;&gt;&gt;     &#39;pccs&#39;: sorted(list(infr.positive_components())),</span>
<span class="sd">            &gt;&gt;&gt;     &#39;iccs&#39;: sorted(list(infr.inconsistent_components())),</span>
<span class="sd">            &gt;&gt;&gt; }, nobr=True, si=True, itemsep=&#39;&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(result)</span>
<span class="sd">            iccs: [{1,2,3,4}],</span>
<span class="sd">            pccs: [{5,6,7,8},{9,10,11,12},{13,14,15,16},{1,2,3,4}],</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># We can short-circuit if there is no inconsistency</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># By the short circuit we know the graph is inconsistent</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">node_labels</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)):</span>
            <span class="c1"># Is this edge part of a CC that has an error?</span>
            <span class="k">if</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">nid_to_errors</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="c1"># Is this edge connected to a CC that has an error?</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">find_neg_nids_to</span><span class="p">(</span><span class="n">cc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">nid_to_errors</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># If none of these conditions are true we are far enough away from the</span>
        <span class="c1"># inconsistency to ignore it.</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_purge_error_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all error edges associated with a PCC so they can be recomputed</span>
<span class="sd">        or resolved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_error_edges</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">nid_to_errors</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="p">[])</span>
        <span class="c1"># Remove priority from old error edges</span>
        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="s1">&#39;maybe_error&#39;</span><span class="p">,</span>
                                <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">old_error_edges</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]))</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">_remove_edge_priority</span><span class="p">(</span><span class="n">old_error_edges</span><span class="p">)</span>
        <span class="n">was_clean</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_error_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">was_clean</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_set_error_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">new_error_edges</span><span class="p">):</span>
        <span class="c1"># flag error edges</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">nid_to_errors</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_error_edges</span>
        <span class="c1"># choose one and give it insanely high priority</span>
        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span><span class="s1">&#39;maybe_error&#39;</span><span class="p">,</span>
                                <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">new_error_edges</span><span class="p">,</span> <span class="p">[</span><span class="kc">True</span><span class="p">]))</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">_increase_priority</span><span class="p">(</span><span class="n">new_error_edges</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<div class="viewcode-block" id="Recovery.maybe_error_edges"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Recovery.maybe_error_edges">[docs]</a>    <span class="k">def</span> <span class="nf">maybe_error_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ut</span><span class="o">.</span><span class="n">iflatten</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">nid_to_errors</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_new_inconsistency</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid</span><span class="p">):</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
        <span class="n">pos_edges</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">pos_edges</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">number_of_components</span><span class="p">()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;New inconsistency </span><span class="si">{}</span><span class="s1"> total&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">_check_inconsistency</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">cc</span><span class="o">=</span><span class="n">cc</span><span class="p">)</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_check_inconsistency</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">cc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if a PCC contains an error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
        <span class="n">was_clean</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_purge_error_edges</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
        <span class="n">neg_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_inside</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">neg_graph</span><span class="p">,</span> <span class="n">cc</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">neg_edges</span><span class="p">:</span>
            <span class="n">pos_subgraph_</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">pos_subgraph_</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cc = </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cc</span><span class="p">,))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pos_subgraph_ = </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos_subgraph_</span><span class="p">,))</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;must be connected&#39;</span><span class="p">)</span>
            <span class="n">hypothesis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">hypothesis_errors</span><span class="p">(</span><span class="n">pos_subgraph_</span><span class="p">,</span> <span class="n">neg_edges</span><span class="p">))</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;must have at least one&#39;</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">_set_error_edges</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">hypothesis</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">is_clean</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">number_of_components</span><span class="p">()</span>
            <span class="c1"># num = len(list(nx.connected_components(infr.recover_graph)))</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;An inconsistent PCC recovered, &#39;</span>
                   <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> inconsistent PCC(s) remain&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">update_pos_redun</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">update_extern_neg_redun</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">is_clean</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">was_clean</span><span class="p">,</span> <span class="n">is_clean</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_mincut_edge_weights</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges_</span><span class="p">):</span>
        <span class="n">conf_gen</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">gen_edge_values</span><span class="p">(</span><span class="s1">&#39;confidence&#39;</span><span class="p">,</span> <span class="n">edges_</span><span class="p">,</span>
                                        <span class="n">default</span><span class="o">=</span><span class="s1">&#39;unspecified&#39;</span><span class="p">)</span>
        <span class="n">conf_gen</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;unspecified&#39;</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">conf_gen</span><span class="p">]</span>
        <span class="n">code_to_conf</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">CONFIDENCE</span><span class="o">.</span><span class="n">CODE_TO_INT</span>
        <span class="n">code_to_conf</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;absolutely_sure&#39;</span> <span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span>
            <span class="s1">&#39;pretty_sure&#39;</span>     <span class="p">:</span> <span class="mf">0.6</span><span class="p">,</span>
            <span class="s1">&#39;not_sure&#39;</span>        <span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>
            <span class="s1">&#39;guessing&#39;</span>        <span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="s1">&#39;unspecified&#39;</span>     <span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">confs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">code_to_conf</span><span class="p">,</span> <span class="n">conf_gen</span><span class="p">))</span>
        <span class="c1"># confs = np.array([0 if c is None else c for c in confs])</span>

        <span class="n">prob_gen</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">gen_edge_values</span><span class="p">(</span><span class="s1">&#39;prob_match&#39;</span><span class="p">,</span> <span class="n">edges_</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">prob_gen</span><span class="p">))</span>

        <span class="n">nrev_gen</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">gen_edge_values</span><span class="p">(</span><span class="s1">&#39;num_reviews&#39;</span><span class="p">,</span> <span class="n">edges_</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nrev_gen</span><span class="p">))</span>

        <span class="n">weight</span> <span class="o">=</span> <span class="n">nrev</span> <span class="o">+</span> <span class="n">probs</span> <span class="o">+</span> <span class="n">confs</span>
        <span class="k">return</span> <span class="n">weight</span>

<div class="viewcode-block" id="Recovery.hypothesis_errors"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Recovery.hypothesis_errors">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">hypothesis_errors</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">pos_subgraph</span><span class="p">,</span> <span class="n">neg_edges</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Not connected&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="p">))</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
            <span class="s1">&#39;Find hypothesis errors in </span><span class="si">{}</span><span class="s1"> nodes with </span><span class="si">{}</span><span class="s1"> neg edges&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_edges</span><span class="p">)),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">pos_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

        <span class="n">neg_weight</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_mincut_edge_weights</span><span class="p">(</span><span class="n">neg_edges</span><span class="p">)</span>
        <span class="n">pos_weight</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_mincut_edge_weights</span><span class="p">(</span><span class="n">pos_edges</span><span class="p">)</span>

        <span class="n">capacity</span> <span class="o">=</span> <span class="s1">&#39;weight&#39;</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">capacity</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">pos_edges</span><span class="p">,</span> <span class="n">pos_weight</span><span class="p">))</span>

        <span class="c1"># Solve a multicut problem for multiple pairs of terminal nodes.</span>
        <span class="c1"># Running multiple min-cuts produces a k-factor approximation</span>
        <span class="n">maybe_error_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">join_weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">neg_edges</span><span class="p">,</span> <span class="n">neg_weight</span><span class="p">):</span>
            <span class="n">cut_weight</span><span class="p">,</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_cut</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                               <span class="n">capacity</span><span class="o">=</span><span class="n">capacity</span><span class="p">)</span>
            <span class="n">cut_edgeset</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">edges_cross</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="p">,</span> <span class="o">*</span><span class="n">parts</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">join_weight</span> <span class="o">&lt;</span> <span class="n">cut_weight</span><span class="p">:</span>
                <span class="n">join_edgeset</span> <span class="o">=</span> <span class="p">{(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)}</span>
                <span class="n">chosen</span> <span class="o">=</span> <span class="n">join_edgeset</span>
                <span class="n">hypothesis</span> <span class="o">=</span> <span class="n">POSTV</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chosen</span> <span class="o">=</span> <span class="n">cut_edgeset</span>
                <span class="n">hypothesis</span> <span class="o">=</span> <span class="n">NEGTV</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">chosen</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">maybe_error_edges</span><span class="p">:</span>
                    <span class="n">maybe_error_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Consistency"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Consistency">[docs]</a><span class="k">class</span> <span class="nc">Consistency</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="Consistency.is_consistent"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Consistency.is_consistent">[docs]</a>    <span class="k">def</span> <span class="nf">is_consistent</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">cc</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if a PCC contains inconsistencies</span>

<span class="sd">        Args:</span>
<span class="sd">            cc (set): nodes in a PCC</span>

<span class="sd">        Returns:</span>
<span class="sd">            flag: bool: returns True unless cc contains any negative edges</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(num_pccs=1, p_incon=1)</span>
<span class="sd">            &gt;&gt;&gt; assert not infr.is_consistent(next(infr.positive_components()))</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(num_pccs=1, p_incon=0)</span>
<span class="sd">            &gt;&gt;&gt; assert infr.is_consistent(next(infr.positive_components()))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_inside</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">neg_graph</span><span class="p">,</span> <span class="n">cc</span><span class="p">))</span></div>

<div class="viewcode-block" id="Consistency.positive_components"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Consistency.positive_components">[docs]</a>    <span class="k">def</span> <span class="nf">positive_components</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the positive connected compoments (PCCs) in the graph</span>
<span class="sd">        These will contain both consistent and inconsinstent PCCs.</span>

<span class="sd">        Yields:</span>
<span class="sd">            cc: set: nodes within the PCC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_graph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span>
        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">graph</span> <span class="ow">is</span> <span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
            <span class="n">ccs</span> <span class="o">=</span> <span class="n">pos_graph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unique_labels</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
            <span class="n">ccs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">connected_to</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">cc</span></div>

<div class="viewcode-block" id="Consistency.inconsistent_components"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Consistency.inconsistent_components">[docs]</a>    <span class="k">def</span> <span class="nf">inconsistent_components</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates inconsistent PCCs.</span>
<span class="sd">        These PCCs contain internal negative edges indicating an error exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">positive_components</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_consistent</span><span class="p">(</span><span class="n">cc</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">cc</span></div>

<div class="viewcode-block" id="Consistency.consistent_components"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Consistency.consistent_components">[docs]</a>    <span class="k">def</span> <span class="nf">consistent_components</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates consistent PCCs.</span>
<span class="sd">        These PCCs contain no internal negative edges.</span>

<span class="sd">        Yields:</span>
<span class="sd">            cc: set: nodes within the PCC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find PCCs without any negative edges</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">positive_components</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_consistent</span><span class="p">(</span><span class="n">cc</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">cc</span></div></div>


<span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">ReloadingMetaclass</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_RedundancyComputers</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    methods for computing redundancy</span>

<span class="sd">    These are used to compute redundancy bookkeeping structures.</span>
<span class="sd">    Thus, they should not use them in their calculations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># def pos_redundancy(infr, cc):</span>
    <span class="c1">#     &quot;&quot;&quot; Returns how positive redundant a cc is &quot;&quot;&quot;</span>
    <span class="c1">#     pos_subgraph = infr.pos_graph.subgraph(cc, dynamic=False)</span>
    <span class="c1">#     if nxu.is_complete(pos_subgraph):</span>
    <span class="c1">#         return np.inf</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         return nx.edge_connectivity(pos_subgraph)</span>

    <span class="c1"># def neg_redundancy(infr, cc1, cc2):</span>
    <span class="c1">#     &quot;&quot;&quot; Returns how negative redundant a cc is &quot;&quot;&quot;</span>
    <span class="c1">#     neg_edge_gen = nxu.edges_cross(infr.neg_graph, cc1, cc2)</span>
    <span class="c1">#     num_neg = len(list(neg_edge_gen))</span>
    <span class="c1">#     if num_neg == len(cc1) or num_neg == len(cc2):</span>
    <span class="c1">#         return np.inf</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         return num_neg</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">is_pos_redundant</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assume_connected</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests if a group of nodes is positive redundant.</span>
<span class="sd">        (ie. if the group is k-edge-connected)</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph.mixin_dynamic import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.make_demo_infr(ccs=[(1, 2, 3, 4, 5)])</span>
<span class="sd">            &gt;&gt;&gt; infr.params[&#39;redun.pos&#39;] = 2</span>
<span class="sd">            &gt;&gt;&gt; cc = infr.pos_graph.connected_to(1)</span>
<span class="sd">            &gt;&gt;&gt; flag1 = infr.is_pos_redundant(cc)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((1, 5), POSTV)</span>
<span class="sd">            &gt;&gt;&gt; flag2 = infr.is_pos_redundant(cc)</span>
<span class="sd">            &gt;&gt;&gt; flags = [flag1, flag2]</span>
<span class="sd">            &gt;&gt;&gt; print(&#39;flags = %r&#39; % (flags,))</span>
<span class="sd">            &gt;&gt;&gt; assert flags == [False, True]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.pos&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">assume_connected</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># assumes cc is connected</span>
        <span class="k">if</span> <span class="n">relax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">relax</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">pos_subgraph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">relax</span><span class="p">:</span>
            <span class="c1"># If we cannot add any more edges to the subgraph then we consider</span>
            <span class="c1"># it positive redundant.</span>
            <span class="n">n_incomp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">edges_inside</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">incomp_graph</span><span class="p">,</span> <span class="n">cc</span><span class="p">))</span>
            <span class="n">n_pos</span> <span class="o">=</span> <span class="n">pos_subgraph</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="n">pos_subgraph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="n">n_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_nodes</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">n_max</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_pos</span> <span class="o">+</span> <span class="n">n_incomp</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># In all other cases test edge-connectivity</span>
        <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">is_k_edge_connected</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">is_neg_redundant</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests if two disjoint groups of nodes are negative redundant</span>
<span class="sd">        (ie. have at least k negative edges between them).</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph.mixin_dynamic import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.make_demo_infr(ccs=[(1, 2), (3, 4)])</span>
<span class="sd">            &gt;&gt;&gt; infr.params[&#39;redun.neg&#39;] = 2</span>
<span class="sd">            &gt;&gt;&gt; cc1 = infr.pos_graph.connected_to(1)</span>
<span class="sd">            &gt;&gt;&gt; cc2 = infr.pos_graph.connected_to(3)</span>
<span class="sd">            &gt;&gt;&gt; flag1 = infr.is_neg_redundant(cc1, cc2)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((1, 3), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; flag2 = infr.is_neg_redundant(cc1, cc2)</span>
<span class="sd">            &gt;&gt;&gt; infr.add_feedback((2, 4), NEGTV)</span>
<span class="sd">            &gt;&gt;&gt; flag3 = infr.is_neg_redundant(cc1, cc2)</span>
<span class="sd">            &gt;&gt;&gt; flags = [flag1, flag2, flag3]</span>
<span class="sd">            &gt;&gt;&gt; print(&#39;flags = %r&#39; % (flags,))</span>
<span class="sd">            &gt;&gt;&gt; assert flags == [False, False, True]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.neg&#39;</span><span class="p">]</span>
        <span class="n">neg_edge_gen</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">edges_cross</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">neg_graph</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">)</span>
        <span class="c1"># do a lazy count of negative edges</span>
        <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neg_edge_gen</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">find_neg_nids_to</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">cc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the nids with at least one negative edge external</span>
<span class="sd">        to this cc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_graph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span>
        <span class="n">neg_graph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">neg_graph</span>
        <span class="n">out_neg_nids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
            <span class="n">nid1</span> <span class="o">=</span> <span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neg_graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="n">nid2</span> <span class="o">=</span> <span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nid1</span> <span class="o">==</span> <span class="n">nid2</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">out_neg_nids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_neg_nids</span>

    <span class="k">def</span> <span class="nf">find_neg_nid_freq_to</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">cc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the number of edges leaving `cc` and directed towards specific</span>
<span class="sd">        names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_graph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span>
        <span class="n">neg_graph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">neg_graph</span>
        <span class="n">neg_nid_freq</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
            <span class="n">nid1</span> <span class="o">=</span> <span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neg_graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="n">nid2</span> <span class="o">=</span> <span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nid1</span> <span class="o">==</span> <span class="n">nid2</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">neg_nid_freq</span><span class="p">[</span><span class="n">nid2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">neg_nid_freq</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">find_neg_redun_nids_to</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">cc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get PCCs that are k-negative redundant with `cc`</span>

<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph.mixin_dynamic import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">            &gt;&gt;&gt; pt.qtensure()</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr2()</span>
<span class="sd">            &gt;&gt;&gt; node = 20</span>
<span class="sd">            &gt;&gt;&gt; cc = infr.pos_graph.connected_to(node)</span>
<span class="sd">            &gt;&gt;&gt; infr.params[&#39;redun.neg&#39;] = 2</span>
<span class="sd">            &gt;&gt;&gt; infr.find_neg_redun_nids_to(cc)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neg_nid_freq</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">find_neg_nid_freq_to</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
        <span class="c1"># check for k-negative redundancy</span>
        <span class="n">k_neg</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.neg&#39;</span><span class="p">]</span>
        <span class="n">pos_graph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span>
        <span class="n">neg_nids</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">nid2</span> <span class="k">for</span> <span class="n">nid2</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">neg_nid_freq</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">k_neg</span> <span class="ow">or</span>
                <span class="n">freq</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">freq</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">connected_to</span><span class="p">(</span><span class="n">nid2</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">neg_nids</span>

    <span class="k">def</span> <span class="nf">find_pos_redundant_pccs</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.pos&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">consistent_components</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_pos_redundant</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">relax</span><span class="o">=</span><span class="n">relax</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">cc</span>

    <span class="k">def</span> <span class="nf">find_non_pos_redundant_pccs</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get PCCs that are not k-positive-redundant</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.pos&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">consistent_components</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_pos_redundant</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">relax</span><span class="o">=</span><span class="n">relax</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">cc</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">find_non_neg_redun_pccs</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get pairs of PCCs that are not complete.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph.mixin_matching import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(pcc_sizes=[1, 1, 2, 3, 5, 8], ignore_pair=True)</span>
<span class="sd">            &gt;&gt;&gt; non_neg_pccs = list(infr.find_non_neg_redun_pccs(k=2))</span>
<span class="sd">            &gt;&gt;&gt; assert len(non_neg_pccs) == (6 * 5) / 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.neg&#39;</span><span class="p">]</span>
        <span class="c1"># need to ensure pccs is static in case new user input is added</span>
        <span class="n">pccs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">positive_components</span><span class="p">())</span>
        <span class="c1"># Loop through all pairs</span>
        <span class="k">for</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">pccs</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_neg_redundant</span><span class="p">(</span><span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span>

    <span class="k">def</span> <span class="nf">find_pos_redun_nids</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; recomputes infr.pos_redun_nids &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">find_pos_redundant_pccs</span><span class="p">():</span>
            <span class="n">node</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">nid</span>

    <span class="k">def</span> <span class="nf">find_neg_redun_nids</span><span class="p">(</span><span class="n">infr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; recomputes edges in infr.neg_redun_metagraph &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">consistent_components</span><span class="p">():</span>
            <span class="n">node</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span>
            <span class="n">nid1</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">node_label</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">find_neg_redun_nids_to</span><span class="p">(</span><span class="n">cc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nid1</span> <span class="o">&lt;</span> <span class="n">nid2</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span>


<div class="viewcode-block" id="Redundancy"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Redundancy">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">ReloadingMetaclass</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Redundancy</span><span class="p">(</span><span class="n">_RedundancyComputers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; methods for dynamic redundancy book-keeping &quot;&quot;&quot;</span>

    <span class="c1"># def pos_redun_edge_flag(infr, edge):</span>
    <span class="c1">#     &quot;&quot;&quot; Quickly check if edge is flagged as pos redundant &quot;&quot;&quot;</span>
    <span class="c1">#     nid1, nid2 = infr.pos_graph.node_labels(*edge)</span>
    <span class="c1">#     return nid1 == nid2 and nid1 in infr.pos_redun_nids</span>

    <span class="c1"># def neg_redun_edge_flag(infr, edge):</span>
    <span class="c1">#     &quot;&quot;&quot; Quickly check if edge is flagged as neg redundant &quot;&quot;&quot;</span>
    <span class="c1">#     nid1, nid2 = infr.pos_graph.node_labels(*edge)</span>
    <span class="c1">#     return infr.neg_redun_metagraph.has_edge(nid1, nid2)</span>

<div class="viewcode-block" id="Redundancy.is_flagged_as_redun"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Redundancy.is_flagged_as_redun">[docs]</a>    <span class="k">def</span> <span class="nf">is_flagged_as_redun</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests redundancy against bookkeeping structure against cache</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nidu</span><span class="p">,</span> <span class="n">nidv</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">node_labels</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nidu</span> <span class="o">==</span> <span class="n">nidv</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nidu</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_redun_nids</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">nidu</span> <span class="o">!=</span> <span class="n">nidv</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">neg_redun_metagraph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">nidu</span><span class="p">,</span> <span class="n">nidv</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Redundancy.filter_edges_flagged_as_redun"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Redundancy.filter_edges_flagged_as_redun">[docs]</a>    <span class="k">def</span> <span class="nf">filter_edges_flagged_as_redun</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns only edges that are not flagged as redundant.</span>
<span class="sd">        Uses bookkeeping structures</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph.mixin_dynamic import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(num_pccs=1, size=4)</span>
<span class="sd">            &gt;&gt;&gt; infr.clear_edges()</span>
<span class="sd">            &gt;&gt;&gt; infr.ensure_cliques()</span>
<span class="sd">            &gt;&gt;&gt; infr.clear_feedback()</span>
<span class="sd">            &gt;&gt;&gt; print(ut.repr4(infr.status()))</span>
<span class="sd">            &gt;&gt;&gt; nonredun_edges = list(infr.filter_edges_flagged_as_redun(</span>
<span class="sd">            &gt;&gt;&gt;     infr.unreviewed_graph.edges()))</span>
<span class="sd">            &gt;&gt;&gt; assert len(nonredun_edges) == 6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_flagged_as_redun</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">edge</span></div>

<div class="viewcode-block" id="Redundancy.update_extern_neg_redun"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Redundancy.update_extern_neg_redun">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">update_extern_neg_redun</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">may_add</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if `nid` is negative redundant to any other `cc` it has at least</span>
<span class="sd">        one negative review to.</span>
<span class="sd">        (TODO: NEG REDUN CAN BE CONSOLIDATED VIA NEG-META-GRAPH)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.enabled&#39;</span><span class="p">]:</span>
            <span class="k">return</span>
        <span class="c1"># infr.print(&#39;neg_redun external update nid={}&#39;.format(nid), 5)</span>
        <span class="n">k_neg</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.neg&#39;</span><span class="p">]</span>
        <span class="n">cc1</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
        <span class="n">force</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
            <span class="c1"># TODO: non-force versions</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">find_neg_nid_freq_to</span><span class="p">(</span><span class="n">cc1</span><span class="p">)</span>
            <span class="n">other_nids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">other_nid</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">freqs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">k_neg</span><span class="p">:</span>
                    <span class="n">other_nids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other_nid</span><span class="p">)</span>
                    <span class="n">flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">may_remove</span><span class="p">:</span>
                    <span class="n">other_nids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other_nid</span><span class="p">)</span>
                    <span class="n">flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_nids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">_set_neg_redun_flags</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">other_nids</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;neg_redun skip update nid=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nid</span><span class="p">,),</span> <span class="mi">6</span><span class="p">)</span></div>

<div class="viewcode-block" id="Redundancy.update_neg_redun_to"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Redundancy.update_neg_redun_to">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">update_neg_redun_to</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">other_nids</span><span class="p">,</span> <span class="n">may_add</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if nid1 is neg redundant to other_nids.</span>
<span class="sd">        Edges are either removed or added to the queue appropriately.</span>
<span class="sd">        (TODO: NEG REDUN CAN BE CONSOLIDATED VIA NEG-META-GRAPH)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.enabled&#39;</span><span class="p">]:</span>
            <span class="k">return</span>
        <span class="c1"># infr.print(&#39;update_neg_redun_to&#39;, 5)</span>
        <span class="n">force</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">cc1</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;implement non-forced version&#39;</span><span class="p">)</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">other_nids</span><span class="p">:</span>
            <span class="n">cc2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
            <span class="n">need_add</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_neg_redundant</span><span class="p">(</span><span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">)</span>
            <span class="n">flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">need_add</span><span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">_set_neg_redun_flags</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">other_nids</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span></div>

<div class="viewcode-block" id="Redundancy.update_pos_redun"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.Redundancy.update_pos_redun">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">update_pos_redun</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">may_add</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">may_remove</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a PCC is newly, or no longer positive redundant.</span>
<span class="sd">        Edges are either removed or added to the queue appropriately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.enabled&#39;</span><span class="p">]:</span>
            <span class="k">return</span>

        <span class="c1"># force = True</span>
        <span class="c1"># infr.print(&#39;update_pos_redun&#39;)</span>
        <span class="n">need_add</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">need_remove</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
            <span class="n">need_add</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_pos_redundant</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">need_remove</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">need_add</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">was_pos_redun</span> <span class="o">=</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_redun_nids</span>
            <span class="k">if</span> <span class="n">may_add</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">was_pos_redun</span><span class="p">:</span>
                <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
                <span class="n">need_add</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_pos_redundant</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">may_remove</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">was_pos_redun</span><span class="p">:</span>
                <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
                <span class="n">need_remove</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">is_pos_redundant</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">need_add</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">_set_pos_redun_flag</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">need_remove</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">_set_pos_redun_flag</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;pos_redun skip update nid=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nid</span><span class="p">,),</span> <span class="mi">6</span><span class="p">)</span></div>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_set_pos_redun_flag</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flags or unflags an nid as positive redundant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">was_pos_redun</span> <span class="o">=</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_redun_nids</span>
        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">was_pos_redun</span><span class="p">:</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;pos_redun flag=T nid=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nid</span><span class="p">,),</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;pos_redun flag=T nid=</span><span class="si">%r</span><span class="s1"> (already done)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nid</span><span class="p">,),</span> <span class="mi">6</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">pos_redun_nids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">remove_internal_priority</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
                    <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span>
                    <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_inside</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">cc</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;same&#39;</span><span class="p">])</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">was_pos_redun</span><span class="p">:</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;pos_redun flag=F nid=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nid</span><span class="p">,),</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;pos_redun flag=F nid=</span><span class="si">%r</span><span class="s1"> (already done)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nid</span><span class="p">,),</span> <span class="mi">6</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">pos_redun_nids</span> <span class="o">-=</span> <span class="p">{</span><span class="n">nid</span><span class="p">}</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">reinstate_internal_priority</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
                    <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span>
                    <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_inside</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">cc</span><span class="p">),</span> <span class="p">[</span><span class="kc">None</span><span class="p">])</span>
                <span class="p">)</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_set_neg_redun_flags</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">other_nids</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flags or unflags an nid1 as negative redundant with other nids.</span>
<span class="sd">        (TODO: NEG REDUN CAN BE CONSOLIDATED VIA NEG-META-GRAPH)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">needs_unflag</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">needs_flag</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">already_flagged</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">already_unflagged</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cc1</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid1</span><span class="p">)</span>
        <span class="n">other_nids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other_nids</span><span class="p">)</span>

        <span class="c1"># Determine what needs what</span>
        <span class="k">for</span> <span class="n">nid2</span><span class="p">,</span> <span class="n">flag</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other_nids</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
            <span class="n">was_neg_redun</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">neg_redun_metagraph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">was_neg_redun</span><span class="p">:</span>
                    <span class="n">needs_flag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">already_flagged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">was_neg_redun</span><span class="p">:</span>
                    <span class="n">needs_unflag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">already_unflagged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>

        <span class="c1"># Print summary of what will be done</span>
        <span class="k">def</span> <span class="nf">_print_helper</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">others</span><span class="p">,</span> <span class="n">already</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">n_other_thresh</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_other_thresh</span><span class="p">:</span>
                <span class="n">omsg</span> <span class="o">=</span> <span class="s1">&#39;#others=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">omsg</span> <span class="o">=</span> <span class="s1">&#39;others=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">others</span><span class="p">)</span>
            <span class="n">amsg</span> <span class="o">=</span> <span class="s1">&#39;(already done)&#39;</span> <span class="k">if</span> <span class="n">already</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> nid=</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">omsg</span><span class="p">,</span> <span class="n">amsg</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">already</span><span class="p">)</span>

        <span class="n">_print_helper</span><span class="p">(</span><span class="s1">&#39;neg_redun flag=T&#39;</span><span class="p">,</span> <span class="n">needs_flag</span><span class="p">)</span>
        <span class="n">_print_helper</span><span class="p">(</span><span class="s1">&#39;neg_redun flag=T&#39;</span><span class="p">,</span> <span class="n">already_flagged</span><span class="p">,</span> <span class="n">already</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_print_helper</span><span class="p">(</span><span class="s1">&#39;neg_redun flag=F&#39;</span><span class="p">,</span> <span class="n">needs_unflag</span><span class="p">)</span>
        <span class="n">_print_helper</span><span class="p">(</span><span class="s1">&#39;neg_redun flag=F&#39;</span><span class="p">,</span> <span class="n">already_unflagged</span><span class="p">,</span> <span class="n">already</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Do the flagging/unflagging</span>
        <span class="k">for</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">needs_flag</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">neg_redun_metagraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">needs_unflag</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">neg_redun_metagraph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)</span>

        <span class="c1"># Update priorities and attributes</span>
        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">infr</span><span class="o">.</span><span class="n">queue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_flagged_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Unprioritize all edges between flagged nids</span>
            <span class="k">for</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">needs_flag</span><span class="p">,</span> <span class="n">already_flagged</span><span class="p">):</span>
                <span class="n">cc2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
                <span class="n">all_flagged_edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_cross</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">queue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
            <span class="n">all_unflagged_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">unrev_unflagged_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">unrev_graph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">unreviewed_graph</span>
            <span class="c1"># Reprioritize unreviewed edges between unflagged nids</span>
            <span class="c1"># Marked inferred state of all edges</span>
            <span class="k">for</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">needs_unflag</span><span class="p">,</span> <span class="n">already_unflagged</span><span class="p">):</span>
                <span class="n">cc2</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">nid2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">queue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">_edges</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">edges_cross</span><span class="p">(</span><span class="n">unrev_graph</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">)</span>
                    <span class="n">unrev_unflagged_edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_edges</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
                    <span class="n">_edges</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">edges_cross</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">)</span>
                    <span class="n">all_unflagged_edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_edges</span><span class="p">)</span>

            <span class="c1"># Batch set prioritize</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">_remove_edge_priority</span><span class="p">(</span><span class="n">all_flagged_edges</span><span class="p">)</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">_reinstate_edge_priority</span><span class="p">(</span><span class="n">unrev_unflagged_edges</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inference.update_attrs&#39;</span><span class="p">]:</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
                    <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">all_flagged_edges</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;diff&#39;</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
                    <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">all_unflagged_edges</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">])</span>
                <span class="p">)</span>

    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">_purge_redun_flags</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">nid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes positive and negative redundancy from nids and all other PCCs</span>
<span class="sd">        touching nids respectively. Return the external PCC nids.</span>

<span class="sd">        (TODO: NEG REDUN CAN BE CONSOLIDATED VIA NEG-META-GRAPH)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">infr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;redun.enabled&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">infr</span><span class="o">.</span><span class="n">neg_redun_metagraph</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">nid</span><span class="p">):</span>
            <span class="n">prev_neg_nids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">neg_redun_metagraph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">nid</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev_neg_nids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># infr.print(&#39;_purge, nid=%r, prev_neg_nids = %r&#39; % (nid, prev_neg_nids,))</span>
        <span class="c1"># for other_nid in prev_neg_nids:</span>
        <span class="c1">#     flag = False</span>
        <span class="c1">#     if other_nid not in infr.pos_graph._ccs:</span>
        <span class="c1">#         flag = True</span>
        <span class="c1">#         infr.print(&#39;!!nid=%r did not update&#39; % (other_nid,))</span>
        <span class="c1">#     if flag:</span>
        <span class="c1">#         assert flag, &#39;nids not maintained&#39;</span>
        <span class="k">for</span> <span class="n">other_nid</span> <span class="ow">in</span> <span class="n">prev_neg_nids</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">_set_neg_redun_flags</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="p">[</span><span class="n">other_nid</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_redun_nids</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">_set_pos_redun_flag</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prev_neg_nids</span></div>


<div class="viewcode-block" id="NonDynamicUpdate"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.NonDynamicUpdate">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">ReloadingMetaclass</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">NonDynamicUpdate</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<div class="viewcode-block" id="NonDynamicUpdate.apply_nondynamic_update"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.NonDynamicUpdate.apply_nondynamic_update">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">apply_nondynamic_update</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recomputes all dynamic bookkeeping for a graph in any state.</span>
<span class="sd">        This ensures that subsequent dyanmic inference can be applied.</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m ibeis.algo.graph.mixin_dynamic apply_nondynamic_update</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph.mixin_dynamic import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; num_pccs = 250</span>
<span class="sd">            &gt;&gt;&gt; kwargs = dict(num_pccs=100, p_incon=.3)</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(infer=False, **kwargs)</span>
<span class="sd">            &gt;&gt;&gt; graph = None</span>
<span class="sd">            &gt;&gt;&gt; infr.apply_nondynamic_update()</span>
<span class="sd">            &gt;&gt;&gt; infr.assert_neg_metagraph()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cluster edges by category</span>
        <span class="n">ne_to_edges</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">collapsed_meta_edges</span><span class="p">()</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">categorize_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ne_to_edges</span><span class="p">)</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
            <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">categories</span><span class="p">[</span><span class="n">POSTV</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="p">[</span><span class="s1">&#39;same&#39;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
            <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">categories</span><span class="p">[</span><span class="n">NEGTV</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="p">[</span><span class="s1">&#39;diff&#39;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
            <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">categories</span><span class="p">[</span><span class="n">INCMP</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="p">[</span><span class="n">INCMP</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
            <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">categories</span><span class="p">[</span><span class="n">UNKWN</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="p">[</span><span class="n">UNKWN</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
            <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">categories</span><span class="p">[</span><span class="n">UNREV</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="p">[</span><span class="kc">None</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
            <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">categories</span><span class="p">[</span><span class="s1">&#39;inconsistent_internal&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                    <span class="p">[</span><span class="s1">&#39;inconsistent_internal&#39;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
            <span class="s1">&#39;inferred_state&#39;</span><span class="p">,</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">categories</span><span class="p">[</span><span class="s1">&#39;inconsistent_external&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                    <span class="p">[</span><span class="s1">&#39;inconsistent_external&#39;</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="c1"># Ensure bookkeeping is taken care of</span>
        <span class="c1"># * positive redundancy</span>
        <span class="c1"># * negative redundancy</span>
        <span class="c1"># * inconsistency</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">pos_redun_nids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">find_pos_redun_nids</span><span class="p">())</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">neg_redun_metagraph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_graph_cls</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">find_neg_redun_nids</span><span class="p">()))</span>

        <span class="c1"># make a node for each PCC, and place an edge between any pccs with at</span>
        <span class="c1"># least one negative edge, with weight being the number of negative</span>
        <span class="c1"># edges. Self loops indicate inconsistency.</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">neg_metagraph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">_graph_cls</span><span class="p">()</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">neg_metagraph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component_labels</span><span class="p">())</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">),</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">ne_to_edges</span><span class="p">[</span><span class="n">NEGTV</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">neg_metagraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>

        <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">nid_to_errors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">nid</span><span class="p">,</span> <span class="n">intern_edges</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">[</span><span class="s1">&#39;inconsistent_internal&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">component_nodes</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
            <span class="n">pos_subgraph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">neg_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">edges_inside</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">neg_graph</span><span class="p">,</span> <span class="n">cc</span><span class="p">))</span>
            <span class="n">recover_hypothesis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">hypothesis_errors</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="p">,</span>
                                                             <span class="n">neg_edges</span><span class="p">))</span>
            <span class="n">nid_to_errors</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">recover_hypothesis</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">recover_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">pos_subgraph</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

        <span class="c1"># Delete old hypothesis</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
            <span class="s1">&#39;maybe_error&#39;</span><span class="p">,</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">infr</span><span class="o">.</span><span class="n">nid_to_errors</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="p">[</span><span class="kc">None</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="c1"># Set new hypothesis</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">set_edge_attrs</span><span class="p">(</span>
            <span class="s1">&#39;maybe_error&#39;</span><span class="p">,</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">nid_to_errors</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="p">[</span><span class="kc">True</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">infr</span><span class="o">.</span><span class="n">nid_to_errors</span> <span class="o">=</span> <span class="n">nid_to_errors</span>

        <span class="c1"># no longer dirty</span>
        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infr</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="NonDynamicUpdate.collapsed_meta_edges"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.NonDynamicUpdate.collapsed_meta_edges">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">collapsed_meta_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collapse the grah such that each PCC is a node. Get a list of edges</span>
<span class="sd">        within/between each PCC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">(</span><span class="n">POSTV</span><span class="p">,</span> <span class="n">NEGTV</span><span class="p">,</span> <span class="n">INCMP</span><span class="p">,</span> <span class="n">UNREV</span><span class="p">,</span> <span class="n">UNKWN</span><span class="p">)</span>
        <span class="n">rev_graph</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">infr</span><span class="o">.</span><span class="n">review_graphs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">graph</span> <span class="ow">is</span> <span class="n">infr</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">graph</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Need to extract relevant subgraphs</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">POSTV</span><span class="p">:</span>
                    <span class="n">rev_graph</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">rev_graph</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span>
                                                             <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rev_graph</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">rev_graph</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="c1"># TODO: Rebalance union find to ensure parents is a single lookup</span>
        <span class="c1"># infr.pos_graph._union_find.rebalance(nodes)</span>
        <span class="c1"># node_to_label = infr.pos_graph._union_find.parents</span>
        <span class="n">node_to_label</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">pos_graph</span><span class="o">.</span><span class="n">_union_find</span>

        <span class="c1"># Get reviewed edges using fast lookup structures</span>
        <span class="n">ne_to_edges</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">nxu</span><span class="o">.</span><span class="n">group_name_edges</span><span class="p">(</span><span class="n">rev_graph</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">node_to_label</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ne_to_edges</span></div>

<div class="viewcode-block" id="NonDynamicUpdate.categorize_edges"><a class="viewcode-back" href="../../../../ibeis.algo.graph.html#ibeis.algo.graph.mixin_dynamic.NonDynamicUpdate.categorize_edges">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">categorize_edges</span><span class="p">(</span><span class="n">infr</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ne_to_edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Non-dynamically computes the status of each edge in the graph.</span>
<span class="sd">        This is can be used to verify the dynamic computations and update when</span>
<span class="sd">        the dynamic state is lost.</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m ibeis.algo.graph.mixin_dynamic categorize_edges --profile</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph.mixin_dynamic import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from ibeis.algo.graph import demo</span>
<span class="sd">            &gt;&gt;&gt; num_pccs = 250 if ut.get_argflag(&#39;--profile&#39;) else 100</span>
<span class="sd">            &gt;&gt;&gt; kwargs = dict(num_pccs=100, p_incon=.3)</span>
<span class="sd">            &gt;&gt;&gt; infr = demo.demodata_infr(infer=False, **kwargs)</span>
<span class="sd">            &gt;&gt;&gt; graph = None</span>
<span class="sd">            &gt;&gt;&gt; cat = infr.categorize_edges()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">(</span><span class="n">POSTV</span><span class="p">,</span> <span class="n">NEGTV</span><span class="p">,</span> <span class="n">INCMP</span><span class="p">,</span> <span class="n">UNREV</span><span class="p">,</span> <span class="n">UNKWN</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ne_to_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ne_to_edges</span> <span class="o">=</span> <span class="n">infr</span><span class="o">.</span><span class="n">collapsed_meta_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

        <span class="c1"># Use reviewed edges to determine status of PCCs (repr by name ids)</span>
        <span class="c1"># The next steps will rectify duplicates in these sets</span>
        <span class="n">name_edges</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">ne_to_edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states</span><span class="p">}</span>

        <span class="c1"># Positive and negative decisions override incomparable and unreviewed</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">UNINFERABLE</span><span class="p">:</span>
            <span class="n">name_edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">name_edges</span><span class="p">[</span><span class="n">POSTV</span><span class="p">])</span>
            <span class="n">name_edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">name_edges</span><span class="p">[</span><span class="n">NEGTV</span><span class="p">])</span>

        <span class="c1"># Negative edges within a PCC signals that an inconsistency exists</span>
        <span class="c1"># Remove inconsistencies from the name edges</span>
        <span class="n">incon_internal_ne</span> <span class="o">=</span> <span class="n">name_edges</span><span class="p">[</span><span class="n">NEGTV</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">name_edges</span><span class="p">[</span><span class="n">POSTV</span><span class="p">])</span>
        <span class="n">name_edges</span><span class="p">[</span><span class="n">POSTV</span><span class="p">]</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">incon_internal_ne</span><span class="p">)</span>
        <span class="n">name_edges</span><span class="p">[</span><span class="n">NEGTV</span><span class="p">]</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">incon_internal_ne</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">name_edges</span><span class="p">[</span><span class="n">POSTV</span><span class="p">]),</span> <span class="p">(</span>
                <span class="s1">&#39;All positive edges should be internal to a PCC&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_edges</span><span class="p">[</span><span class="n">INCMP</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">incon_internal_ne</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_edges</span><span class="p">[</span><span class="n">UNREV</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">incon_internal_ne</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_edges</span><span class="p">[</span><span class="n">UNKWN</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">incon_internal_ne</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">incon_internal_ne</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;incon_internal edges should be internal to a PCC&#39;</span><span class="p">)</span>

        <span class="c1"># External inconsistentices are edges leaving inconsistent components</span>
        <span class="n">incon_internal_nids</span> <span class="o">=</span> <span class="p">{</span><span class="n">n1</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">incon_internal_ne</span><span class="p">}</span>
        <span class="n">incon_external_ne</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="c1"># Find all edges leaving an inconsistent PCC</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">NEGTV</span><span class="p">,)</span> <span class="o">+</span> <span class="n">UNINFERABLE</span><span class="p">:</span>
            <span class="n">incon_external_ne</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)</span> <span class="k">for</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">name_edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">nid1</span> <span class="ow">in</span> <span class="n">incon_internal_nids</span> <span class="ow">or</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">incon_internal_nids</span>
            <span class="p">})</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">NEGTV</span><span class="p">,)</span> <span class="o">+</span> <span class="n">UNINFERABLE</span><span class="p">:</span>
            <span class="n">name_edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">incon_external_ne</span><span class="p">)</span>

        <span class="c1"># Inference between names is now complete.</span>
        <span class="c1"># Now we expand this inference and project the labels onto the</span>
        <span class="c1"># annotation edges corresponding to each name edge.</span>

        <span class="c1"># Version of union that accepts generators</span>
        <span class="n">union</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">gen</span><span class="p">:</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">gen</span><span class="p">)</span>  <span class="c1"># NOQA</span>

        <span class="c1"># Find edges within consistent PCCs</span>
        <span class="n">positive</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">nid1</span><span class="p">:</span> <span class="n">union</span><span class="p">(</span>
                <span class="n">ne_to_edges</span><span class="p">[</span><span class="n">key</span><span class="p">][(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">POSTV</span><span class="p">,)</span> <span class="o">+</span> <span class="n">UNINFERABLE</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">name_edges</span><span class="p">[</span><span class="n">POSTV</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="c1"># Find edges between 1-negative-redundant consistent PCCs</span>
        <span class="n">negative</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">):</span> <span class="n">union</span><span class="p">(</span>
                <span class="n">ne_to_edges</span><span class="p">[</span><span class="n">key</span><span class="p">][(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">NEGTV</span><span class="p">,)</span> <span class="o">+</span> <span class="n">UNINFERABLE</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">name_edges</span><span class="p">[</span><span class="n">NEGTV</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="c1"># Find edges internal to inconsistent PCCs</span>
        <span class="n">incon_internal</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">nid</span><span class="p">:</span> <span class="n">union</span><span class="p">(</span>
                <span class="n">ne_to_edges</span><span class="p">[</span><span class="n">key</span><span class="p">][(</span><span class="n">nid</span><span class="p">,</span> <span class="n">nid</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">POSTV</span><span class="p">,</span> <span class="n">NEGTV</span><span class="p">,)</span> <span class="o">+</span> <span class="n">UNINFERABLE</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">incon_internal_nids</span>
        <span class="p">}</span>
        <span class="c1"># Find edges leaving inconsistent PCCs</span>
        <span class="n">incon_external</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">):</span> <span class="n">union</span><span class="p">(</span>
                <span class="n">ne_to_edges</span><span class="p">[</span><span class="n">key</span><span class="p">][(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">NEGTV</span><span class="p">,)</span> <span class="o">+</span> <span class="n">UNINFERABLE</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span> <span class="ow">in</span> <span class="n">incon_external_ne</span>
        <span class="p">}</span>
        <span class="c1"># Unknown names may have been comparable but the reviewer did not</span>
        <span class="c1"># know and could not guess. Likely bad quality.</span>
        <span class="n">unknown</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">):</span> <span class="n">ne_to_edges</span><span class="p">[</span><span class="n">UNKWN</span><span class="p">][(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">name_edges</span><span class="p">[</span><span class="n">UNKWN</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="c1"># Incomparable names cannot make inference about any other edges</span>
        <span class="n">notcomparable</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">):</span> <span class="n">ne_to_edges</span><span class="p">[</span><span class="n">INCMP</span><span class="p">][(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">name_edges</span><span class="p">[</span><span class="n">INCMP</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="c1"># Unreviewed edges are between any name not known to be negative</span>
        <span class="c1"># (this ignores specific incomparable edges)</span>
        <span class="n">unreviewed</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">):</span> <span class="n">ne_to_edges</span><span class="p">[</span><span class="n">UNREV</span><span class="p">][(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">nid1</span><span class="p">,</span> <span class="n">nid2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">name_edges</span><span class="p">[</span><span class="n">UNREV</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="n">ne_categories</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">POSTV</span><span class="p">:</span> <span class="n">positive</span><span class="p">,</span>
            <span class="n">NEGTV</span><span class="p">:</span> <span class="n">negative</span><span class="p">,</span>
            <span class="n">UNREV</span><span class="p">:</span> <span class="n">unreviewed</span><span class="p">,</span>
            <span class="n">INCMP</span><span class="p">:</span> <span class="n">notcomparable</span><span class="p">,</span>
            <span class="n">UNKWN</span><span class="p">:</span> <span class="n">unknown</span><span class="p">,</span>
            <span class="s1">&#39;inconsistent_internal&#39;</span><span class="p">:</span> <span class="n">incon_internal</span><span class="p">,</span>
            <span class="s1">&#39;inconsistent_external&#39;</span><span class="p">:</span> <span class="n">incon_external</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ne_categories</span></div></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m ibeis.algo.graph.mixin_dynamic</span>
<span class="sd">        python -m ibeis.algo.graph.mixin_dynamic --allexamples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>
    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>  <span class="c1"># for win32</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>  <span class="c1"># NOQA</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Wild Me

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>